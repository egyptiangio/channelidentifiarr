<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Channel Identifiarr - Station Search</title>
    <style>
        :root {
            --bg-primary: #1e1e1e;
            --bg-secondary: #2a2a2a;
            --bg-card: #1a1a2e;
            --bg-input: #2a2a3e;
            --bg-hover: rgba(255, 255, 255, 0.05);
            --text-primary: #e0e0e0;
            --text-secondary: #999;
            --border-color: rgba(255, 255, 255, 0.1);
            --accent-color: #667eea;
            --header-bg: rgba(0, 0, 0, 0.3);
        }

        body.light-mode {
            --bg-primary: #f5f5f5;
            --bg-secondary: #ffffff;
            --bg-card: #ffffff;
            --bg-input: #f8f9fa;
            --bg-hover: rgba(0, 0, 0, 0.05);
            --text-primary: #1a1a1a;
            --text-secondary: #666;
            --border-color: rgba(0, 0, 0, 0.1);
            --accent-color: #667eea;
            --header-bg: rgba(255, 255, 255, 0.95);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: linear-gradient(135deg, var(--bg-primary) 0%, var(--bg-secondary) 100%);
            color: var(--text-primary);
            min-height: 100vh;
            transition: background 0.3s ease, color 0.3s ease;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 15px;
        }

        header {
            background: var(--header-bg);
            padding: 15px 0;
            margin-bottom: 20px;
            border-bottom: 1px solid var(--border-color);
            transition: background 0.3s ease;
        }

        header .container {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header-content {
            flex: 1;
        }

        .theme-toggle {
            background: var(--bg-input);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            padding: 8px 14px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 18px;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 6px;
            user-select: none;
        }

        .theme-toggle:hover {
            background: var(--bg-hover);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        .theme-toggle:active {
            transform: translateY(0);
        }

        h1 {
            font-size: 2rem;
            font-weight: 700;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-align: center;
        }

        .subtitle {
            text-align: center;
            color: #999;
            margin-top: 5px;
            font-size: 0.95rem;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 15px;
            margin-bottom: 25px;
            animation: fadeIn 0.5s ease;
        }

        .stat-item {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .stat-value {
            font-size: 1.6rem;
            font-weight: bold;
            color: #667eea;
        }

        .stat-label {
            color: #999;
            margin-top: 4px;
            font-size: 0.9rem;
        }

        .search-section {
            background: rgba(0, 0, 0, 0.2);
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .dispatcharr-section, .emby-section {
            /* No extra styling needed - padding handled by .tab-content */
        }

        .card {
            background: rgba(0, 0, 0, 0.2);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .search-controls {
            display: flex;
            gap: 8px;
            margin-bottom: 15px;
        }

        #searchInput {
            flex: 1;
        }

        input, select, button, textarea {
            padding: 8px 14px;
            border-radius: 6px;
            border: 1px solid var(--border-color);
            background: var(--bg-input);
            color: var(--text-primary);
            font-size: 14px;
        }

        input:focus, select:focus, textarea:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            cursor: pointer;
            font-weight: bold;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .filters {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .results-section {
            animation: fadeIn 0.5s ease;
        }

        .results-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .results-count {
            font-size: 1.2rem;
            font-weight: bold;
        }

        /* Table Styles */
        .results-table-container {
            overflow-x: auto;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            padding: 10px;
        }

        .results-table {
            width: 100%;
            border-collapse: collapse;
        }

        .results-table th {
            background: rgba(102, 126, 234, 0.2);
            color: #e0e0e0;
            padding: 12px;
            text-align: left;
            font-weight: 600;
            position: sticky;
            top: 0;
            z-index: 10;
            cursor: pointer;
            user-select: none;
            white-space: nowrap;
        }

        .results-table th:hover {
            background: rgba(102, 126, 234, 0.3);
        }

        .results-table th.sortable::after {
            content: ' ‚Üï';
            opacity: 0.4;
            font-size: 0.8em;
        }

        .results-table th.sorted-asc::after {
            content: ' ‚Üë';
            opacity: 1;
        }

        .results-table th.sorted-desc::after {
            content: ' ‚Üì';
            opacity: 1;
        }

        .results-table td {
            padding: 10px 12px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }

        .results-table tr {
            transition: background 0.2s;
            cursor: pointer;
        }

        .results-table tr:hover {
            background: rgba(255, 255, 255, 0.05);
        }

        .results-table .station-logo-small {
            width: 50px;
            height: 38px;
            object-fit: contain;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
            padding: 2px;
            display: block;
        }

        .results-table .no-logo-cell {
            color: #999;
            font-size: 0.9em;
            font-style: italic;
        }

        .result-header {
            display: flex;
            justify-content: space-between;
            align-items: start;
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .station-name {
            font-size: 1.2rem;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .station-id {
            color: #999;
            font-size: 0.9rem;
        }

        .station-logo {
            width: 80px;
            height: 60px;
            object-fit: contain;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
            padding: 4px;
        }

        .logo-indicator {
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.85rem;
            font-weight: bold;
        }

        .has-logo {
            background: rgba(76, 175, 80, 0.2);
            color: #4CAF50;
        }

        .no-logo {
            background: rgba(244, 67, 54, 0.2);
            color: #F44336;
        }

        .result-details {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .detail-item {
            display: flex;
            flex-direction: column;
        }

        .detail-label {
            color: #999;
            font-size: 0.85rem;
            margin-bottom: 2px;
        }

        .detail-value {
            font-weight: 500;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #999;
        }

        .spinner {
            border: 3px solid rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            border-top: 3px solid #667eea;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes progress-slide {
            0% {
                background-position: 0% 0%;
            }
            100% {
                background-position: 100% 0%;
            }
        }

        .error {
            background: rgba(244, 67, 54, 0.1);
            border: 1px solid rgba(244, 67, 54, 0.3);
            color: #ff6b6b;
            padding: 15px;
            border-radius: 6px;
            margin: 20px 0;
        }

        .hidden {
            display: none;
        }

        /* Tab Styles */
        .tabs {
            display: flex;
            gap: 8px;
            margin-bottom: 15px;
            border-bottom: 2px solid rgba(255, 255, 255, 0.1);
            padding-bottom: 8px;
        }

        .tab-button {
            padding: 8px 16px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px 6px 0 0;
            color: #999;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 14px;
        }

        .tab-button:hover {
            background: rgba(255, 255, 255, 0.08);
        }

        .tab-button.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-color: transparent;
        }

        .tab-content {
            display: none;
            padding: 15px;
        }

        .tab-content.active {
            display: block;
        }

        /* Modal Styles */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal-content {
            background: #2a2a2a;
            border-radius: 10px;
            width: 90%;
            max-width: 800px;
            max-height: 90vh;
            overflow-y: auto;
            padding: 30px;
            position: relative;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: start;
            margin-bottom: 20px;
            padding-bottom: 20px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .modal-title {
            font-size: 1.5rem;
            font-weight: bold;
        }

        .close-button {
            background: none;
            border: none;
            color: #999;
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
        }

        .close-button:hover {
            color: #fff;
        }

        .station-detail-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin-bottom: 20px;
        }

        @media (max-width: 768px) {
            .station-detail-grid {
                grid-template-columns: 1fr;
            }
        }

        .station-detail-item {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.05), rgba(255, 255, 255, 0.02));
            padding: 15px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.08);
            transition: all 0.2s;
        }

        .station-detail-item:hover {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.08), rgba(255, 255, 255, 0.04));
            border-color: rgba(255, 255, 255, 0.12);
            transform: translateY(-1px);
        }

        .station-detail-label {
            color: #999;
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 6px;
            font-weight: 600;
        }

        .station-detail-value {
            font-weight: 500;
            word-break: break-word;
            color: #fff;
            font-size: 0.95rem;
        }

        .station-logo-large {
            max-width: 200px;
            max-height: 150px;
            object-fit: contain;
            margin: 20px 0;
        }
    </style>
</head>
<body>
    <header>
        <div class="container">
            <div class="header-content">
                <h1>üõ∞Ô∏è Channel Identifiarr</h1>
                <div class="subtitle">Gracenote Station Database Search</div>
            </div>
            <div style="display: flex; align-items: center; gap: 10px;">
                <span style="font-size: 0.85em; color: var(--text-muted); opacity: 0.7;">v0.6.2</span>
                <button class="theme-toggle" onclick="toggleTheme()" title="Toggle dark/light mode">
                    <span id="themeIcon">üåô</span>
                </button>
            </div>
        </div>
    </header>

    <!-- Tab Navigation -->
    <div class="container">
        <div class="tabs">
            <button class="tab-button active" onclick="switchTab('search')">üîç Search</button>
            <button id="dispatcharrTabButton" class="tab-button" onclick="switchTab('dispatcharr')" style="display: none;">üì° Dispatcharr Integration</button>
            <button id="embyTabButton" class="tab-button" onclick="switchTab('emby')" style="display: none;">üì∫ Emby Integration</button>
            <button class="tab-button" onclick="switchTab('settings')">‚öôÔ∏è Settings</button>
        </div>
    </div>

    <div class="container">
        <!-- Search Tab Content -->
        <div id="searchTab" class="tab-content active">
            <!-- Stats Section -->
            <div class="stats hidden" id="statsSection">
            <div class="stat-item">
                <div class="stat-value" id="totalStations">-</div>
                <div class="stat-label">Total Stations</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="totalCountries">-</div>
                <div class="stat-label">Countries</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="totalMarkets">-</div>
                <div class="stat-label">Markets</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="totalLineups">-</div>
                <div class="stat-label">Lineups</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="stationsWithLogos">-</div>
                <div class="stat-label">With Logos</div>
            </div>
        </div>

        <!-- Database Metadata -->
        <div id="dbMetadata" style="text-align: center; margin: 20px 0; padding: 15px; background: rgba(0,0,0,0.2); border-radius: 8px; display: none;">
            <div style="color: #999; font-size: 0.85rem; margin-bottom: 5px;">Database Information</div>
            <div style="display: flex; justify-content: center; gap: 20px; flex-wrap: wrap; font-size: 0.9rem;">
                <span>Version: <strong id="dbVersion">-</strong></span>
                <span>‚Ä¢</span>
                <span>Effective Date: <strong id="dbEffectiveDate">-</strong></span>
                <span>‚Ä¢</span>
                <span>Schema: <strong id="dbSchema">-</strong></span>
            </div>
        </div>

        <!-- Search Section -->
        <div class="search-section">
            <div class="search-controls">
                <input type="text" id="searchInput" placeholder="Search by channel name, call sign, or station ID..." autofocus>
                <button id="searchBtn" onclick="performSearch()">üîç Search</button>
                <button onclick="clearSearch()">Clear</button>
            </div>
            <div class="filters">
                <select id="countryFilter">
                    <option value="">All Countries</option>
                    <option value="USA" selected>USA</option>
                </select>
                <select id="typeFilter">
                    <option value="">All Types</option>
                </select>
                <select id="qualityFilter">
                    <option value="">All Qualities</option>
                </select>
                <select id="limitFilter">
                    <option value="20">20 Results</option>
                    <option value="50">50 Results</option>
                    <option value="100" selected>100 Results</option>
                    <option value="200">200 Results</option>
                    <option value="500">500 Results</option>
                    <option value="-1">Unlimited</option>
                </select>
            </div>
        </div>

        <!-- Results Section -->
        <div class="results-section hidden" id="resultsSection">
            <div class="results-header">
                <div class="results-count" id="resultsCount">0 Results</div>
                <button onclick="exportResults()">üì• Export</button>
            </div>
            <div class="results-table-container">
                <table class="results-table">
                    <thead id="resultsTableHead"></thead>
                    <tbody id="resultsTableBody"></tbody>
                </table>
            </div>
        </div>

        <!-- Loading Indicator -->
        <div class="loading hidden" id="loadingSection">
            <div class="spinner"></div>
            <div>Searching database...</div>
        </div>

            <!-- Error Display -->
            <div class="error hidden" id="errorSection"></div>
        </div><!-- End Search Tab -->

        <!-- Channel Matching Tab Content -->
        <!-- Settings Tab Content -->
        <div id="settingsTab" class="tab-content" style="display: none;">
            <div style="display: flex; gap: 20px; max-width: 1400px; margin: 0 auto;">
                <!-- Settings Sidebar -->
                <div style="width: 220px; flex-shrink: 0;">
                    <div style="position: sticky; top: 20px; background: rgba(0, 0, 0, 0.3); border-radius: 10px; padding: 15px;">
                        <h3 style="margin-top: 0; margin-bottom: 15px; font-size: 1.1rem;">‚öôÔ∏è Settings</h3>
                        <nav style="display: flex; flex-direction: column; gap: 4px;">
                            <!-- Database -->
                            <a href="#settings-database" onclick="scrollToSetting('settings-database')" style="padding: 8px 12px; border-radius: 6px; text-decoration: none; color: #999; transition: all 0.2s; display: block; font-size: 0.9rem;" onmouseover="this.style.background='rgba(102, 126, 234, 0.2)'; this.style.color='#667eea';" onmouseout="this.style.background=''; this.style.color='#999';">
                                üíæ Database
                            </a>

                            <!-- Dispatcharr -->
                            <a href="#settings-dispatcharr" onclick="scrollToSetting('settings-dispatcharr')" style="padding: 8px 12px; border-radius: 6px; text-decoration: none; color: #fff; transition: all 0.2s; display: block; font-size: 0.9rem; font-weight: 500;" onmouseover="this.style.background='rgba(102, 126, 234, 0.2)';" onmouseout="this.style.background='';">
                                üì° Dispatcharr
                            </a>
                            <div style="padding-left: 20px; display: flex; flex-direction: column; gap: 2px;">
                                <a href="#settings-dispatcharr-login" onclick="scrollToSetting('settings-dispatcharr-login')" style="padding: 6px 10px; border-radius: 4px; text-decoration: none; color: #999; transition: all 0.2s; display: block; font-size: 0.8rem;" onmouseover="this.style.background='rgba(102, 126, 234, 0.15)'; this.style.color='#667eea';" onmouseout="this.style.background=''; this.style.color='#999';">
                                    Login
                                </a>
                                <a href="#settings-dispatcharr-matching" onclick="scrollToSetting('settings-dispatcharr-matching')" style="padding: 6px 10px; border-radius: 4px; text-decoration: none; color: #999; transition: all 0.2s; display: block; font-size: 0.8rem;" onmouseover="this.style.background='rgba(102, 126, 234, 0.15)'; this.style.color='#667eea';" onmouseout="this.style.background=''; this.style.color='#999';">
                                    Matching
                                </a>
                                <a href="#settings-dispatcharr-streams" onclick="scrollToSetting('settings-dispatcharr-streams')" style="padding: 6px 10px; border-radius: 4px; text-decoration: none; color: #999; transition: all 0.2s; display: block; font-size: 0.8rem;" onmouseover="this.style.background='rgba(102, 126, 234, 0.15)'; this.style.color='#667eea';" onmouseout="this.style.background=''; this.style.color='#999';">
                                    Streams
                                </a>
                                <a href="#settings-dispatcharr-channel-creation" onclick="scrollToSetting('settings-dispatcharr-channel-creation')" style="padding: 6px 10px; border-radius: 4px; text-decoration: none; color: #999; transition: all 0.2s; display: block; font-size: 0.8rem;" onmouseover="this.style.background='rgba(102, 126, 234, 0.15)'; this.style.color='#667eea';" onmouseout="this.style.background=''; this.style.color='#999';">
                                    Channel Creation
                                </a>
                                <a href="#settings-dispatcharr-groups" onclick="scrollToSetting('settings-dispatcharr-groups')" style="padding: 6px 10px; border-radius: 4px; text-decoration: none; color: #999; transition: all 0.2s; display: block; font-size: 0.8rem;" onmouseover="this.style.background='rgba(102, 126, 234, 0.15)'; this.style.color='#667eea';" onmouseout="this.style.background=''; this.style.color='#999';">
                                    Groups
                                </a>
                            </div>

                            <!-- Emby -->
                            <a href="#settings-emby" onclick="scrollToSetting('settings-emby')" style="padding: 8px 12px; border-radius: 6px; text-decoration: none; color: #fff; transition: all 0.2s; display: block; font-size: 0.9rem; font-weight: 500; margin-top: 4px;" onmouseover="this.style.background='rgba(102, 126, 234, 0.2)';" onmouseout="this.style.background='';">
                                üì∫ Emby
                            </a>
                            <div style="padding-left: 20px; display: flex; flex-direction: column; gap: 2px;">
                                <a href="#settings-emby-login" onclick="scrollToSetting('settings-emby-login')" style="padding: 6px 10px; border-radius: 4px; text-decoration: none; color: #999; transition: all 0.2s; display: block; font-size: 0.8rem;" onmouseover="this.style.background='rgba(102, 126, 234, 0.15)'; this.style.color='#667eea';" onmouseout="this.style.background=''; this.style.color='#999';">
                                    Login
                                </a>
                            </div>
                        </nav>
                        <div style="margin-top: 20px; padding-top: 15px; border-top: 1px solid rgba(255,255,255,0.1);">
                            <button onclick="saveAllSettings()" class="btn-primary" style="width: 100%;">üíæ Save All</button>
                        </div>
                    </div>
                </div>

                <!-- Settings Content -->
                <div style="flex: 1; overflow-y: auto;">
                    <div style="margin-bottom: 30px;">
                        <p style="color: #999;">Configure your connections and preferences</p>
                    </div>

                    <!-- Database Settings -->
                    <div id="settings-database" class="settings-card" style="background: rgba(0, 0, 0, 0.3); padding: 20px; border-radius: 10px; margin-bottom: 20px; scroll-margin-top: 20px;">
                        <h3>üíæ Database Configuration</h3>
                    <div style="margin-top: 15px;">
                        <label style="display: block; margin-bottom: 5px; color: #999;">Database Path:</label>
                        <input type="text" id="settingsDatabasePath" placeholder="/data/channelidentifiarr.db" value="/data/channelidentifiarr.db" style="width: 100%;">
                        <p style="color: #666; font-size: 0.85rem; margin-top: 5px;">Path to the channelidentifiarr.db file. Set DATABASE_PATH environment variable and restart backend to apply changes.</p>
                    </div>
                    <div style="margin-top: 15px;">
                        <button onclick="testDatabaseConnection()" class="btn-secondary">üîó Test Database</button>
                        <span id="databaseTestResult" style="margin-left: 15px;"></span>
                    </div>

                    <hr style="margin: 25px 0; border: none; border-top: 1px solid rgba(255,255,255,0.1);">

                    <h4 style="margin-bottom: 10px; font-size: 1rem; color: #999;">Database Updates</h4>
                    <p style="color: #666; font-size: 0.85rem; margin-bottom: 15px;">Check for and download updated databases from remote maintainers.</p>

                    <div style="margin-bottom: 15px;">
                        <label style="display: block; margin-bottom: 5px; color: #999;">Remote Database URL:</label>
                        <input type="text" id="settingsRemoteDatabaseUrl" placeholder="https://example.com/channelidentifiarr.db" style="width: 100%;">
                        <p style="color: #666; font-size: 0.85rem; margin-top: 5px;">URL to remote database file. A JSON metadata file (channelidentifiarr.json) must be available in the same directory.</p>
                    </div>

                    <div style="background: rgba(0, 0, 0, 0.2); padding: 15px; border-radius: 6px; margin-bottom: 15px;">
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 10px;">
                            <div>
                                <div style="font-size: 0.85rem; color: #999; margin-bottom: 5px;">Local Version:</div>
                                <div id="localDbVersion" style="font-size: 1rem; font-weight: bold; color: #4a9eff;">Loading...</div>
                                <div id="localDbDate" style="font-size: 0.8rem; color: #666; margin-top: 2px;">-</div>
                            </div>
                            <div>
                                <div style="font-size: 0.85rem; color: #999; margin-bottom: 5px;">Remote Version:</div>
                                <div id="remoteDbVersion" style="font-size: 1rem; font-weight: bold; color: #666;">-</div>
                                <div id="remoteDbDate" style="font-size: 0.8rem; color: #666; margin-top: 2px;">-</div>
                                <div id="remoteDbSize" style="font-size: 0.8rem; color: #666; margin-top: 2px;">-</div>
                            </div>
                        </div>
                        <div id="updateStatus" style="font-size: 0.9rem; color: #4a9eff; text-align: center;"></div>
                    </div>

                    <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px;">
                        <button onclick="checkForDatabaseUpdate()" class="btn-secondary" id="btnCheckUpdate">üîç Check for Updates</button>
                        <button onclick="downloadDatabaseUpdate()" class="btn-primary" id="btnDownloadUpdate" disabled style="opacity: 0.5;">‚¨áÔ∏è Download Update</button>
                        <button onclick="restoreDatabaseBackup()" class="btn-secondary" id="btnRestoreBackup">üîô Restore Backup</button>
                    </div>
                    <div id="downloadProgress" style="margin-top: 15px; display: none;">
                        <div style="background: rgba(0,0,0,0.3); border-radius: 4px; overflow: hidden; height: 24px; position: relative;">
                            <div id="downloadProgressBar" style="background: linear-gradient(90deg, #4a9eff, #6bb6ff); height: 100%; width: 0%; transition: width 0.3s;"></div>
                            <div id="downloadProgressText" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 0.85rem; font-weight: bold;">0%</div>
                        </div>
                    </div>
                </div>

                <!-- Dispatcharr Settings -->
                <div id="settings-dispatcharr" class="settings-card" style="background: rgba(0, 0, 0, 0.3); padding: 20px; border-radius: 10px; margin-bottom: 20px; scroll-margin-top: 20px;">
                    <h3>üì° Dispatcharr Settings</h3>

                    <h4 id="settings-dispatcharr-login" style="margin-top: 20px; margin-bottom: 10px; font-size: 1rem; color: #999; scroll-margin-top: 80px;">Connection Settings</h4>
                    <div style="margin-bottom: 15px;">
                        <label style="display: block; margin-bottom: 5px; color: #999;">Server URL:</label>
                        <input type="text" id="settingsDispatcharrUrl" placeholder="http://192.168.1.100:9191" style="width: 100%;">
                        <div style="font-size: 0.8rem; color: #666; margin-top: 3px;">Include port in URL (default: 9191)</div>
                    </div>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                        <div>
                            <label style="display: block; margin-bottom: 5px; color: #999;">Username:</label>
                            <input type="text" id="settingsDispatcharrUsername" placeholder="admin" style="width: 100%;">
                        </div>
                        <div>
                            <label style="display: block; margin-bottom: 5px; color: #999;">Password:</label>
                            <input type="password" id="settingsDispatcharrPassword" placeholder="password" style="width: 100%;">
                        </div>
                    </div>
                    <div style="margin-top: 15px;">
                        <button onclick="testDispatcharrSettings()" class="btn-secondary">üîó Test & Save</button>
                        <span id="dispatcharrTestResult" style="margin-left: 15px;"></span>
                    </div>

                    <hr style="margin: 25px 0; border: none; border-top: 1px solid rgba(255,255,255,0.1);">

                    <h4 id="settings-dispatcharr-matching" style="margin-bottom: 10px; font-size: 1rem; color: #999; scroll-margin-top: 80px;">Matching Preferences</h4>
                    <p style="color: #666; font-size: 0.85rem; margin-bottom: 15px;">Select which fields to update when applying a match:</p>
                    <div>
                        <label style="display: flex; align-items: center; margin-bottom: 10px;">
                            <input type="checkbox" id="applyStationId" checked style="margin-right: 10px;">
                            <span>Apply Gracenote Station ID (tvc_guide_stationid)</span>
                        </label>
                        <label style="display: flex; align-items: center; margin-bottom: 10px;">
                            <input type="checkbox" id="applyChannelName" style="margin-right: 10px;">
                            <span>Apply channel name</span>
                        </label>
                        <div style="margin-bottom: 10px;">
                            <label style="display: flex; align-items: center; margin-bottom: 10px;">
                                <input type="checkbox" id="applyTvgId" style="margin-right: 10px;" onchange="toggleTvgIdSourceOptions()">
                                <span>Apply TVG-ID (tvg_id)</span>
                            </label>
                            <div style="margin-left: 30px;">
                                <label style="display: flex; align-items: center; margin-bottom: 8px; cursor: pointer;">
                                    <input type="radio" name="tvgIdSource" value="callsign" id="tvgIdSourceCallsign" style="margin-right: 10px;" disabled>
                                    <span id="tvgIdSourceCallsignLabel" style="color: #666;">Use Call Sign</span>
                                </label>
                                <label style="display: flex; align-items: center; margin-bottom: 8px; cursor: pointer;">
                                    <input type="radio" name="tvgIdSource" value="gracenote" id="tvgIdSourceGracenote" style="margin-right: 10px;" disabled>
                                    <span id="tvgIdSourceGracenoteLabel" style="color: #666;">Use Gracenote ID</span>
                                </label>
                                <div id="tvgIdSourceHelp" style="font-size: 0.8rem; color: #666; margin-top: 3px;">Select which value to populate into the TVG-ID field</div>
                            </div>
                        </div>
                        <label style="display: flex; align-items: center; margin-bottom: 10px;">
                            <input type="checkbox" id="applyLogo" checked style="margin-right: 10px;">
                            <span>Apply logo</span>
                        </label>
                    </div>

                    <hr style="margin: 25px 0; border: none; border-top: 1px solid rgba(255,255,255,0.1);">

                    <h4 id="settings-dispatcharr-streams" style="margin-bottom: 10px; font-size: 1rem; color: #999; scroll-margin-top: 80px;">Stream Management</h4>
                    <p style="color: #666; font-size: 0.85rem; margin-bottom: 15px;">Configure stream search and matching behavior:</p>

                    <div style="margin-bottom: 15px;">
                        <label style="display: block; margin-bottom: 5px; color: #999;">Maximum search results:</label>
                        <input type="number" id="streamSearchMaxResults" value="10" min="5" max="50" style="width: 100px;">
                        <div style="font-size: 0.8rem; color: #666; margin-top: 3px;">Number of streams to display in search results (5-50)</div>
                    </div>

                    <div style="margin-bottom: 15px;">
                        <label style="display: block; margin-bottom: 10px; color: #999;">Playlist Priority:</label>
                        <div style="font-size: 0.8rem; color: #666; margin-bottom: 10px;">
                            Drag to reorder playlists by preference. Higher priority playlists will be preferred when multiple matches have similar relevance.
                        </div>
                        <div id="playlistPriorityList" style="background: rgba(0, 0, 0, 0.2); padding: 10px; border-radius: 6px; min-height: 100px;">
                            <div style="text-align: center; color: #666; padding: 20px;">
                                Loading playlists... (requires Dispatcharr connection)
                            </div>
                        </div>
                        <button onclick="loadPlaylistsForSettings()" class="btn-secondary" style="margin-top: 10px;">
                            üîÑ Refresh Playlists
                        </button>
                    </div>

                    <hr style="margin: 25px 0; border: none; border-top: 1px solid rgba(255,255,255,0.1);">

                    <h4 id="settings-dispatcharr-channel-creation" style="margin-bottom: 10px; font-size: 1rem; color: #999; scroll-margin-top: 80px;">Channel Creation Defaults</h4>
                    <p style="color: #666; font-size: 0.85rem; margin-bottom: 15px;">Configure default settings for creating new channels:</p>

                    <div style="margin-bottom: 15px;">
                        <label style="display: block; margin-bottom: 8px; color: #999; font-weight: 500;">Default Group for New Channels:</label>

                        <!-- Current default group display -->
                        <div id="currentDefaultGroupDisplay" style="background: rgba(74, 158, 255, 0.08); border: 1px solid rgba(74, 158, 255, 0.2); padding: 10px 12px; border-radius: 6px; margin-bottom: 12px;">
                            <div style="font-size: 0.75rem; color: #999; margin-bottom: 3px;">Current default:</div>
                            <div id="currentDefaultGroupName" style="font-size: 0.95rem; color: #4a9eff;">No Default Set</div>
                        </div>

                        <!-- Group selector -->
                        <input type="text" id="settingsDefaultGroupFilter" placeholder="Type to search groups..." style="width: 100%; margin-bottom: 8px;" oninput="filterDefaultGroupSelector()">
                        <label style="display: flex; align-items: center; margin-bottom: 8px; cursor: pointer;">
                            <input type="checkbox" id="settingsDefaultGroupShowCustomOnly" onchange="filterDefaultGroupSelector()" style="margin-right: 8px;">
                            <span style="font-size: 0.9rem; color: #999;">Show only custom groups (no M3U)</span>
                        </label>
                        <select id="settingsDefaultGroup" size="6" style="width: 100%; padding: 10px; border-radius: 4px; max-height: 180px; font-size: 0.95rem;" onchange="updateDefaultGroupDisplay()">
                            <option value="">-- No Default --</option>
                        </select>
                        <div id="settingsDefaultGroupStatus" style="font-size: 0.85rem; color: #4a9eff; margin-top: 8px; font-weight: 500;"></div>
                    </div>

                    <div style="margin-bottom: 15px;">
                        <label style="display: block; margin-bottom: 5px; color: #999;">Smart Ranges:</label>
                        <div style="font-size: 0.8rem; color: #666; margin-bottom: 10px;">
                            Define channel number ranges with automatic group assignment. When creating a channel in a range, the associated group will be auto-assigned.
                        </div>
                        <div id="customRangesList" style="background: rgba(0, 0, 0, 0.2); padding: 10px; border-radius: 6px; min-height: 60px; margin-bottom: 10px;">
                            <div style="text-align: center; color: #666; padding: 10px; font-size: 0.85rem;">
                                No Smart Ranges defined
                            </div>
                        </div>
                        <button onclick="openCustomRangesModal()" class="btn-secondary" style="width: 100%;">
                            ‚öôÔ∏è Manage Smart Ranges
                        </button>
                    </div>

                    <hr style="margin: 25px 0; border: none; border-top: 1px solid rgba(255,255,255,0.1);">

                    <h4 id="settings-dispatcharr-groups" style="margin-bottom: 10px; font-size: 1rem; color: #999; scroll-margin-top: 80px;">Manage Groups</h4>
                    <p style="color: #666; font-size: 0.85rem; margin-bottom: 15px;">
                        View and delete channel groups. Groups can only be deleted if they have no channels and no M3U playlist associations.
                    </p>
                    <div id="manageGroupsList" style="background: rgba(0, 0, 0, 0.2); padding: 10px; border-radius: 6px; min-height: 60px; margin-bottom: 10px;">
                        <div style="text-align: center; color: #666; padding: 10px; font-size: 0.85rem;">
                            Loading groups...
                        </div>
                    </div>
                    <div style="display: flex; gap: 10px;">
                        <button onclick="openCreateGroupInManagement()" class="btn-primary" style="flex: 1;">
                            ‚ûï Create Group
                        </button>
                        <button onclick="loadGroupsForManagement()" class="btn-secondary" style="flex: 1;">
                            üîÑ Refresh
                        </button>
                    </div>
                </div>

                <!-- Emby Settings -->
                <div id="settings-emby" class="settings-card" style="background: rgba(0, 0, 0, 0.3); padding: 20px; border-radius: 10px; margin-bottom: 20px; scroll-margin-top: 20px;">
                    <h3>üì∫ Emby Settings</h3>

                    <h4 id="settings-emby-login" style="margin-top: 20px; margin-bottom: 10px; font-size: 1rem; color: #999; scroll-margin-top: 80px;">Connection Settings</h4>
                    <div style="margin-bottom: 15px;">
                        <label style="display: block; margin-bottom: 5px; color: #999;">Server URL:</label>
                        <input type="text" id="settingsEmbyUrl" placeholder="http://192.168.1.100:8096" style="width: 100%;">
                        <div style="font-size: 0.8rem; color: #666; margin-top: 3px;">Include port in URL (default: 8096)</div>
                    </div>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                        <div>
                            <label style="display: block; margin-bottom: 5px; color: #999;">Username:</label>
                            <input type="text" id="settingsEmbyUsername" placeholder="admin" style="width: 100%;">
                        </div>
                        <div>
                            <label style="display: block; margin-bottom: 5px; color: #999;">Password:</label>
                            <input type="password" id="settingsEmbyPassword" placeholder="password" style="width: 100%;">
                        </div>
                    </div>
                    <div style="margin-top: 15px;">
                        <button onclick="testEmbySettings()" class="btn-secondary">üîó Test & Save</button>
                        <span id="embyTestResult" style="margin-left: 15px;"></span>
                    </div>
                </div>

                </div><!-- End Settings Content -->
            </div><!-- End Settings Container -->
        </div><!-- End Settings Tab -->

        <!-- Dispatcharr Tab Content -->
        <div id="dispatcharrTab" class="tab-content">
            <!-- Connection Status Banner -->
            <div id="dispatcharrConnectionBanner" style="padding: 15px; background: rgba(255, 165, 0, 0.1); border: 1px solid #ffa500; border-radius: 8px; margin-bottom: 20px; display: none;">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <span id="connectionStatusMessage" style="color: #ffa500;">‚ö†Ô∏è Dispatcharr not configured. Please configure settings first.</span>
                    <button onclick="switchTab('settings')" class="btn-secondary" style="padding: 8px 15px;">‚öôÔ∏è Go to Settings</button>
                </div>
            </div>

            <div class="dispatcharr-section">
                <h2>üì° Dispatcharr Channels</h2>
                <div class="dispatcharr-controls" style="display: flex; gap: 10px; margin-bottom: 15px; flex-wrap: nowrap; align-items: center; overflow-x: auto;">
                    <button onclick="openCreateCustomChannelModal()" class="btn-primary" style="padding: 3px 6px; font-size: 11px;">‚ûï Create Channel</button>
                    <button onclick="openCloneLineupModal()" class="btn-primary" style="padding: 3px 6px; font-size: 11px;">üìã Clone Lineup</button>
                    <div style="border-left: 1px solid rgba(255,255,255,0.2); height: 30px; margin: 0 5px;"></div>
                    <button onclick="loadDispatcharrChannels()" style="padding: 3px 6px; font-size: 11px;">üîÑ Refresh Channels</button>
                    <div style="border-left: 1px solid rgba(255,255,255,0.2); height: 30px; margin: 0 5px;"></div>
                    <span style="color: #999; font-size: 0.9rem;">Select:</span>
                    <button onclick="selectAll()" class="btn-secondary" style="padding: 3px 6px; font-size: 11px;">All</button>
                    <button onclick="selectMissingGracenote()" class="btn-secondary" style="padding: 3px 6px; font-size: 11px;">Missing Gracenote ID</button>
                    <button onclick="selectMissingLogo()" class="btn-secondary" style="padding: 3px 6px; font-size: 11px;">Missing Logo</button>
                    <button onclick="selectMissingTvgId()" class="btn-secondary" style="padding: 3px 6px; font-size: 11px;">Missing TVG-ID</button>
                    <div style="flex-grow: 1;"></div>
                    <div style="border-left: 1px solid rgba(255,255,255,0.2); height: 30px; margin: 0 5px;"></div>
                    <button onclick="matchSelectedStations()" class="btn-primary" id="matchSelectedBtn" disabled style="padding: 3px 6px; font-size: 11px;">üéØ Match Selected</button>
                    <button onclick="bulkEditGroup()" class="btn-secondary" id="bulkEditGroupBtn" disabled style="padding: 3px 6px; font-size: 11px;">üìù Edit Selected</button>
                    <button onclick="bulkDeleteChannels()" id="bulkDeleteBtn" disabled style="padding: 3px 6px; font-size: 11px; background: #dc2626; border-color: #dc2626; color: white;">üóëÔ∏è Delete Selected</button>
                </div>

                <!-- Dispatcharr channels table -->
                <div class="results-table-container" style="margin-top: 20px;">
                    <table class="results-table" id="dispatcharrTable" style="table-layout: fixed; width: 100%;">
                        <thead>
                            <tr>
                                <th style="width: 40px;"><input type="checkbox" id="selectAllChannels" onclick="toggleSelectAll()" title="Select/Deselect All"></th>
                                <th style="width: 80px;">Channel #</th>
                                <th style="width: 200px;">Name</th>
                                <th style="width: 120px;">Call Sign</th>
                                <th style="width: 120px;">Gracenote ID</th>
                                <th style="width: 150px;">Group</th>
                                <th style="width: 100px;">Logo</th>
                                <th style="width: 200px;">Actions</th>
                            </tr>
                            <tr>
                                <th></th>
                                <th><input type="text" id="filterChannelNumber" placeholder="# or range" style="width: 100%; padding: 4px; font-size: 12px;" oninput="filterDispatcharrChannels()"></th>
                                <th><input type="text" id="filterName" placeholder="Filter by name..." style="width: 100%; padding: 4px; font-size: 12px;" oninput="filterDispatcharrChannels()"></th>
                                <th><input type="text" id="filterCallSign" placeholder="Filter..." style="width: 100%; padding: 4px; font-size: 12px;" oninput="filterDispatcharrChannels()"></th>
                                <th><input type="text" id="filterGracenoteId" placeholder="Numeric only..." style="width: 100%; padding: 4px; font-size: 12px;" oninput="filterDispatcharrChannels()" onkeypress="return event.charCode >= 48 && event.charCode <= 57"></th>
                                <th><input type="text" id="filterGroup" placeholder="Filter by group..." style="width: 100%; padding: 4px; font-size: 12px;" oninput="filterDispatcharrChannels()"></th>
                                <th>
                                    <select id="filterLogo" style="width: 100%; padding: 4px; font-size: 12px;" onchange="filterDispatcharrChannels()">
                                        <option value="">All</option>
                                        <option value="yes">Yes</option>
                                        <option value="no">No</option>
                                    </select>
                                </th>
                                <th></th>
                            </tr>
                        </thead>
                        <tbody id="dispatcharrTableBody">
                            <tr>
                                <td colspan="8" style="text-align: center; padding: 40px;">
                                    Click "Refresh Channels" to load Dispatcharr channels
                                </td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </div><!-- End Dispatcharr Tab -->

        <!-- Emby Tab Content -->
        <div id="embyTab" class="tab-content" style="display: none;">
            <!-- Connection Status Banner -->
            <div id="embyConnectionBanner" style="padding: 15px; background: rgba(255, 165, 0, 0.1); border: 1px solid #ffa500; border-radius: 8px; margin-bottom: 20px; display: none;">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <span id="embyConnectionStatusMessage" style="color: #ffa500;">‚ö†Ô∏è Emby not configured. Please configure settings first.</span>
                    <button onclick="switchTab('settings')" class="btn-secondary" style="padding: 8px 15px;">‚öôÔ∏è Go to Settings</button>
                </div>
            </div>

            <div class="emby-section">
                <h2>üì∫ Emby Server Integration</h2>
                <p style="color: #999; margin-bottom: 20px;">Manage your Emby Live TV channels and listings</p>

                <!-- Emby Actions -->
                <div class="card" style="margin-bottom: 20px; max-width: 800px;">
                    <h3>üéØ Scan & Add Missing Listings</h3>
                    <p style="color: #999; margin-bottom: 20px;">
                        Channel Identifiarr will automatically add lineup providers to Emby to cover all channels
                        that don't currently have guide data assigned.
                    </p>

                    <div style="background: rgba(0, 100, 255, 0.1); border: 1px solid rgba(0, 100, 255, 0.3); border-radius: 8px; padding: 15px; margin-bottom: 20px;">
                        <h4 style="margin-top: 0; color: #4da6ff;">üìç Location Preferences (Optional)</h4>
                        <p style="color: #999; font-size: 0.9rem; margin-bottom: 15px;">
                            When location is provided, lineups from your market will be preferred. Otherwise,
                            Channel Identifiarr will intelligently select the minimum number of lineups
                            (preferring OTA, then Cable, then Satellite/Streaming) to ensure all channels receive guide data.
                        </p>

                        <div style="display: grid; gap: 15px;">
                            <div>
                                <label style="display: block; margin-bottom: 5px; color: #ccc;">Country:</label>
                                <select id="embyCountrySelect" style="width: 100%; padding: 8px; border-radius: 4px;">
                                    <option value="">Any Country</option>
                                    <option value="USA" selected>USA - United States</option>
                                    <option value="CAN">CAN - Canada</option>
                                    <option value="GBR">GBR - United Kingdom</option>
                                    <option value="AUS">AUS - Australia</option>
                                    <option value="DEU">DEU - Germany</option>
                                    <option value="FRA">FRA - France</option>
                                    <option value="ITA">ITA - Italy</option>
                                    <option value="ESP">ESP - Spain</option>
                                    <option value="NLD">NLD - Netherlands</option>
                                    <option value="BEL">BEL - Belgium</option>
                                    <option value="CHE">CHE - Switzerland</option>
                                    <option value="AUT">AUT - Austria</option>
                                    <option value="SWE">SWE - Sweden</option>
                                    <option value="NOR">NOR - Norway</option>
                                    <option value="DNK">DNK - Denmark</option>
                                    <option value="FIN">FIN - Finland</option>
                                    <option value="IRL">IRL - Ireland</option>
                                    <option value="MEX">MEX - Mexico</option>
                                </select>
                            </div>

                            <div>
                                <label style="display: block; margin-bottom: 5px; color: #ccc;">ZIP/Postal Code:</label>
                                <input type="text" id="embyZipcode" placeholder="e.g., 90210" style="width: 100%; padding: 8px; border-radius: 4px;">
                                <div style="font-size: 0.8rem; color: #666; margin-top: 3px;">Lineups matching this location will be preferred</div>
                            </div>
                        </div>
                    </div>

                    <button onclick="scanEmbyMissingListings()" class="btn-primary" style="padding: 15px; width: 100%;">
                        üì° Scan & Add Listing Providers
                    </button>
                </div>

                <div class="card" style="margin-bottom: 20px; max-width: 800px;">
                    <h3>üõ†Ô∏è Other Channel Tools</h3>
                    <div style="display: grid; gap: 15px; margin-top: 20px;">
                        <!-- Logo Deletion Tool -->
                        <div style="border: 1px solid #444; border-radius: 8px; padding: 15px;">
                            <div style="font-weight: 600; margin-bottom: 10px; font-size: 1rem;">
                                üóëÔ∏è Delete Channel Logos
                            </div>
                            <div style="font-size: 0.85rem; color: #999; margin-bottom: 15px;">
                                Select which logo types to remove from all Live TV channels
                            </div>
                            <div style="display: grid; gap: 8px; margin-bottom: 15px;">
                                <label style="display: flex; align-items: center; cursor: pointer;">
                                    <input type="checkbox" id="logoTypePrimary" checked style="margin-right: 8px; cursor: pointer;">
                                    <span>Primary</span>
                                </label>
                                <label style="display: flex; align-items: center; cursor: pointer;">
                                    <input type="checkbox" id="logoTypeLogoLight" checked style="margin-right: 8px; cursor: pointer;">
                                    <span>LogoLight</span>
                                </label>
                                <label style="display: flex; align-items: center; cursor: pointer;">
                                    <input type="checkbox" id="logoTypeLogoLightColor" checked style="margin-right: 8px; cursor: pointer;">
                                    <span>LogoLightColor</span>
                                </label>
                            </div>
                            <div style="display: flex; gap: 10px;">
                                <button onclick="selectAllLogoTypes()" class="btn-secondary" style="flex: 1; padding: 8px;">
                                    ‚úì Select All
                                </button>
                                <button onclick="deselectAllLogoTypes()" class="btn-secondary" style="flex: 1; padding: 8px;">
                                    ‚úó Deselect All
                                </button>
                                <button onclick="deleteSelectedEmbyLogos()" class="btn-primary" style="flex: 2; padding: 8px;">
                                    üóëÔ∏è Delete Selected
                                </button>
                            </div>
                        </div>

                        <button onclick="clearAllEmbyChannelNumbers()" class="btn-secondary" style="padding: 15px; text-align: left;">
                            üî¢ Clear All Channel Numbers
                            <div style="font-size: 0.85rem; color: #999; margin-top: 5px;">Remove channel numbers from all Live TV channels</div>
                        </button>
                    </div>
                </div>

                <!-- Emby Channels List -->
                <div class="card" id="embyChannelsList" style="display: none;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                        <h3>üì∫ Emby Live TV Channels</h3>
                        <button onclick="loadEmbyChannels()" class="btn-secondary">üîÑ Refresh</button>
                    </div>

                    <div class="results-table-container">
                        <table class="results-table" id="embyChannelsTable">
                            <thead>
                                <tr>
                                    <th>Channel #</th>
                                    <th>Name</th>
                                    <th>Listings ID</th>
                                    <th>Management ID</th>
                                </tr>
                            </thead>
                            <tbody id="embyChannelsTableBody">
                                <tr><td colspan="4" style="text-align: center; padding: 40px; color: #666;">No channels loaded. Click Refresh to load channels.</td></tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div><!-- End Emby Tab -->
    </div>


    <!-- Create Channel Modal -->
    <div id="createChannelModal" class="modal" style="display: none;">
        <div class="modal-content" style="width: 95%; max-width: 1200px; max-height: 90vh; overflow: hidden; display: flex; flex-direction: column;">
            <div class="modal-header">
                <div class="modal-title">‚ûï Create New Channel</div>
                <button class="close-button" onclick="closeCreateChannelModal()">√ó</button>
            </div>

            <div style="display: flex; flex: 1; overflow: hidden;">
                <!-- Main Content -->
                <div style="flex: 1; padding: 25px; overflow-y: auto;">
                <!-- Station Info (Read-only) -->
                <div style="background: rgba(102, 126, 234, 0.1); border: 1px solid #667eea; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                    <h3 style="margin-top: 0; color: #667eea;">üì∫ Source Station</h3>
                    <div id="createChannelStationInfo"></div>
                </div>

                <!-- Channel Configuration -->
                <div style="margin-bottom: 20px;">
                    <h3>üîß Channel Configuration</h3>

                    <!-- Channel Name -->
                    <div style="margin-bottom: 15px;">
                        <label style="display: block; margin-bottom: 5px; color: #999;">Channel Name: <span style="color: #ff6b6b;">*</span></label>
                        <input type="text" id="createChannelName" placeholder="Enter channel name" style="width: 100%;">
                    </div>

                    <!-- Channel Number -->
                    <div style="margin-bottom: 15px;">
                        <label style="display: block; margin-bottom: 5px; color: #999;">Channel Number:</label>
                        <div style="display: flex; gap: 10px; align-items: center; flex-wrap: wrap;">
                            <input type="number" id="createChannelNumber" placeholder="e.g. 101" style="flex: 1; min-width: 120px;" step="0.1">
                            <button onclick="openRangeSelector()" class="btn-secondary" style="padding: 8px 12px; white-space: nowrap;">üìä Smart Range</button>
                            <button onclick="suggestChannelNumber('first')" class="btn-secondary" style="padding: 8px 12px; white-space: nowrap;">First Available</button>
                            <button onclick="suggestChannelNumber('next')" class="btn-secondary" style="padding: 8px 12px; white-space: nowrap;">Highest + 1</button>
                        </div>
                        <div id="channelNumberSuggestion" style="font-size: 0.85rem; color: #999; margin-top: 5px;"></div>
                        <div style="font-size: 0.8rem; color: #666; margin-top: 8px; padding: 8px; background: rgba(102, 126, 234, 0.05); border-radius: 4px; border-left: 3px solid rgba(102, 126, 234, 0.3);">
                            üí° If you select an occupied channel number, you'll be given the option to insert the channel here and automatically shift existing channels up until a gap is found.
                        </div>
                    </div>

                    <!-- Group Assignment -->
                    <div style="margin-bottom: 15px;">
                        <label style="display: block; margin-bottom: 5px; color: #999;">Group: <span style="color: #ff6b6b;">*</span></label>
                        <input type="text" id="createChannelGroupFilter" placeholder="Type to filter groups..." style="width: 100%; margin-bottom: 8px;" oninput="filterGroupsInCreate()">

                        <!-- Create New Group Button -->
                        <button onclick="toggleCreateGroupForm()" class="btn-secondary" style="width: 100%; margin-bottom: 8px; font-size: 0.9rem;">‚ûï Create New Group</button>

                        <!-- Inline Group Creation Form (hidden by default) -->
                        <div id="inlineGroupCreateForm" style="display: none; background: rgba(102, 126, 234, 0.1); border: 1px solid #667eea; padding: 12px; border-radius: 6px; margin-bottom: 8px;">
                            <div style="display: flex; gap: 8px; align-items: center;">
                                <input type="text" id="newGroupName" placeholder="Enter group name (e.g., NEWS)" style="flex: 1;" onkeypress="if(event.key==='Enter') createGroupInline()">
                                <button onclick="createGroupInline()" class="btn-primary" style="padding: 8px 16px; white-space: nowrap;">Create</button>
                                <button onclick="cancelCreateGroupInline()" class="btn-secondary" style="padding: 8px 16px;">Cancel</button>
                            </div>
                            <div id="inlineGroupStatus" style="font-size: 0.85rem; margin-top: 8px;"></div>
                        </div>

                        <label style="display: flex; align-items: center; margin-bottom: 8px; cursor: pointer;">
                            <input type="checkbox" id="createChannelShowCustomOnly" onchange="filterGroupsInCreate()" style="margin-right: 8px;">
                            <span style="font-size: 0.9rem; color: #999;">Show only custom groups (no M3U associations)</span>
                        </label>
                        <select id="createChannelGroup" size="5" style="width: 100%; padding: 10px; border-radius: 4px; max-height: 150px;">
                        </select>
                        <div id="groupFilterStatus" style="font-size: 0.85rem; color: #999; margin-top: 5px;"></div>
                    </div>

                    <!-- Gracenote ID (Read-only) -->
                    <div style="margin-bottom: 15px;">
                        <label style="display: block; margin-bottom: 5px; color: #999;">Gracenote ID:</label>
                        <input type="text" id="createChannelGracenoteId" readonly style="width: 100%; opacity: 0.6; cursor: not-allowed;">
                    </div>

                    <!-- TVG-ID -->
                    <div style="margin-bottom: 15px;">
                        <label style="display: block; margin-bottom: 5px; color: #999;">TVG-ID / Call Sign:</label>
                        <input type="text" id="createChannelTvgId" placeholder="e.g. HBOHD" style="width: 100%;">
                    </div>
                </div>

                <!-- Stream Assignment (Optional) -->
                <div style="margin-bottom: 20px;">
                    <h3>üì° Stream Assignment (Optional)</h3>

                    <!-- Stream Search UI -->
                    <div style="margin-bottom: 15px; background: rgba(0,0,0,0.2); padding: 15px; border-radius: 8px;">
                        <div style="display: flex; gap: 10px; margin-bottom: 10px;">
                            <input type="text" id="createChannelStreamSearch" placeholder="Search for streams..." style="flex: 1;">
                            <button onclick="searchStreamsInCreate('manual')" class="btn-secondary" style="padding: 8px 15px; white-space: nowrap;">üîç Search</button>
                            <button onclick="searchStreamsInCreate('auto')" class="btn-primary" style="padding: 8px 15px; white-space: nowrap;">‚ú® Auto</button>
                        </div>
                        <div id="createChannelStreamSearchResults" style="max-height: 250px; overflow-y: auto;"></div>
                    </div>

                    <!-- Assigned Streams List -->
                    <div style="background: rgba(0,0,0,0.3); border-radius: 8px; padding: 15px; min-height: 60px;">
                        <div style="font-weight: bold; margin-bottom: 10px; color: #999;">Assigned Streams:</div>
                        <div id="createChannelStreamsList">
                            <div style="text-align: center; color: #666;">No streams assigned</div>
                        </div>
                    </div>
                </div>

                <!-- Action Buttons -->
                <div style="display: flex; gap: 10px; justify-content: flex-end; border-top: 1px solid rgba(255,255,255,0.1); padding-top: 20px;">
                    <button onclick="closeCreateChannelModal()" class="btn-secondary">Cancel</button>
                    <button onclick="submitCreateChannel()" class="btn-primary" style="background: #22c55e; border-color: #22c55e;">‚ûï Create Channel</button>
                </div>
                </div>
                <!-- End Main Content -->

                <!-- Sidebar: Existing Channels -->
                <div style="width: 280px; border-left: 1px solid rgba(255,255,255,0.1); background: rgba(0,0,0,0.2); padding: 20px; overflow-y: auto;">
                    <h3 style="margin-top: 0;">üìã Existing Channels</h3>
                    <div style="margin-bottom: 15px;">
                        <input type="text" id="channelSidebarFilter" placeholder="Filter by number or name..." style="width: 100%; padding: 8px; font-size: 0.9rem;" oninput="filterChannelSidebar()">
                    </div>
                    <div id="channelSidebarList" style="font-size: 0.85rem;">
                        <div style="text-align: center; color: #666; padding: 20px;">Loading channels...</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Matching Modal Overlay -->
    <div id="matchingModal" class="modal" style="display: none;">
        <div class="modal-content" style="width: 90%; max-width: 900px;">
            <div class="modal-header" style="position: sticky; top: 0; z-index: 10; border-bottom: 1px solid rgba(255,255,255,0.1);">
                <div class="modal-title">üéØ Channel Matching</div>
                <button class="close-button" onclick="closeMatchingModal()">√ó</button>
            </div>

            <div style="padding: 20px;">
                <!-- Progress Bar -->
                <div id="matchingProgress" style="margin-bottom: 20px;">
                    <div style="background: rgba(102, 126, 234, 0.1); border: 1px solid #667eea; padding: 15px; border-radius: 6px;">
                        <div style="display: flex; justify-content: space-between; margin-bottom: 10px;">
                            <span>Progress: <span id="matchProgress">0</span>/<span id="matchTotal">0</span></span>
                            <span id="matchPercentage">0%</span>
                        </div>
                        <div style="background: #333; height: 10px; border-radius: 5px; overflow: hidden;">
                            <div id="matchProgressBar" style="width: 0%; height: 100%; background: linear-gradient(90deg, #667eea, #764ba2); transition: width 0.3s;"></div>
                        </div>
                    </div>
                </div>

                <div id="matchingInterface">
                    <!-- Current Channel Being Matched -->
                    <div class="matching-card" style="background: rgba(0, 0, 0, 0.3); padding: 20px; border-radius: 10px; margin-bottom: 20px;">
                        <h3 style="margin: 0 0 15px 0;">Currently Matching:</h3>
                        <div style="margin-bottom: 15px;">
                            <div style="font-size: 1.3rem; font-weight: bold; margin-bottom: 8px;" id="currentChannelName">-</div>
                            <div style="color: #999; font-size: 0.9rem; display: flex; gap: 15px; flex-wrap: wrap;">
                                <span>Channel ID: <span id="currentChannelId">-</span></span>
                                <span>Current Station ID: <span id="currentStationId" style="color: #ff6b6b;">None</span></span>
                            </div>
                        </div>

                        <!-- Parsed Info -->
                        <div id="parsedInfo" style="padding: 12px; background: rgba(255, 255, 255, 0.05); border-radius: 6px; border-left: 3px solid #667eea;">
                            <div style="font-size: 0.85rem; color: #999; margin-bottom: 8px;">üìã Parsed Analysis:</div>
                            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 10px; font-size: 0.9rem;">
                                <div><span style="color: #999;">Clean Name:</span> <strong id="parsedCleanName">-</strong></div>
                                <div><span style="color: #999;">Country:</span> <strong id="parsedCountry">-</strong></div>
                                <div><span style="color: #999;">Resolution:</span> <strong id="parsedResolution">-</strong></div>
                            </div>
                        </div>
                    </div>

                    <!-- Filter Section -->
                    <div id="matchingFilters" style="margin-top: 20px; padding: 15px; background: rgba(102, 126, 234, 0.1); border: 1px solid rgba(102, 126, 234, 0.3); border-radius: 8px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; cursor: pointer;" onclick="toggleMatchingFilters()">
                            <h3 style="margin: 0; font-size: 1rem;">üîç Filters <span style="color: #999; font-size: 0.85rem; font-weight: normal;">(from parsed data)</span></h3>
                            <span id="filterToggleIcon" style="font-size: 1.2rem;">‚ñ∂</span>
                        </div>
                        <div id="filterControls" style="display: none; margin-top: 15px;">
                            <!-- Country Filter -->
                            <div style="margin-bottom: 12px;">
                                <label style="display: block; font-size: 0.9rem; color: #999; margin-bottom: 5px;">
                                    Country <span id="countryAutoDetected" style="color: #667eea; font-size: 0.85rem;"></span>
                                </label>
                                <select id="filterCountry" onchange="filtersManuallyModified = true; applyMatchingFilters()" style="width: 100%; padding: 8px; border-radius: 4px; background: rgba(0, 0, 0, 0.3); border: 1px solid rgba(255, 255, 255, 0.2); color: white;">
                                    <option value="">All Countries</option>
                                    <option value="USA">USA</option>
                                    <option value="CAN">Canada</option>
                                    <option value="GBR">United Kingdom</option>
                                    <option value="AUS">Australia</option>
                                    <option value="MEX">Mexico</option>
                                </select>
                            </div>

                            <!-- Resolution Filter -->
                            <div style="margin-bottom: 12px;">
                                <label style="display: block; font-size: 0.9rem; color: #999; margin-bottom: 5px;">
                                    Quality/Resolution <span id="resolutionAutoDetected" style="color: #667eea; font-size: 0.85rem;"></span>
                                </label>
                                <div style="display: flex; gap: 15px; flex-wrap: wrap;">
                                    <label style="display: flex; align-items: center; gap: 5px; cursor: pointer;">
                                        <input type="checkbox" id="filterSD" value="SD" onchange="filtersManuallyModified = true; applyMatchingFilters()" checked>
                                        <span>SD</span>
                                    </label>
                                    <label style="display: flex; align-items: center; gap: 5px; cursor: pointer;">
                                        <input type="checkbox" id="filterHD" value="HD" onchange="filtersManuallyModified = true; applyMatchingFilters()" checked>
                                        <span>HD</span>
                                    </label>
                                    <label style="display: flex; align-items: center; gap: 5px; cursor: pointer;">
                                        <input type="checkbox" id="filterUHD" value="UHD" onchange="filtersManuallyModified = true; applyMatchingFilters()" checked>
                                        <span>UHD/4K</span>
                                    </label>
                                </div>
                            </div>

                            <!-- Filter Actions -->
                            <div style="display: flex; gap: 10px; margin-top: 15px;">
                                <button onclick="resetMatchingFilters()" class="btn-secondary" style="padding: 6px 12px; font-size: 0.9rem;">Reset to Auto</button>
                                <button onclick="clearAllMatchingFilters()" class="btn-secondary" style="padding: 6px 12px; font-size: 0.9rem;">Clear All</button>
                            </div>
                        </div>
                    </div>

                    <!-- Suggested Matches -->
                    <div class="matching-suggestions" style="margin-top: 20px;">
                        <h3>Suggested Matches:</h3>
                        <div id="suggestedMatches" style="margin-top: 15px;">
                            <!-- Will be populated dynamically -->
                        </div>
                    </div>

                    <!-- Manual Search Override -->
                    <div class="manual-search" style="margin-top: 30px; padding: 20px; background: rgba(255, 255, 255, 0.05); border-radius: 10px;">
                        <h3>Manual Search Override</h3>
                        <p style="color: #999; margin-bottom: 15px;">Can't find the right match? Search manually:</p>
                        <div style="display: flex; gap: 10px;">
                            <input type="text" id="manualSearchInput" placeholder="Enter station name or call sign..." style="flex: 1;">
                            <button onclick="performManualSearch()" class="btn-secondary">üîç Search</button>
                        </div>
                        <div id="manualSearchResults" style="margin-top: 15px;">
                            <!-- Will be populated with manual search results -->
                        </div>
                    </div>

                    <!-- Action Buttons -->
                    <div class="matching-actions" style="margin-top: 30px; display: flex; gap: 10px; justify-content: center;">
                        <button onclick="skipCurrentChannel()" class="btn-secondary">‚è≠Ô∏è Skip</button>
                        <button onclick="closeMatchingModal()" class="btn-danger">‚èπÔ∏è Stop Matching</button>
                    </div>
                </div>

                <!-- Results Summary -->
                <div id="matchingResults" style="display: none; margin-top: 30px;">
                    <h3>Matching Complete!</h3>
                    <div id="matchingSummary" style="margin-top: 15px;">
                        <!-- Will be populated with results -->
                    </div>
                    <div style="text-align: center; margin-top: 20px;">
                        <button onclick="closeMatchingModal()" class="btn-primary">Close</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Batch Edit Modal -->
    <!-- Batch Edit Modal removed - future feature -->

    <!-- Custom Notification System -->
    <div id="notificationContainer" style="position: fixed; top: 20px; right: 20px; z-index: 10000; display: flex; flex-direction: column; gap: 10px; max-width: 400px;"></div>

    <!-- Custom Confirmation Modal -->
    <div id="confirmModal" class="modal" style="display: none; z-index: 2000;">
        <div class="modal-content" style="width: 90%; max-width: 500px;">
            <div class="modal-header">
                <div class="modal-title">Confirm Action</div>
            </div>
            <div style="padding: 20px;">
                <p id="confirmMessage" style="color: #ccc; margin-bottom: 25px; white-space: pre-line;"></p>
                <div style="display: flex; gap: 10px; justify-content: flex-end;">
                    <button id="confirmCancel" class="btn-secondary">Cancel</button>
                    <button id="confirmOk" class="btn-primary">Confirm</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Channel Number Range Selector Modal -->
    <div id="rangeSelectorModal" class="modal" style="display: none; z-index: 2000;">
        <div class="modal-content" style="width: 90%; max-width: 650px;">
            <div class="modal-header">
                <div class="modal-title">üìä Select Channel Number Range</div>
                <button class="close-button" onclick="closeRangeSelector()">√ó</button>
            </div>
            <div style="padding: 20px;">
                <div style="margin-bottom: 20px;">
                    <h3 style="margin-top: 0; margin-bottom: 15px; color: #999;">Your Smart Ranges</h3>
                    <div style="font-size: 0.85rem; color: #666; margin-bottom: 10px;">
                        Select a range to auto-fill channel number and assign group
                    </div>
                    <div id="suggestedRangesList" style="display: grid; gap: 10px;">
                        <!-- Populated by JavaScript -->
                    </div>
                </div>

                <div style="border-top: 1px solid rgba(255,255,255,0.1); padding-top: 20px;">
                    <h3 style="margin-top: 0; margin-bottom: 15px; color: #999;">One-Time Range</h3>
                    <div style="font-size: 0.85rem; color: #666; margin-bottom: 10px;">
                        Enter a one-time range for this channel only (won't auto-assign group)
                    </div>
                    <div style="display: grid; grid-template-columns: 1fr auto 1fr; gap: 10px; align-items: center; margin-bottom: 10px;">
                        <input type="number" id="customRangeStart" placeholder="Start (e.g. 5001)" step="1" min="1">
                        <span style="color: #999;">to</span>
                        <input type="number" id="customRangeEnd" placeholder="End (e.g. 6000)" step="1" min="1">
                    </div>
                    <button onclick="applyCustomRange()" class="btn-primary" style="width: 100%; margin-bottom: 10px;">Apply Range</button>
                    <div id="customRangeStatus" style="font-size: 0.85rem; color: #999;"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Edit Group Modal -->
    <div id="editGroupModal" class="modal" style="display: none; z-index: 2000;">
        <div class="modal-content" style="width: 90%; max-width: 500px;">
            <div class="modal-header">
                <div class="modal-title">‚úèÔ∏è Edit Group</div>
                <button class="close-button" onclick="closeEditGroupModal()">√ó</button>
            </div>
            <div style="padding: 20px;">
                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 5px; color: #999;">Group Name:</label>
                    <input type="text" id="editGroupName" placeholder="Enter group name" style="width: 100%;">
                </div>
                <div id="editGroupInfo" style="font-size: 0.85rem; color: #999; margin-bottom: 15px; padding: 10px; background: rgba(255,255,255,0.05); border-radius: 6px;">
                    <!-- Info will be populated by JS -->
                </div>
                <div style="display: flex; gap: 10px;">
                    <button onclick="saveGroupEdit()" class="btn-primary" style="flex: 1;">üíæ Save</button>
                    <button onclick="closeEditGroupModal()" class="btn-secondary" style="flex: 1;">Cancel</button>
                </div>
                <div id="editGroupStatus" style="margin-top: 10px; font-size: 0.85rem;"></div>
            </div>
        </div>
    </div>

    <!-- Smart Ranges Management Modal -->
    <div id="customRangesModal" class="modal" style="display: none; z-index: 2000;">
        <div class="modal-content" style="width: 90%; max-width: 800px; max-height: 80vh; display: flex; flex-direction: column;">
            <div class="modal-header">
                <div class="modal-title">üìä Manage Smart Ranges</div>
                <button class="close-button" onclick="closeCustomRangesModal()">√ó</button>
            </div>
            <div style="padding: 20px; overflow-y: auto; flex: 1;">
                <div style="margin-bottom: 20px;">
                    <p style="color: #999; font-size: 0.9rem;">Define channel number ranges with automatic group assignment. Ranges are automatically linked to groups by matching names.</p>
                </div>

                <!-- Existing Ranges List -->
                <div id="customRangesModalList" style="margin-bottom: 20px;">
                    <!-- Populated by JS -->
                </div>

                <!-- Add New Range Section -->
                <div style="background: rgba(102, 126, 234, 0.1); border: 1px solid #667eea; padding: 15px; border-radius: 8px;">
                    <h4 style="margin-top: 0; margin-bottom: 15px; color: #667eea;">‚ûï Add New Range</h4>
                    <div style="display: grid; grid-template-columns: 2fr 1fr 1fr; gap: 10px; margin-bottom: 10px;">
                        <div>
                            <label style="display: block; margin-bottom: 5px; color: #999; font-size: 0.85rem;">Range Name:</label>
                            <input type="text" id="newRangeName" placeholder="e.g., SPORTS, NEWS" style="width: 100%;">
                        </div>
                        <div>
                            <label style="display: block; margin-bottom: 5px; color: #999; font-size: 0.85rem;">Start:</label>
                            <input type="number" id="newRangeStart" placeholder="e.g., 1001" min="1" step="1" style="width: 100%;">
                        </div>
                        <div>
                            <label style="display: block; margin-bottom: 5px; color: #999; font-size: 0.85rem;">End:</label>
                            <input type="number" id="newRangeEnd" placeholder="e.g., 2000" min="1" step="1" style="width: 100%;">
                        </div>
                    </div>
                    <button onclick="addRangeFromModal()" class="btn-primary" style="width: 100%;">‚ûï Add Range</button>
                    <div id="addRangeStatus" style="margin-top: 10px; font-size: 0.85rem;"></div>
                </div>
            </div>
            <div style="padding: 15px; border-top: 1px solid rgba(255,255,255,0.1); display: flex; gap: 10px;">
                <button onclick="saveCustomRangesFromModal()" class="btn-primary" style="flex: 1;">üíæ Save All Changes</button>
                <button onclick="closeCustomRangesModal()" class="btn-secondary">Close</button>
            </div>
        </div>
    </div>

    <!-- Channel Shift Preview Modal -->
    <div id="shiftPreviewModal" class="modal" style="display: none; z-index: 1100;">
        <div class="modal-content" style="max-width: 800px; max-height: 90vh; display: flex; flex-direction: column;">
            <div class="modal-header">
                <div class="modal-title">üîÑ Channel Number Occupied - Shift Existing Channels?</div>
                <button class="close-button" onclick="closeShiftPreviewModal()">√ó</button>
            </div>

            <div style="padding: 20px; overflow-y: auto; flex: 1;">
                <!-- Summary Section -->
                <div style="background: rgba(102, 126, 234, 0.1); border: 1px solid #667eea; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                    <h3 style="margin-top: 0; color: #667eea;">üìä Shift Summary</h3>
                    <div style="display: grid; grid-template-columns: auto 1fr; gap: 10px; font-size: 0.95rem;">
                        <strong>Inserting at:</strong>
                        <span id="previewInsertAt"></span>

                        <strong>Shift amount:</strong>
                        <span id="previewShiftAmount"></span>

                        <strong>Affected channels:</strong>
                        <span id="previewCount"></span>

                        <strong>First gap at:</strong>
                        <span id="previewGapAt"></span>

                        <strong>Estimated time:</strong>
                        <span id="previewTime"></span>
                    </div>
                </div>

                <!-- Warnings Section -->
                <div id="previewWarnings"></div>

                <!-- Changes Table -->
                <div style="margin-bottom: 15px;">
                    <h3 style="margin-bottom: 10px;">Channel Changes:</h3>
                    <div style="max-height: 400px; overflow-y: auto; border: 1px solid rgba(255,255,255,0.1); border-radius: 4px;">
                        <table style="width: 100%; border-collapse: collapse;">
                            <thead style="position: sticky; top: 0; background: var(--bg-secondary); z-index: 1;">
                                <tr>
                                    <th style="padding: 8px; text-align: left; border-bottom: 1px solid rgba(255,255,255,0.1);">Channel Name</th>
                                    <th style="padding: 8px; text-align: center; border-bottom: 1px solid rgba(255,255,255,0.1);">Current #</th>
                                    <th style="padding: 8px; text-align: center; border-bottom: 1px solid rgba(255,255,255,0.1);"></th>
                                    <th style="padding: 8px; text-align: center; border-bottom: 1px solid rgba(255,255,255,0.1);">New #</th>
                                    <th style="padding: 8px; text-align: left; border-bottom: 1px solid rgba(255,255,255,0.1);">Group</th>
                                </tr>
                            </thead>
                            <tbody id="previewTableBody"></tbody>
                        </table>
                    </div>
                </div>
            </div>

            <div style="padding: 15px; border-top: 1px solid rgba(255,255,255,0.1); display: flex; gap: 10px; justify-content: flex-end;">
                <button onclick="closeShiftPreviewModal()" class="btn-secondary">Cancel</button>
                <button onclick="confirmChannelShift()" class="btn-primary">‚úì Confirm Shift</button>
            </div>
        </div>
    </div>

    <!-- Channel Shift Progress Modal -->
    <div id="shiftProgressModal" class="modal" style="display: none; z-index: 1100;">
        <div class="modal-content" style="max-width: 500px;">
            <div class="modal-header">
                <div class="modal-title">üîÑ Shifting Channels</div>
            </div>

            <div style="padding: 25px;">
                <p id="shiftProgressText" style="font-size: 1.1rem; margin-bottom: 15px; text-align: center;">Processing 0/0 channels...</p>

                <div style="background: rgba(0,0,0,0.3); border-radius: 8px; height: 30px; overflow: hidden; margin-bottom: 20px;">
                    <div id="shiftProgressFill" style="background: linear-gradient(90deg, #667eea, #764ba2); height: 100%; width: 0%; transition: width 0.3s ease;"></div>
                </div>

                <div id="shiftProgressStatus" style="font-size: 0.9rem; color: #999; text-align: center; min-height: 20px;"></div>
            </div>

            <div style="padding: 15px; border-top: 1px solid rgba(255,255,255,0.1); text-align: center;">
                <button onclick="cancelShiftInProgress()" class="btn-secondary" id="shiftCancelButton">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Clone Lineup Modal -->
    <div id="cloneLineupModal" class="modal" style="display: none; z-index: 1000;">
        <div class="modal-content" style="max-width: 800px; max-height: 90vh; overflow-y: auto;">
            <div class="modal-header">
                <div class="modal-title">üìã Clone Real-World Lineup</div>
                <button onclick="closeCloneLineupModal()" class="btn-secondary" style="position: absolute; right: 20px; top: 20px;">‚úï</button>
            </div>

            <!-- Step 1: Zip Code Search -->
            <div id="cloneStep1" style="padding: 25px;">
                <h3 style="font-size: 1.1rem; margin-bottom: 15px;">Search for a Lineup</h3>
                <p style="color: #999; font-size: 0.9rem; margin-bottom: 20px;">
                    Import channels from real-world lineups (DirecTV, Dish, Cable providers, etc.)
                </p>

                <div style="display: flex; gap: 10px; margin-bottom: 20px;">
                    <input type="text" id="cloneZipCode" placeholder="Enter ZIP code"
                           style="flex: 1; padding: 10px; background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.2); color: white; border-radius: 4px;"
                           onkeypress="if(event.key === 'Enter') searchLineupsByZip()">
                    <select id="cloneCountry" style="padding: 10px; background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.2); color: white; border-radius: 4px;">
                        <option value="">Loading...</option>
                    </select>
                    <button onclick="searchLineupsByZip()" class="btn-primary">üîç Search</button>
                </div>

                <div id="cloneSearchResults" style="display: none;">
                    <div id="cloneLineupList" style="max-height: 300px; overflow-y: auto;"></div>
                </div>
            </div>

            <!-- Step 2: Lineup Preview -->
            <div id="cloneStep2" style="display: none; padding: 25px; border-top: 1px solid rgba(255,255,255,0.1);">
                <h3 style="font-size: 1.1rem; margin-bottom: 15px;">Preview Lineup</h3>

                <div id="clonePreviewInfo" style="background: rgba(0,0,0,0.3); padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                    <div id="clonePreviewName" style="font-weight: 600; margin-bottom: 10px;"></div>
                    <div id="clonePreviewStats" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 10px; color: #999; font-size: 0.9rem;"></div>
                </div>

                <div id="clonePreviewChannels" style="max-height: 200px; overflow-y: auto; background: rgba(0,0,0,0.2); padding: 10px; border-radius: 4px; font-size: 0.85rem; color: #ccc;">
                    <div id="cloneChannelSamples"></div>
                </div>

                <div style="margin-top: 20px; text-align: center;">
                    <button onclick="showCloneConfiguration()" class="btn-primary">Continue to Configuration ‚Üí</button>
                </div>
            </div>

            <!-- Step 3: Configuration -->
            <div id="cloneStep3" style="display: none; padding: 25px; border-top: 1px solid rgba(255,255,255,0.1);">
                <h3 style="font-size: 1.1rem; margin-bottom: 15px;">Import Configuration</h3>

                <!-- Quality Filters -->
                <div style="margin-bottom: 20px;">
                    <label style="font-weight: 600; display: block; margin-bottom: 10px;">Include Quality Types:</label>
                    <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px;">
                        <label style="display: flex; align-items: center; cursor: pointer;">
                            <input type="checkbox" id="cloneIncludeHd" checked style="margin-right: 8px;">
                            <span>HD (HDTV)</span>
                        </label>
                        <label style="display: flex; align-items: center; cursor: pointer;">
                            <input type="checkbox" id="cloneIncludeSd" checked style="margin-right: 8px;">
                            <span>SD (SDTV)</span>
                        </label>
                        <label style="display: flex; align-items: center; cursor: pointer;">
                            <input type="checkbox" id="cloneIncludeUhd" checked style="margin-right: 8px;">
                            <span>4K (UHDTV)</span>
                        </label>
                        <label style="display: flex; align-items: center; cursor: pointer;">
                            <input type="checkbox" id="cloneIncludeUnknown" checked style="margin-right: 8px;">
                            <span>Unknown Quality</span>
                        </label>
                    </div>
                </div>

                <!-- Channel Offset -->
                <div style="margin-bottom: 20px;">
                    <label style="font-weight: 600; display: block; margin-bottom: 10px;">Channel Number Offset:</label>
                    <input type="number" id="cloneChannelOffset" value="0" min="0" max="10000"
                           style="width: 150px; padding: 8px; background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.2); color: white; border-radius: 4px;">
                    <span style="color: #999; font-size: 0.85rem; margin-left: 10px;">Add this value to all channel numbers (e.g., 2000 shifts 1-999 to 2001-2999)</span>
                </div>

                <!-- Data Usage Options -->
                <div style="margin-bottom: 20px;">
                    <label style="font-weight: 600; display: block; margin-bottom: 10px;">Use from Gracenote Database:</label>
                    <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px;">
                        <label style="display: flex; align-items: center; cursor: pointer;">
                            <input type="checkbox" id="cloneUseLogos" checked style="margin-right: 8px;">
                            <span>Channel Logos</span>
                        </label>
                        <label style="display: flex; align-items: center; cursor: pointer;">
                            <input type="checkbox" id="cloneUseCallSign" checked style="margin-right: 8px;">
                            <span>Call Sign (TVG-ID)</span>
                        </label>
                        <label style="display: flex; align-items: center; cursor: pointer;">
                            <input type="checkbox" id="cloneUseStationId" checked style="margin-right: 8px;">
                            <span>Station ID (Gracenote)</span>
                        </label>
                    </div>
                </div>

                <!-- Default Group -->
                <div style="margin-bottom: 20px;">
                    <label style="font-weight: 600; display: block; margin-bottom: 10px;">Assign to Group (optional):</label>
                    <input type="text" id="cloneGroupFilter" placeholder="Type to filter groups..." style="width: 100%; margin-bottom: 8px; padding: 8px; background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.2); color: white; border-radius: 4px;" oninput="filterGroupsInClone()">
                    <label style="display: flex; align-items: center; margin-bottom: 8px; cursor: pointer;">
                        <input type="checkbox" id="cloneShowCustomOnly" onchange="filterGroupsInClone()" style="margin-right: 8px;">
                        <span style="font-size: 0.9rem; color: #999;">Show only custom groups (no M3U associations)</span>
                    </label>
                    <select id="cloneDefaultGroup" size="5" style="width: 100%; padding: 10px; background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.2); color: white; border-radius: 4px; max-height: 150px;">
                        <option value="">-- No Group --</option>
                    </select>
                    <div id="cloneGroupFilterStatus" style="font-size: 0.85rem; color: #999; margin-top: 5px;"></div>
                </div>

                <!-- Channel Number Conflict -->
                <div style="margin-bottom: 20px;">
                    <label style="font-weight: 600; display: block; margin-bottom: 10px;">If channel number already exists in lineup:</label>
                    <select id="cloneNumberConflict" style="width: 100%; padding: 8px; background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.2); color: white; border-radius: 4px;">
                        <option value="skip" selected>Skip (do not import this channel)</option>
                        <option value="overwrite">Overwrite (replace existing channel)</option>
                    </select>
                </div>

                <!-- Existing Station Conflict -->
                <div style="margin-bottom: 20px;">
                    <label style="font-weight: 600; display: block; margin-bottom: 10px;">If station already exists elsewhere in Dispatcharr:</label>
                    <select id="cloneStationConflict" style="width: 100%; padding: 8px; background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.2); color: white; border-radius: 4px;">
                        <option value="skip" selected>Skip (do not import this channel)</option>
                        <option value="move">Move existing channel to lineup location</option>
                        <option value="create">Create again (duplicate station)</option>
                    </select>
                </div>

                <!-- Warning -->
                <div style="background: rgba(255, 193, 7, 0.1); border: 1px solid rgba(255, 193, 7, 0.3); padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                    <div style="font-weight: 600; margin-bottom: 5px;">‚ö†Ô∏è Fresh Install Recommended</div>
                    <div style="font-size: 0.85rem; color: #ffd43b;">
                        Since channel number conflicts may be encountered, this feature works best with a clean Dispatcharr installation. Review your settings before importing.
                    </div>
                </div>

                <div style="display: flex; gap: 10px; justify-content: center;">
                    <button onclick="hideCloneConfiguration()" class="btn-secondary">‚Üê Back to Preview</button>
                    <button onclick="startCloneImport()" class="btn-primary">üöÄ Start Import</button>
                </div>
            </div>

            <!-- Step 4: Import Progress -->
            <div id="cloneStep4" style="display: none; padding: 25px; border-top: 1px solid rgba(255,255,255,0.1);">
                <h3 style="font-size: 1.1rem; margin-bottom: 15px;">Import in Progress</h3>

                <div style="margin-bottom: 20px;">
                    <div id="cloneProgressText" style="font-size: 1rem; margin-bottom: 10px; text-align: center;">Preparing import...</div>

                    <div style="background: rgba(0,0,0,0.3); border-radius: 8px; height: 30px; overflow: hidden; margin-bottom: 15px;">
                        <div id="cloneProgressFill" style="background: linear-gradient(90deg, #667eea, #764ba2); height: 100%; width: 0%; transition: width 0.3s ease;"></div>
                    </div>

                    <div id="cloneProgressStatus" style="font-size: 0.9rem; color: #999; min-height: 60px; max-height: 200px; overflow-y: auto; background: rgba(0,0,0,0.2); padding: 10px; border-radius: 4px;"></div>
                </div>

                <div style="text-align: center;">
                    <button onclick="cancelCloneImport()" class="btn-secondary" id="cloneCancelButton">Cancel Import</button>
                    <button onclick="closeCloneLineupModal()" class="btn-primary" id="cloneFinishButton" style="display: none;">‚úì Finish</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        let currentResults = [];
        let sortColumn = null;
        let sortDirection = 'asc';
        let dispatcharrChannels = [];
        let dispatcharrGroups = [];

        // Channel Matching Variables
        let matchingQueue = [];
        let currentMatchIndex = 0;
        let matchingResults = [];
        let isMatching = false;

        // Track if changes were made in modals (for conditional reload)
        let channelChangedInModal = false;
        let hasIncrementalUpdates = false; // Track if we did immediate row updates (skip full reload)

        // Custom Notification System
        function showNotification(message, type = 'info') {
            const container = document.getElementById('notificationContainer');
            const notification = document.createElement('div');

            const colors = {
                success: '#51cf66',
                error: '#ff6b6b',
                warning: '#ffd43b',
                info: '#667eea'
            };

            const icons = {
                success: '‚úÖ',
                error: '‚ùå',
                warning: '‚ö†Ô∏è',
                info: '‚ÑπÔ∏è'
            };

            notification.style.cssText = `
                background: rgba(0, 0, 0, 0.9);
                border: 1px solid ${colors[type] || colors.info};
                border-radius: 6px;
                padding: 15px 20px;
                color: white;
                box-shadow: 0 4px 6px rgba(0,0,0,0.3);
                animation: slideIn 0.3s ease;
                display: flex;
                align-items: center;
                gap: 10px;
            `;

            notification.innerHTML = `
                <span style="font-size: 1.2em;">${icons[type] || icons.info}</span>
                <span style="flex: 1; white-space: pre-line;">${message}</span>
                <button onclick="this.parentElement.remove()" style="background: none; border: none; color: #999; cursor: pointer; font-size: 1.5em; padding: 0; width: 20px; height: 20px; display: flex; align-items: center; justify-content: center;">&times;</button>
            `;

            container.appendChild(notification);

            // Auto-remove after 5 seconds
            setTimeout(() => {
                notification.style.animation = 'slideOut 0.3s ease';
                setTimeout(() => notification.remove(), 300);
            }, 5000);
        }

        // Custom Confirmation Dialog
        function showConfirm(message) {
            return new Promise((resolve) => {
                const modal = document.getElementById('confirmModal');
                const messageEl = document.getElementById('confirmMessage');
                const okBtn = document.getElementById('confirmOk');
                const cancelBtn = document.getElementById('confirmCancel');

                messageEl.textContent = message;
                modal.style.display = 'flex';

                const handleOk = () => {
                    cleanup();
                    resolve(true);
                };

                const handleCancel = () => {
                    cleanup();
                    resolve(false);
                };

                const cleanup = () => {
                    modal.style.display = 'none';
                    okBtn.removeEventListener('click', handleOk);
                    cancelBtn.removeEventListener('click', handleCancel);
                };

                okBtn.addEventListener('click', handleOk);
                cancelBtn.addEventListener('click', handleCancel);
            });
        }

        // Add slide animations to CSS
        const style = document.createElement('style');
        style.textContent = `
            @keyframes slideIn {
                from {
                    transform: translateX(400px);
                    opacity: 0;
                }
                to {
                    transform: translateX(0);
                    opacity: 1;
                }
            }
            @keyframes slideOut {
                from {
                    transform: translateX(0);
                    opacity: 1;
                }
                to {
                    transform: translateX(400px);
                    opacity: 0;
                }
            }
        `;
        document.head.appendChild(style);

        // Tab switching function
        async function switchTab(tabName) {
            // Update tab buttons
            document.querySelectorAll('.tab-button').forEach(btn => {
                btn.classList.remove('active');
            });

            // Find and activate the correct button
            const buttons = document.querySelectorAll('.tab-button');
            buttons.forEach(btn => {
                if (btn.textContent.toLowerCase().includes(tabName.toLowerCase())) {
                    btn.classList.add('active');
                }
            });

            // Update tab content
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
                content.style.display = 'none';
            });

            if (tabName === 'search') {
                document.getElementById('searchTab').classList.add('active');
                document.getElementById('searchTab').style.display = 'block';
            } else if (tabName === 'dispatcharr') {
                document.getElementById('dispatcharrTab').classList.add('active');
                document.getElementById('dispatcharrTab').style.display = 'block';
                // Auto-refresh channels when entering tab
                const settings = await getSettings();
                if (settings.dispatcharr && settings.dispatcharr.url) {
                    loadDispatcharrChannels();
                }
            } else if (tabName === 'emby') {
                document.getElementById('embyTab').classList.add('active');
                document.getElementById('embyTab').style.display = 'block';
                // Check Emby configuration
                checkEmbySettings();
            } else if (tabName === 'settings') {
                document.getElementById('settingsTab').classList.add('active');
                document.getElementById('settingsTab').style.display = 'block';
                // Auto-load playlists when entering settings tab
                loadPlaylistsForSettings();
                // Auto-check for database updates if remote URL is configured
                autoCheckDatabaseUpdate();
            }
        }

        // Dispatcharr Connection Check (uses settings from Settings tab)
        async function checkDispatcharrSettings() {
            const settings = await getSettings();

            if (!settings.dispatcharr || !settings.dispatcharr.url) {
                // Show banner if not configured
                const banner = document.getElementById('dispatcharrConnectionBanner');
                if (banner) {
                    banner.style.display = 'block';
                }
                return false;
            }

            // Hide banner if configured
            const banner = document.getElementById('dispatcharrConnectionBanner');
            if (banner) {
                banner.style.display = 'none';
            }
            return true;
        }

        // Emby Connection Check
        async function checkEmbySettings() {
            const settings = await getSettings();

            if (!settings.emby || !settings.emby.url) {
                // Show banner if not configured
                const banner = document.getElementById('embyConnectionBanner');
                if (banner) {
                    banner.style.display = 'block';
                }
                return false;
            }

            // Hide banner if configured
            const banner = document.getElementById('embyConnectionBanner');
            if (banner) {
                banner.style.display = 'none';
            }
            return true;
        }

        // Emby functions
        async function loadEmbyChannels() {
            const tableBody = document.getElementById('embyChannelsTableBody');

            if (!await checkEmbySettings()) {
                tableBody.innerHTML = '<tr><td colspan="4" style="text-align: center; padding: 40px; color: #ff6b6b;">Please configure Emby settings in the Settings tab</td></tr>';
                return;
            }

            const settings = await getSettings();

            tableBody.innerHTML = '<tr><td colspan="4" style="text-align: center; padding: 40px;">Loading channels from Emby...</td></tr>';

            try {
                const response = await fetch('/api/emby/channels', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        url: settings.emby.url,
                        username: settings.emby.username,
                        password: settings.emby.password
                    })
                });

                const data = await response.json();

                if (!response.ok) {
                    throw new Error(data.error || 'Failed to load channels');
                }

                if (!data.channels || data.channels.length === 0) {
                    tableBody.innerHTML = '<tr><td colspan="4" style="text-align: center; padding: 40px; color: #666;">No channels found</td></tr>';
                    return;
                }

                tableBody.innerHTML = '';
                data.channels.forEach(channel => {
                    const row = document.createElement('tr');
                    row.innerHTML = `
                        <td>${channel.ChannelNumber || '-'}</td>
                        <td>${channel.Name || 'Unknown'}</td>
                        <td>${channel.ListingsId || '<span style="color: #ff6b6b;">Not Set</span>'}</td>
                        <td style="font-size: 0.85rem; color: #999;">${channel.ManagementId || '-'}</td>
                    `;
                    tableBody.appendChild(row);
                });

                document.getElementById('embyChannelsList').style.display = 'block';
            } catch (error) {
                tableBody.innerHTML = `<tr><td colspan="4" style="text-align: center; padding: 40px; color: #ff6b6b;">Error: ${error.message}</td></tr>`;
            }
        }

        async function scanEmbyMissingListings() {
            if (!checkEmbySettings()) {
                showNotification('Please configure Emby settings first', 'error');
                return;
            }

            // Get location preferences
            const country = document.getElementById('embyCountrySelect').value;
            const zipcode = document.getElementById('embyZipcode').value.trim();

            let confirmMessage = 'This will scan Emby channels for missing ListingsId and automatically add listing providers.\n\n';
            if (country || zipcode) {
                confirmMessage += `Location preferences:\n`;
                if (country) confirmMessage += `  ‚Ä¢ Country: ${country}\n`;
                if (zipcode) confirmMessage += `  ‚Ä¢ ZIP/Postal Code: ${zipcode}\n`;
                confirmMessage += '\n';
            } else {
                confirmMessage += 'No location specified - will use intelligent lineup selection.\n\n';
            }
            confirmMessage += 'Emby will then map channels to these listings automatically.\n\nContinue?';

            if (!await showConfirm(confirmMessage)) {
                return;
            }

            const settings = await getSettings();

            showNotification('üì° Scanning Emby channels and finding optimal lineups...', 'info');

            try {
                const response = await fetch('/api/emby/scan-missing-listings', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        url: settings.emby.url,
                        username: settings.emby.username,
                        password: settings.emby.password,
                        country: country,
                        zipcode: zipcode
                    })
                });

                const reader = response.body.getReader();
                const decoder = new TextDecoder();

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;

                    const chunk = decoder.decode(value);
                    const lines = chunk.split('\n');

                    for (const line of lines) {
                        if (line.startsWith('data: ')) {
                            const data = JSON.parse(line.slice(6));

                            if (data.done) {
                                let successMessage = `‚úÖ Success!\n\n`;
                                successMessage += `üìä Results:\n`;
                                successMessage += `  ‚Ä¢ Listing providers added: ${data.providers_added || 0}\n`;
                                if (data.providers_failed && data.providers_failed > 0) {
                                    successMessage += `  ‚Ä¢ Failed: ${data.providers_failed}\n`;
                                }
                                successMessage += `  ‚Ä¢ Stations covered: ${data.total_stations || 0}\n\n`;

                                if (data.lineups_selected && data.lineups_selected.length > 0) {
                                    successMessage += `üì° Lineups added:\n`;
                                    data.lineups_selected.forEach(lineup => {
                                        successMessage += `  ‚Ä¢ ${lineup}\n`;
                                    });
                                    successMessage += '\n';
                                }

                                successMessage += `Emby will now automatically map your channels to guide data.`;
                                showNotification(successMessage, 'success');
                            } else {
                                showNotification(`üì° Adding lineup providers...\n\nProcessing: ${data.progress} of ${data.total}\n${data.lineup}\n(${data.lineup_id})`, 'info');
                            }
                        }
                    }
                }
            } catch (error) {
                showNotification(`Failed to scan: ${error.message}`, 'error');
            }
        }

        function selectAllLogoTypes() {
            document.getElementById('logoTypePrimary').checked = true;
            document.getElementById('logoTypeLogoLight').checked = true;
            document.getElementById('logoTypeLogoLightColor').checked = true;
        }

        function deselectAllLogoTypes() {
            document.getElementById('logoTypePrimary').checked = false;
            document.getElementById('logoTypeLogoLight').checked = false;
            document.getElementById('logoTypeLogoLightColor').checked = false;
        }

        async function deleteSelectedEmbyLogos() {
            if (!checkEmbySettings()) {
                showNotification('Please configure Emby settings first', 'error');
                return;
            }

            // Get selected logo types
            const logoTypes = [];
            if (document.getElementById('logoTypePrimary').checked) logoTypes.push('Primary');
            if (document.getElementById('logoTypeLogoLight').checked) logoTypes.push('LogoLight');
            if (document.getElementById('logoTypeLogoLightColor').checked) logoTypes.push('LogoLightColor');

            if (logoTypes.length === 0) {
                showNotification('Please select at least one logo type to delete', 'error');
                return;
            }

            // Build confirmation message
            const logoTypesList = logoTypes.join(', ');
            const confirmMessage = `This will delete the following logo types from all channels:\n\n${logoTypesList}\n\nLogos will be re-downloaded when channels are accessed.\n\nContinue?`;

            if (!await showConfirm(confirmMessage)) {
                return;
            }

            const settings = await getSettings();

            showNotification('üóëÔ∏è Starting logo deletion...', 'info');

            try {
                const response = await fetch('/api/emby/delete-logos', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        url: settings.emby.url,
                        username: settings.emby.username,
                        password: settings.emby.password,
                        logoTypes: logoTypes
                    })
                });

                const reader = response.body.getReader();
                const decoder = new TextDecoder();

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;

                    const chunk = decoder.decode(value);
                    const lines = chunk.split('\n');

                    for (const line of lines) {
                        if (line.startsWith('data: ')) {
                            const data = JSON.parse(line.slice(6));

                            if (data.done) {
                                showNotification(`‚úÖ Successfully deleted ${logoTypesList} logos from ${data.channels_processed} channels`, 'success');
                            } else {
                                showNotification(`üóëÔ∏è Deleting logos...\n\nProcessing: ${data.progress} of ${data.total}\n${data.channel}`, 'info');
                            }
                        }
                    }
                }
            } catch (error) {
                showNotification(`Failed to delete logos: ${error.message}`, 'error');
            }
        }

        async function clearAllEmbyChannelNumbers() {
            if (!checkEmbySettings()) {
                showNotification('Please configure Emby settings first', 'error');
                return;
            }

            if (!await showConfirm('This will clear ALL channel numbers from Emby Live TV channels.\n\nContinue?')) {
                return;
            }

            const settings = await getSettings();

            // Show initial notification
            showNotification('üî¢ Starting channel number clearing...', 'info');

            try {
                const response = await fetch('/api/emby/clear-channel-numbers', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        url: settings.emby.url,
                        username: settings.emby.username,
                        password: settings.emby.password
                    })
                });

                const reader = response.body.getReader();
                const decoder = new TextDecoder();

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;

                    const chunk = decoder.decode(value);
                    const lines = chunk.split('\n');

                    for (const line of lines) {
                        if (line.startsWith('data: ')) {
                            const data = JSON.parse(line.slice(6));

                            if (data.done) {
                                showNotification(`‚úÖ Successfully cleared ${data.channels_cleared} channel numbers`, 'success');
                            } else {
                                showNotification(`üî¢ Clearing channel numbers...\n\nProcessing: ${data.progress} of ${data.total}\n${data.channel}`, 'info');
                            }
                        }
                    }
                }
            } catch (error) {
                showNotification(`Failed to clear channel numbers: ${error.message}`, 'error');
            }
        }

        async function testEmbySettings() {
            const url = document.getElementById('settingsEmbyUrl').value;
            const username = document.getElementById('settingsEmbyUsername').value;
            const password = document.getElementById('settingsEmbyPassword').value;

            const resultSpan = document.getElementById('embyTestResult');
            resultSpan.innerHTML = '<span style="color: #999;">Testing...</span>';

            if (!url) {
                resultSpan.innerHTML = '<span style="color: #ff6b6b;">Please enter Emby URL</span>';
                return;
            }

            try {
                const response = await fetch('/api/emby/test', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ url, username, password })
                });

                const data = await response.json();

                if (response.ok && data.success) {
                    resultSpan.innerHTML = `<span style="color: #51cf66;">‚úÖ Connected! (${data.server_name || 'Emby Server'})</span>`;
                    // Auto-save settings and show tab on successful connection
                    try {
                        saveAllSettings();
                    } catch (e) {
                        console.error('Error saving settings:', e);
                    }
                } else {
                    resultSpan.innerHTML = `<span style="color: #ff6b6b;">‚ùå ${data.error || 'Connection failed'}</span>`;
                }
            } catch (error) {
                console.error('Emby test error:', error);
                resultSpan.innerHTML = `<span style="color: #ff6b6b;">‚ùå ${error.message}</span>`;
            }
        }

        // Dispatcharr functions
        async function loadDispatcharrGroups() {
            const settings = await getSettings();

            if (!settings.dispatcharr || !settings.dispatcharr.url) {
                return;
            }

            try {
                const response = await fetch('/api/dispatcharr/groups', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        url: settings.dispatcharr.url,
                        username: settings.dispatcharr.username,
                        password: settings.dispatcharr.password
                    })
                });

                const data = await response.json();

                if (data.groups) {
                    dispatcharrGroups = data.groups;
                    console.log(`Loaded ${dispatcharrGroups.length} groups`);
                }
            } catch (error) {
                console.error('Error loading groups:', error);
            }
        }

        async function loadDispatcharrChannels() {
            const tableBody = document.getElementById('dispatcharrTableBody');

            // Check if we have settings configured
            if (!checkDispatcharrSettings()) {
                tableBody.innerHTML = '<tr><td colspan="7" style="text-align: center; padding: 40px; color: #ff6b6b;">Please configure Dispatcharr settings in the Settings tab</td></tr>';
                return;
            }

            // Get settings from consolidated storage
            const settings = await getSettings();
            const url = settings.dispatcharr.url;
            const username = settings.dispatcharr.username;
            const password = settings.dispatcharr.password;

            tableBody.innerHTML = '<tr><td colspan="7" style="text-align: center; padding: 40px;">Loading channels from Dispatcharr...</td></tr>';

            try {
                const response = await fetch('/api/dispatcharr/channels', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ url, username, password })
                });
                const data = await response.json();

                if (!response.ok) {
                    throw new Error(data.error || 'Failed to load Dispatcharr channels');
                }

                dispatcharrChannels = data.channels || [];
                await loadDispatcharrGroups();  // Load groups for editing
                displayDispatcharrChannels(dispatcharrChannels);

            } catch (error) {
                tableBody.innerHTML = `<tr><td colspan="7" style="text-align: center; padding: 40px; color: #ff6b6b;">Error: ${error.message}</td></tr>`;
            }
        }

        // Removed toggleDispatcharrSettings - settings now in Settings tab only

        function createChannelRow(channel) {
            /**
             * Create a single channel table row (extracted for reusability)
             */
            const row = document.createElement('tr');
            row.setAttribute('data-channel-id', channel.id);

            const hasLogo = channel.logo_url && channel.logo_url.trim() !== '';
            const logoCell = hasLogo
                ? `<img src="${channel.logo_url}" alt="${channel.name}" class="station-logo-small" onerror="this.style.display='none'; this.parentElement.innerHTML='<span class=\\'no-logo-cell\\'>No Logo</span>'">`
                : '<span class="no-logo-cell">No Logo</span>';

            const groupName = (() => {
                const group = dispatcharrGroups.find(g => g.id === channel.group_id);
                return group ? group.name : (channel.group_id ? `Group ${channel.group_id}` : 'Ungrouped');
            })();

            row.innerHTML = `
                <td><input type="checkbox" class="channel-checkbox" data-channel-id="${channel.id}" onchange="updateMatchButtons()"></td>
                <td>${channel.channel_number || 'N/A'}</td>
                <td>${channel.name || 'N/A'}</td>
                <td>${channel.call_sign || 'N/A'}</td>
                <td>${channel.gracenote_id || 'Not Set'}</td>
                <td>${groupName}</td>
                <td>${logoCell}</td>
                <td style="white-space: nowrap;">
                    <button onclick="editDispatcharrChannel(${channel.id})" style="padding: 3px 6px; font-size: 11px; margin-right: 3px;">
                        ‚úèÔ∏è Edit
                    </button>
                    <button onclick="searchAndMatch(${channel.id})" style="padding: 3px 6px; font-size: 11px; margin-right: 3px;">
                        üîç Match
                    </button>
                    <button onclick="manageChannelStreams(${channel.id})" style="padding: 3px 6px; font-size: 11px; ${channel.streams && channel.streams.length > 0 ? 'background: rgba(34, 197, 94, 0.2); border-color: #22c55e; position: relative;' : ''}" ${channel.streams && channel.streams.length > 0 ? `title="${channel.streams.length} stream${channel.streams.length > 1 ? 's' : ''} assigned"` : ''}>
                        üì∫ Streams${channel.streams && channel.streams.length > 0 ? ` <span style="background: #22c55e; color: #000; padding: 0px 4px; border-radius: 10px; font-size: 9px; font-weight: bold; margin-left: 2px;">${channel.streams.length}</span>` : ''}
                    </button>
                </td>
            `;

            return row;
        }

        function updateSingleChannelRow(channelId) {
            /**
             * Update just one channel row in the table (faster than full re-render)
             */
            const channel = dispatcharrChannels.find(ch => ch.id === channelId);
            if (!channel) return;

            const tableBody = document.getElementById('dispatcharrTableBody');
            const existingRow = tableBody.querySelector(`tr[data-channel-id="${channelId}"]`);

            if (existingRow) {
                const newRow = createChannelRow(channel);
                existingRow.replaceWith(newRow);
            }
        }

        function displayDispatcharrChannels(channels) {
            const tableBody = document.getElementById('dispatcharrTableBody');

            if (channels.length === 0) {
                tableBody.innerHTML = '<tr><td colspan="8" style="text-align: center; padding: 40px;">No channels found in Dispatcharr</td></tr>';
                return;
            }

            tableBody.innerHTML = '';
            channels.forEach(channel => {
                const row = createChannelRow(channel);
                tableBody.appendChild(row);
            });

            // Enable/disable action buttons
            updateMatchButtons();
        }

        function filterDispatcharrChannels() {
            // Get filter values
            const channelNumberFilter = document.getElementById('filterChannelNumber').value.trim();
            const nameFilter = document.getElementById('filterName').value.toLowerCase().trim();
            const callSignFilter = document.getElementById('filterCallSign').value.toLowerCase().trim();
            const gracenoteIdFilter = document.getElementById('filterGracenoteId').value.trim();
            const groupFilter = document.getElementById('filterGroup').value.toLowerCase().trim();
            const logoFilter = document.getElementById('filterLogo').value;

            // Parse channel number filter (support ranges like "100-200")
            let channelNumberMin = null;
            let channelNumberMax = null;
            if (channelNumberFilter) {
                if (channelNumberFilter.includes('-')) {
                    const parts = channelNumberFilter.split('-').map(p => parseFloat(p.trim()));
                    if (parts.length === 2 && !isNaN(parts[0]) && !isNaN(parts[1])) {
                        channelNumberMin = Math.min(parts[0], parts[1]);
                        channelNumberMax = Math.max(parts[0], parts[1]);
                    }
                } else {
                    const num = parseFloat(channelNumberFilter);
                    if (!isNaN(num)) {
                        channelNumberMin = num;
                        channelNumberMax = num;
                    }
                }
            }

            // Get all table rows
            const tableBody = document.getElementById('dispatcharrTableBody');
            const rows = tableBody.querySelectorAll('tr');

            rows.forEach(row => {
                // Skip rows that don't have a channel ID (like empty state rows)
                const channelId = row.getAttribute('data-channel-id');
                if (!channelId) {
                    return;
                }

                // Find the channel data
                const channel = dispatcharrChannels.find(ch => ch.id == channelId);
                if (!channel) {
                    return;
                }

                // Apply filters
                let channelNumberMatch = true;
                if (channelNumberMin !== null && channelNumberMax !== null) {
                    const channelNum = parseFloat(channel.channel_number);
                    channelNumberMatch = !isNaN(channelNum) && channelNum >= channelNumberMin && channelNum <= channelNumberMax;
                }

                const nameMatch = !nameFilter || (channel.name && channel.name.toLowerCase().includes(nameFilter));
                const callSignMatch = !callSignFilter || (channel.call_sign && channel.call_sign.toLowerCase().includes(callSignFilter));
                const gracenoteIdMatch = !gracenoteIdFilter || (channel.gracenote_id && channel.gracenote_id.includes(gracenoteIdFilter));

                // For group filter, need to look up group name
                let groupMatch = true;
                if (groupFilter) {
                    const group = dispatcharrGroups.find(g => g.id === channel.group_id);
                    const groupName = group ? group.name : '';
                    groupMatch = groupName.toLowerCase().includes(groupFilter);
                }

                // Logo filter - check if logo_url exists and is not a generic placeholder
                let logoMatch = true;
                if (logoFilter === 'yes') {
                    // Has logo: logo_url must exist, not be empty, and not be a generic placeholder
                    const hasLogo = channel.logo_url &&
                                   typeof channel.logo_url === 'string' &&
                                   channel.logo_url.trim().length > 0 &&
                                   !channel.logo_url.includes('generic');
                    logoMatch = hasLogo;
                } else if (logoFilter === 'no') {
                    // No logo: logo_url is undefined, null, empty string, whitespace, or generic placeholder
                    const hasLogo = channel.logo_url &&
                                   typeof channel.logo_url === 'string' &&
                                   channel.logo_url.trim().length > 0 &&
                                   !channel.logo_url.includes('generic');
                    logoMatch = !hasLogo;
                }

                // Show or hide row based on all filters
                if (channelNumberMatch && nameMatch && callSignMatch && gracenoteIdMatch && groupMatch && logoMatch) {
                    row.style.display = '';
                } else {
                    row.style.display = 'none';
                }
            });

            // Update button states based on visible checked rows
            updateMatchButtons();
        }

        async function smartChannelMatch() {
            if (!await showConfirm('This will attempt to automatically match all channels without Gracenote IDs. Continue?')) {
                return;
            }

            const unmatchedChannels = dispatcharrChannels.filter(ch => !ch.gracenote_id);

            if (unmatchedChannels.length === 0) {
                showNotification('All channels already have Gracenote IDs!');
                return;
            }

            // Switch to matching tab and start the process
            switchTab('matching');
            startChannelMatching();
        }

        function searchForChannel(channelName) {
            // Switch to search tab
            document.querySelector('.tab-button').click();

            // Set search query and perform search
            document.getElementById('searchInput').value = channelName;
            performSearch();
        }

        function escapeQuotes(str) {
            return (str || '').replace(/'/g, "\\'").replace(/"/g, '\\"');
        }

        function editDispatcharrChannel(channelId) {
            // Find the channel in the dispatcharrChannels array
            const channel = dispatcharrChannels.find(ch => ch.id === channelId);

            if (!channel) {
                showNotification('Channel not found');
                return;
            }

            // Reset change tracking flag
            channelChangedInModal = false;

            // Create edit modal
            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.onclick = (e) => {
                if (e.target === modal) {
                    modal.remove();
                    // Improved refresh strategy: skip reload if we already did incremental updates
                    if (hasIncrementalUpdates) {
                        hasIncrementalUpdates = false;
                    } else if (channelChangedInModal) {
                        loadDispatcharrChannels();
                    }
                    channelChangedInModal = false;
                }
            };

            modal.innerHTML = `
                <div class="modal-content">
                    <div class="modal-header">
                        <div>
                            <div class="modal-title">Edit Channel ${channel.channel_number}</div>
                            <div style="color: #999; margin-top: 5px;">Channel ID: ${channel.id}</div>
                        </div>
                        <button class="close-button" onclick="this.closest('.modal').remove(); if (hasIncrementalUpdates) { hasIncrementalUpdates = false; } else if (channelChangedInModal) { loadDispatcharrChannels(); } channelChangedInModal = false;">√ó</button>
                    </div>

                    <div style="margin-top: 20px;">
                        <div style="margin-bottom: 15px;">
                            <label style="display: block; margin-bottom: 5px; color: #999;">Channel Name:</label>
                            <input type="text" id="editChannelName" value="${escapeHtml(channel.name || '')}" style="width: 100%;">
                        </div>

                        <div style="margin-bottom: 15px;">
                            <label style="display: block; margin-bottom: 5px; color: #999;">TVG-ID:</label>
                            <input type="text" id="editChannelCallSign" value="${escapeHtml(channel.call_sign || '')}" style="width: 100%;">
                        </div>

                        <div style="margin-bottom: 15px;">
                            <label style="display: block; margin-bottom: 5px; color: #999;">Gracenote Station ID:</label>
                            <input type="text" id="editChannelGracenoteId" value="${escapeHtml(channel.gracenote_id || '')}" style="width: 100%;">
                        </div>

                        <div style="margin-bottom: 15px;">
                            <label style="display: block; margin-bottom: 5px; color: #999;">Channel Number:</label>
                            <input type="text" id="editChannelNumber" value="${escapeHtml(channel.channel_number || '')}" style="width: 100%;">
                            <div style="font-size: 0.8rem; color: #666; margin-top: 8px; padding: 8px; background: rgba(102, 126, 234, 0.05); border-radius: 4px; border-left: 3px solid rgba(102, 126, 234, 0.3);">
                                üí° If you select an occupied channel number, you'll be given the option to insert the channel here and automatically shift existing channels up until a gap is found. Your current position (${channel.channel_number}) will remain vacant.
                            </div>
                        </div>

                        <div style="margin-top: 25px; display: flex; gap: 10px; justify-content: space-between;">
                            <button onclick="deleteDispatcharrChannel(${channel.id})" class="btn-secondary" style="background: #ff6b6b; border-color: #ff6b6b;">üóëÔ∏è Delete Channel</button>
                            <div style="display: flex; gap: 10px;">
                                <button onclick="this.closest('.modal').remove(); if (hasIncrementalUpdates) { hasIncrementalUpdates = false; } else if (channelChangedInModal) { loadDispatcharrChannels(); } channelChangedInModal = false;" class="btn-secondary">Cancel</button>
                                <button onclick="saveChannelEdits(${channel.id})" class="btn-primary">üíæ Save Changes</button>
                            </div>
                        </div>
                    </div>
                </div>
            `;

            document.body.appendChild(modal);
        }

        function escapeHtml(str) {
            const div = document.createElement('div');
            div.textContent = str;
            return div.innerHTML;
        }

        async function saveChannelEdits(channelId) {
            const settings = await getSettings();

            if (!settings.dispatcharr || !settings.dispatcharr.url) {
                showNotification('Please configure Dispatcharr settings first!');
                return;
            }

            // Find original channel
            const originalChannel = dispatcharrChannels.find(ch => ch.id === channelId);
            if (!originalChannel) {
                showNotification('Channel not found', 'error');
                return;
            }

            // Get edited values
            const newChannelNumber = document.getElementById('editChannelNumber').value;

            const updateData = {
                name: document.getElementById('editChannelName').value,
                call_sign: document.getElementById('editChannelCallSign').value,
                gracenote_id: document.getElementById('editChannelGracenoteId').value,
                channel_number: newChannelNumber
            };

            // INTELLIGENT SHIFT DETECTION: Check if channel number changed and if new number is occupied
            const originalNum = parseFloat(originalChannel.channel_number);
            const newNum = parseFloat(newChannelNumber);

            if (!isNaN(newNum) && originalNum !== newNum) {
                await ensureChannelsLoaded();

                // Check if the new channel number is occupied (exclude the channel being edited)
                const isOccupied = dispatcharrChannels.some(ch => {
                    if (ch.id === channelId) return false; // Exclude the channel being edited
                    const existingNum = parseFloat(ch.channel_number);
                    return !isNaN(existingNum) && existingNum === newNum;
                });

                if (isOccupied) {
                    // New number is taken - automatically plan a shift
                    // EXCLUDE the channel being edited from the shift (it's being moved, not shifted)
                    const plan = await planChannelShift(newNum, 1, channelId);

                    if (plan.affectedChannels.length > 0) {
                        // Show preview modal with option to shift
                        showShiftPreviewModal(plan);

                        // Store channel edit data for after shift
                        pendingChannelData = {
                            channelId: channelId,
                            updateData: updateData,
                            isEdit: true
                        };

                        // Exit here - update will happen after user confirms shift
                        return;
                    }
                    // If no channels to shift (shouldn't happen), fall through to normal update
                }
            }

            // Normal update (no shift)
            try {
                const response = await fetch(`/api/dispatcharr/channels/${channelId}`, {
                    method: 'PATCH',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        url: settings.dispatcharr.url,
                        username: settings.dispatcharr.username,
                        password: settings.dispatcharr.password,
                        update_data: updateData
                    })
                });

                const result = await response.json();

                if (result.success) {
                    showNotification('Channel updated successfully!', 'success');

                    // Update local channel data with the updated channel from API
                    const channelIndex = dispatcharrChannels.findIndex(ch => ch.id == channelId);
                    if (channelIndex !== -1 && result.channel) {
                        dispatcharrChannels[channelIndex] = result.channel;
                        // Update just this channel's row immediately (improved refresh strategy)
                        updateSingleChannelRow(channelId);
                        hasIncrementalUpdates = true;
                    }

                    // Close modal (skip reload since we already updated the row)
                    document.querySelector('.modal').remove();
                } else {
                    showNotification('Failed to update channel: ' + (result.error || 'Unknown error'), 'error');
                }
            } catch (error) {
                showNotification('Error updating channel: ' + error.message, 'error');
            }
        }

        async function deleteDispatcharrChannel(channelId) {
            // Find the channel name for confirmation
            const channel = dispatcharrChannels.find(ch => ch.id === channelId);
            const channelName = channel ? channel.name : `Channel ID ${channelId}`;

            // Confirm deletion
            const confirmed = await showConfirm(
                `Are you sure you want to delete this channel?\n\n${channelName}\n\nThis action cannot be undone.`
            );

            if (!confirmed) {
                return;
            }

            const settings = await getSettings();

            if (!settings.dispatcharr || !settings.dispatcharr.url) {
                showNotification('Please configure Dispatcharr settings first!', 'error');
                return;
            }

            try {
                showNotification('Deleting channel...', 'info');

                const response = await fetch(`/api/dispatcharr/channels/${channelId}/delete`, {
                    method: 'DELETE',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        url: settings.dispatcharr.url,
                        username: settings.dispatcharr.username,
                        password: settings.dispatcharr.password
                    })
                });

                const result = await response.json();

                if (result.success) {
                    showNotification('Channel deleted successfully!', 'success');
                    // Mark that changes were made
                    channelChangedInModal = true;
                    // Close ALL modals (edit modal + confirmation modal)
                    document.querySelectorAll('.modal').forEach(modal => {
                        modal.style.display = 'none';
                        // Remove dynamically created modals
                        if (!modal.id || modal.id === '') {
                            modal.remove();
                        }
                    });
                    // Reload channels to reflect deletion
                    loadDispatcharrChannels();
                } else {
                    showNotification('Failed to delete channel: ' + (result.error || 'Unknown error'), 'error');
                }
            } catch (error) {
                showNotification('Error deleting channel: ' + error.message, 'error');
            }
        }

        // Stream Management Functions
        let cachedM3UAccounts = null;
        let currentStreamManagerChannel = null;
        let currentChannelStreams = [];
        let lastStreamSearchTerm = null;
        let lastStreamSearchMode = 'auto';
        let playlistPriorityOrder = []; // Array of playlist IDs in priority order
        let customRangesData = []; // Array of {start, end, name, groupId}
        let defaultGroupId = null; // Default group ID for new channels
        let editingGroupId = null; // ID of group currently being edited
        let editingGroupChannelCount = 0; // Channel count of group being edited

        async function loadM3UAccounts() {
            // Load M3U accounts if not already cached
            if (cachedM3UAccounts) {
                return;
            }

            const settings = await getSettings();
            if (!settings.dispatcharr || !settings.dispatcharr.url) {
                return;
            }

            try {
                const response = await fetch('/api/dispatcharr/m3u-accounts', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        url: settings.dispatcharr.url,
                        username: settings.dispatcharr.username,
                        password: settings.dispatcharr.password
                    })
                });
                const data = await response.json();
                if (data.success) {
                    cachedM3UAccounts = data.accounts;
                }
            } catch (error) {
                console.error('Failed to fetch M3U accounts:', error);
            }
        }

        async function manageChannelStreams(channelId) {
            const channel = dispatcharrChannels.find(ch => ch.id === channelId);
            if (!channel) {
                showNotification('Channel not found');
                return;
            }

            // Reset change tracking flag
            channelChangedInModal = false;

            currentStreamManagerChannel = channel;
            const settings = await getSettings();

            // Load M3U accounts
            await loadM3UAccounts();

            // Fetch groups if not already loaded
            if (!dispatcharrGroups || dispatcharrGroups.length === 0) {
                try {
                    const response = await fetch('/api/dispatcharr/groups', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            url: settings.dispatcharr.url,
                            username: settings.dispatcharr.username,
                            password: settings.dispatcharr.password
                        })
                    });
                    const data = await response.json();
                    if (data.groups) {
                        dispatcharrGroups = data.groups;
                    }
                } catch (error) {
                    console.error('Failed to fetch groups:', error);
                }
            }

            // Fetch current streams for this channel
            try {
                const response = await fetch(`/api/dispatcharr/channels/${channelId}/streams`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        url: settings.dispatcharr.url,
                        username: settings.dispatcharr.username,
                        password: settings.dispatcharr.password,
                        action: 'get'
                    })
                });
                const data = await response.json();
                if (data.success) {
                    currentChannelStreams = data.streams || [];
                }
            } catch (error) {
                console.error('Failed to fetch channel streams:', error);
                currentChannelStreams = [];
            }

            // Create stream manager modal
            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.onclick = (e) => {
                if (e.target === modal) {
                    modal.remove();
                    // Improved refresh strategy: skip reload if we already did incremental updates
                    if (hasIncrementalUpdates) {
                        hasIncrementalUpdates = false;
                    } else if (channelChangedInModal) {
                        loadDispatcharrChannels();
                    }
                    channelChangedInModal = false;
                }
            };

            modal.innerHTML = `
                <div class="modal-content" style="max-width: 900px; max-height: 85vh; overflow: hidden; display: flex; flex-direction: column;">
                    <div class="modal-header">
                        <div>
                            <div class="modal-title">Manage Streams - ${escapeHtml(channel.name)}</div>
                            <div style="color: #999; margin-top: 5px;">Channel ${channel.channel_number}</div>
                        </div>
                        <button class="close-button" onclick="this.closest('.modal').remove(); if (hasIncrementalUpdates) { hasIncrementalUpdates = false; } else if (channelChangedInModal) { loadDispatcharrChannels(); } channelChangedInModal = false;">√ó</button>
                    </div>

                    <div style="flex: 1; overflow-y: auto; margin-top: 20px;">
                        <!-- Current Streams Section -->
                        <div style="margin-bottom: 25px;">
                            <h3 style="margin-bottom: 10px; display: flex; align-items: center; gap: 10px;">
                                üì∫ Current Streams
                                <span style="font-size: 0.8rem; color: #999;">(${currentChannelStreams.length})</span>
                            </h3>
                            <div id="currentStreamsList" style="background: rgba(0, 0, 0, 0.3); border-radius: 8px; padding: 15px; min-height: 100px;">
                                ${currentChannelStreams.length === 0
                                    ? '<div style="text-align: center; color: #666; padding: 20px;">No streams assigned</div>'
                                    : ''}
                            </div>
                        </div>

                        <!-- Search Section -->
                        <div style="margin-bottom: 25px;">
                            <h3 style="margin-bottom: 10px;">üîç Search for Streams</h3>
                            <div style="display: flex; gap: 10px; margin-bottom: 15px;">
                                <button onclick="autoSearchStreams()" class="btn-primary" style="padding: 8px 15px; white-space: nowrap;">
                                    ‚ö° Auto Search
                                </button>
                                <input type="text" id="streamSearchInput" placeholder="Or manually search..."
                                    style="flex: 1;" onkeypress="if(event.key==='Enter') manualSearchStreams()">
                                <button onclick="manualSearchStreams()" class="btn-secondary" style="padding: 8px 15px;">
                                    üîç Search
                                </button>
                            </div>
                            <div id="streamSearchResults" style="background: rgba(0, 0, 0, 0.2); border-radius: 8px; padding: 15px; min-height: 150px;">
                                <div style="text-align: center; color: #666;">Click "Auto Search" to find matching streams using the channel name</div>
                            </div>
                        </div>
                    </div>

                    <div style="margin-top: 20px; display: flex; gap: 10px; justify-content: flex-end; border-top: 1px solid rgba(255,255,255,0.1); padding-top: 15px;">
                        <button onclick="this.closest('.modal').remove()" class="btn-secondary">Close</button>
                    </div>
                </div>
            `;

            document.body.appendChild(modal);

            // Render current streams with drag-and-drop
            renderCurrentStreams();
        }

        function renderCurrentStreams() {
            const container = document.getElementById('currentStreamsList');
            if (!container) return;

            if (currentChannelStreams.length === 0) {
                container.innerHTML = '<div style="text-align: center; color: #666; padding: 20px;">No streams assigned</div>';
                return;
            }

            container.innerHTML = currentChannelStreams.map((stream, index) => {
                const playlist = cachedM3UAccounts ? cachedM3UAccounts[stream.m3u_account] || `Account ${stream.m3u_account}` : `Account ${stream.m3u_account}`;

                // Get group name if available
                const groupName = stream.channel_group && dispatcharrGroups
                    ? (dispatcharrGroups.find(g => g.id === stream.channel_group)?.name || '')
                    : '';

                return `
                    <div class="stream-item" draggable="true" data-stream-id="${stream.id}" data-index="${index}"
                        style="background: rgba(255,255,255,0.05); padding: 10px; margin-bottom: 8px; border-radius: 6px; cursor: move; border: 1px solid rgba(255,255,255,0.1);"
                        ondragstart="handleStreamDragStart(event)" ondragover="handleStreamDragOver(event)"
                        ondrop="handleStreamDrop(event)" ondragend="handleStreamDragEnd(event)">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <div style="flex: 1;">
                                <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 5px;">
                                    <span style="color: #999; font-size: 0.9rem;">‚ãÆ‚ãÆ</span>
                                    <span style="background: rgba(51, 204, 255, 0.2); color: #33ccff; padding: 2px 8px; border-radius: 4px; font-size: 0.8rem;">
                                        ${playlist}${groupName ? ` <span style="opacity: 0.6; font-size: 0.7rem;">(${escapeHtml(groupName)})</span>` : ''}
                                    </span>
                                    <span style="color: #999; font-size: 0.8rem;">#${index + 1}</span>
                                </div>
                                <div style="font-weight: 500; margin-left: 30px;">${escapeHtml(stream.name)}</div>
                                ${stream.url ? `<div style="font-size: 0.75rem; color: #666; margin-left: 30px; margin-top: 3px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${escapeHtml(stream.url)}</div>` : ''}
                            </div>
                            <button onclick="removeStreamFromChannel(${stream.id})"
                                style="padding: 5px 10px; font-size: 12px; background: rgba(255, 107, 107, 0.2); color: #ff6b6b; border: 1px solid #ff6b6b;">
                                üóëÔ∏è Remove
                            </button>
                        </div>
                    </div>
                `;
            }).join('');
        }

        // Drag and drop handlers
        let draggedStreamElement = null;
        let draggedStreamIndex = null;

        function handleStreamDragStart(e) {
            draggedStreamElement = e.target.closest('.stream-item');
            draggedStreamIndex = parseInt(draggedStreamElement.dataset.index);
            e.dataTransfer.effectAllowed = 'move';
            draggedStreamElement.style.opacity = '0.4';
        }

        function handleStreamDragOver(e) {
            if (e.preventDefault) {
                e.preventDefault();
            }
            e.dataTransfer.dropEffect = 'move';

            const targetElement = e.target.closest('.stream-item');
            if (targetElement && targetElement !== draggedStreamElement) {
                targetElement.style.borderTop = '3px solid #33ccff';
            }
            return false;
        }

        function handleStreamDrop(e) {
            if (e.stopPropagation) {
                e.stopPropagation();
            }

            const targetElement = e.target.closest('.stream-item');
            if (targetElement && draggedStreamElement && targetElement !== draggedStreamElement) {
                const targetIndex = parseInt(targetElement.dataset.index);

                // Reorder the array
                const [movedStream] = currentChannelStreams.splice(draggedStreamIndex, 1);
                currentChannelStreams.splice(targetIndex, 0, movedStream);

                // Re-render and save
                renderCurrentStreams();
                saveStreamOrder();
            }

            // Clear border highlight
            document.querySelectorAll('.stream-item').forEach(item => {
                item.style.borderTop = '';
            });

            return false;
        }

        function handleStreamDragEnd(e) {
            if (draggedStreamElement) {
                draggedStreamElement.style.opacity = '';
            }

            // Clear all border highlights
            document.querySelectorAll('.stream-item').forEach(item => {
                item.style.borderTop = '';
            });
        }

        async function autoSearchStreams() {
            // Use the actual channel name with the smart algorithm
            await performStreamSearch(currentStreamManagerChannel.name, 'auto');
        }

        async function manualSearchStreams() {
            // Use the user-entered search term
            const searchTerm = document.getElementById('streamSearchInput').value.trim();
            if (!searchTerm) {
                const resultsContainer = document.getElementById('streamSearchResults');
                resultsContainer.innerHTML = '<div style="text-align: center; color: #666;">Please enter a search term</div>';
                return;
            }
            await performStreamSearch(searchTerm, 'manual');
        }

        async function performStreamSearch(searchTerm, searchMode = 'auto') {
            const resultsContainer = document.getElementById('streamSearchResults');

            // Store the last search term and mode for re-running after add/remove
            lastStreamSearchTerm = searchTerm;
            lastStreamSearchMode = searchMode;

            resultsContainer.innerHTML = '<div style="text-align: center; color: #999; padding: 20px;">Searching...</div>';

            const settings = await getSettings();

            // Get max results from settings
            const maxResults = (settings.streamManagement && settings.streamManagement.maxResults) || 10;

            // Get playlist priority from settings
            const preferredPlaylists = (settings.streamManagement && settings.streamManagement.playlistPriority) || [];

            try {
                const response = await fetch(`/api/dispatcharr/channels/${currentStreamManagerChannel.id}/search-streams`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        url: settings.dispatcharr.url,
                        username: settings.dispatcharr.username,
                        password: settings.dispatcharr.password,
                        channel_name: searchTerm,  // Use searchTerm as the channel name for matching
                        preferred_playlists: preferredPlaylists,
                        max_results: maxResults,
                        search_mode: searchMode
                    })
                });

                const data = await response.json();

                if (!data.success) {
                    resultsContainer.innerHTML = `<div style="text-align: center; color: #ff6b6b;">Error: ${data.error || 'Search failed'}</div>`;
                    return;
                }

                const results = data.results || [];

                if (results.length === 0) {
                    resultsContainer.innerHTML = '<div style="text-align: center; color: #666;">No matching streams found</div>';
                    return;
                }

                // Filter out already added streams
                const currentStreamIds = new Set(currentChannelStreams.map(s => s.id));
                const availableResults = results.filter(r => !currentStreamIds.has(r.stream.id));

                if (availableResults.length === 0) {
                    resultsContainer.innerHTML = '<div style="text-align: center; color: #666;">All matching streams are already added</div>';
                    return;
                }

                resultsContainer.innerHTML = `
                    <div style="margin-bottom: 10px; color: #999; font-size: 0.9rem;">
                        Found ${availableResults.length} matching stream${availableResults.length > 1 ? 's' : ''}
                        ${data.strategy ? `<span style="color: #666;"> (Strategy: ${data.strategy})</span>` : ''}
                    </div>
                    ${availableResults.slice(0, 20).map(result => {
                        const stream = result.stream;
                        const playlist = cachedM3UAccounts ? cachedM3UAccounts[stream.m3u_account] || `Account ${stream.m3u_account}` : `Account ${stream.m3u_account}`;

                        // Get group name if available
                        const groupName = stream.channel_group && dispatcharrGroups
                            ? (dispatcharrGroups.find(g => g.id === stream.channel_group)?.name || '')
                            : '';

                        // Confidence badge
                        const confidence = result.relevance;
                        let confidenceBadge = '';
                        let confidenceColor = '';
                        if (confidence >= 0.95) {
                            confidenceBadge = 'Excellent';
                            confidenceColor = '#51cf66';
                        } else if (confidence >= 0.85) {
                            confidenceBadge = 'Very Good';
                            confidenceColor = '#94d82d';
                        } else if (confidence >= 0.80) {
                            confidenceBadge = 'Good';
                            confidenceColor = '#ffd43b';
                        } else if (confidence >= 0.70) {
                            confidenceBadge = 'Fair';
                            confidenceColor = '#ff922b';
                        } else {
                            confidenceBadge = 'Low';
                            confidenceColor = '#ff6b6b';
                        }

                        return `
                            <div style="background: rgba(255,255,255,0.05); padding: 12px; margin-bottom: 8px; border-radius: 6px; border: 1px solid rgba(255,255,255,0.1);">
                                <div style="display: flex; justify-content: space-between; align-items: start;">
                                    <div style="flex: 1;">
                                        <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 5px; flex-wrap: wrap;">
                                            <span style="background: rgba(51, 204, 255, 0.2); color: #33ccff; padding: 2px 8px; border-radius: 4px; font-size: 0.8rem;">
                                                ${playlist}${groupName ? ` <span style="opacity: 0.6; font-size: 0.7rem;">(${escapeHtml(groupName)})</span>` : ''}
                                            </span>
                                            <span style="background: rgba(${confidenceColor.replace('#', '')}, 0.2); color: ${confidenceColor}; padding: 2px 8px; border-radius: 4px; font-size: 0.8rem;">
                                                ${confidenceBadge} (${(confidence * 100).toFixed(0)}%)
                                            </span>
                                        </div>
                                        <div style="font-weight: 500; margin-bottom: 3px;">${escapeHtml(stream.name)}</div>
                                        ${stream.url ? `<div style="font-size: 0.75rem; color: #666; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${escapeHtml(stream.url)}</div>` : ''}
                                    </div>
                                    <button onclick="addStreamToChannel(${stream.id}, '${escapeHtml(stream.name).replace(/'/g, "\\'")}', ${stream.m3u_account}, '${escapeHtml(stream.url || '').replace(/'/g, "\\'")}', ${stream.channel_group || 'null'})"
                                        style="padding: 5px 12px; font-size: 12px; margin-left: 10px; white-space: nowrap;">
                                        ‚ûï Add
                                    </button>
                                </div>
                            </div>
                        `;
                    }).join('')}
                    ${availableResults.length > 20 ? `<div style="text-align: center; color: #666; margin-top: 10px; font-size: 0.9rem;">Showing top 20 of ${availableResults.length} results</div>` : ''}
                `;

            } catch (error) {
                console.error('Stream search error:', error);
                resultsContainer.innerHTML = `<div style="text-align: center; color: #ff6b6b;">Error: ${error.message}</div>`;
            }
        }

        function addStreamToChannel(streamId, streamName, m3uAccount, streamUrl, channelGroup) {
            // Check if already added
            if (currentChannelStreams.find(s => s.id === streamId)) {
                showNotification('Stream already added', 'warning');
                return;
            }

            // Add to current streams
            currentChannelStreams.push({
                id: streamId,
                name: streamName,
                m3u_account: m3uAccount,
                url: streamUrl,
                channel_group: channelGroup
            });

            // Re-render and save
            renderCurrentStreams();
            saveStreamOrder();

            // Re-run last search to update available streams
            if (lastStreamSearchTerm) {
                performStreamSearch(lastStreamSearchTerm, lastStreamSearchMode);
            }

            showNotification('Stream added successfully', 'success');
        }

        function removeStreamFromChannel(streamId) {
            currentChannelStreams = currentChannelStreams.filter(s => s.id !== streamId);
            renderCurrentStreams();
            saveStreamOrder();

            // Update search results to show the removed stream is now available again
            if (lastStreamSearchTerm) {
                performStreamSearch(lastStreamSearchTerm, lastStreamSearchMode);
            }

            showNotification('Stream removed successfully', 'success');
        }

        async function saveStreamOrder() {
            const settings = await getSettings();
            const streamIds = currentChannelStreams.map(s => s.id);

            try {
                const response = await fetch(`/api/dispatcharr/channels/${currentStreamManagerChannel.id}/streams`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        url: settings.dispatcharr.url,
                        username: settings.dispatcharr.username,
                        password: settings.dispatcharr.password,
                        stream_ids: streamIds
                    })
                });

                const data = await response.json();

                if (!data.success) {
                    console.error('Failed to save stream order:', data.error);
                    showNotification('Failed to save stream order', 'error');
                } else {
                    // Update local channel data with new streams
                    const channelIndex = dispatcharrChannels.findIndex(ch => ch.id === currentStreamManagerChannel.id);
                    if (channelIndex !== -1) {
                        dispatcharrChannels[channelIndex].streams = currentChannelStreams;
                        // Update just this channel's row immediately (improved refresh strategy)
                        updateSingleChannelRow(currentStreamManagerChannel.id);
                        hasIncrementalUpdates = true;
                    }
                }
            } catch (error) {
                console.error('Error saving stream order:', error);
                showNotification('Error saving stream order', 'error');
            }
        }

        // Batch editing functions removed - future feature

        // Theme toggle function
        function toggleTheme() {
            const body = document.body;
            const themeIcon = document.getElementById('themeIcon');
            const isLightMode = body.classList.contains('light-mode');

            if (isLightMode) {
                body.classList.remove('light-mode');
                themeIcon.textContent = 'üåô';
                localStorage.setItem('theme', 'dark');
            } else {
                body.classList.add('light-mode');
                themeIcon.textContent = '‚òÄÔ∏è';
                localStorage.setItem('theme', 'light');
            }
        }

        // Apply saved theme on page load
        function applySavedTheme() {
            const savedTheme = localStorage.getItem('theme');
            const themeIcon = document.getElementById('themeIcon');

            if (savedTheme === 'light') {
                document.body.classList.add('light-mode');
                themeIcon.textContent = '‚òÄÔ∏è';
            } else {
                themeIcon.textContent = 'üåô';
            }
        }

        // Initialize on page load
        window.addEventListener('DOMContentLoaded', () => {
            applySavedTheme();
            loadStats();
            loadMetadata();

            // Enable search on Enter key
            document.getElementById('searchInput').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    performSearch();
                }
            });
        });

        async function loadMetadata() {
            try {
                const response = await fetch('/api/metadata');
                const data = await response.json();

                // Populate countries dropdown with USA at top
                const countrySelect = document.getElementById('countryFilter');

                // Remove the pre-selected USA option first
                const existingUSA = countrySelect.querySelector('option[value="USA"]');
                if (existingUSA) {
                    existingUSA.remove();
                }

                // Add USA first if it exists
                if (data.countries.includes('USA')) {
                    const usaOption = document.createElement('option');
                    usaOption.value = 'USA';
                    usaOption.textContent = 'USA';
                    usaOption.selected = true;  // Set USA as selected
                    countrySelect.appendChild(usaOption);

                    // Add divider
                    const divider = document.createElement('option');
                    divider.disabled = true;
                    divider.textContent = '‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ';
                    countrySelect.appendChild(divider);
                }

                // Add all countries alphabetically
                data.countries.sort().forEach(country => {
                    const option = document.createElement('option');
                    option.value = country;
                    option.textContent = country;
                    countrySelect.appendChild(option);
                });

                // Populate types dropdown
                const typeSelect = document.getElementById('typeFilter');
                data.lineup_types.forEach(type => {
                    const option = document.createElement('option');
                    option.value = type;
                    option.textContent = type;
                    typeSelect.appendChild(option);
                });

                // Populate quality dropdown
                const qualitySelect = document.getElementById('qualityFilter');
                if (data.qualities && data.qualities.length > 0) {
                    data.qualities.forEach(quality => {
                        const option = document.createElement('option');
                        option.value = quality;

                        // Display friendly names
                        if (quality === 'UHDTV/4K') {
                            option.textContent = 'UHDTV/4K';
                        } else if (quality === 'HDTV') {
                            option.textContent = 'HDTV';
                        } else if (quality === 'SDTV') {
                            option.textContent = 'SDTV';
                        } else {
                            option.textContent = quality;
                        }

                        qualitySelect.appendChild(option);
                    });
                }
            } catch (error) {
                console.error('Failed to load metadata:', error);
            }
        }

        async function loadStats() {
            try {
                const response = await fetch('/api/stats');
                const data = await response.json();

                document.getElementById('totalStations').textContent = (data.total_stations || 0).toLocaleString();
                document.getElementById('totalCountries').textContent = (data.total_countries || 0).toLocaleString();
                document.getElementById('totalMarkets').textContent = (data.total_markets || 0).toLocaleString();
                document.getElementById('totalLineups').textContent = (data.total_lineups || 0).toLocaleString();
                document.getElementById('stationsWithLogos').textContent = (data.stations_with_logos || 0).toLocaleString();
                document.getElementById('statsSection').classList.remove('hidden');
            } catch (error) {
                console.error('Failed to load stats:', error);
            }
        }

        async function performSearch() {
            const query = document.getElementById('searchInput').value.trim();
            if (!query) {
                showError('Please enter a search query');
                return;
            }

            // Hide previous results and errors
            document.getElementById('resultsSection').classList.add('hidden');
            document.getElementById('errorSection').classList.add('hidden');

            // Show loading
            document.getElementById('loadingSection').classList.remove('hidden');
            document.getElementById('searchBtn').disabled = true;

            try {
                const params = new URLSearchParams({
                    q: query,
                    country: document.getElementById('countryFilter').value,
                    type: document.getElementById('typeFilter').value,
                    quality: document.getElementById('qualityFilter').value,
                    limit: document.getElementById('limitFilter').value
                });

                const response = await fetch(`/api/search/stations?${params}`);
                const data = await response.json();

                if (!response.ok) {
                    throw new Error(data.error || 'Search failed');
                }

                currentResults = data.results;
                displayResults(data.results, query);

            } catch (error) {
                showError(`Search error: ${error.message}`);
            } finally {
                document.getElementById('loadingSection').classList.add('hidden');
                document.getElementById('searchBtn').disabled = false;
            }
        }

        function displayResults(results, query) {
            const resultsSection = document.getElementById('resultsSection');
            const tableHead = document.getElementById('resultsTableHead');
            const tableBody = document.getElementById('resultsTableBody');
            const resultsCount = document.getElementById('resultsCount');

            resultsCount.textContent = `${results.length} Result${results.length !== 1 ? 's' : ''} for "${query}"`;

            // Clear table
            tableHead.innerHTML = '';
            tableBody.innerHTML = '';

            if (results.length === 0) {
                tableBody.innerHTML = '<tr><td colspan="6" style="text-align: center; padding: 40px; color: #666;">No results found. Try adjusting your search or filters.</td></tr>';
            } else {
                // Create header
                const headerRow = document.createElement('tr');
                headerRow.innerHTML = `
                    <th class="sortable" onclick="sortResults('station_id')">Station ID</th>
                    <th class="sortable" onclick="sortResults('name')">Name</th>
                    <th class="sortable" onclick="sortResults('call_sign')">Call Sign</th>
                    <th class="sortable" onclick="sortResults('type')">Type</th>
                    <th>Logo</th>
                    <th>Actions</th>
                `;
                tableHead.appendChild(headerRow);

                // Create rows
                results.forEach(result => {
                    const row = createResultRow(result);
                    tableBody.appendChild(row);
                });
            }

            resultsSection.classList.remove('hidden');
        }

        function createResultRow(result) {
            const row = document.createElement('tr');

            const hasLogo = result.logo_uri && result.logo_uri.trim() !== '';
            const logoCell = hasLogo
                ? `<img src="${result.logo_uri}" alt="${result.name}" class="station-logo-small" onerror="this.style.display='none'; this.parentElement.innerHTML='<span class=\'no-logo-cell\'>No Logo</span>'">`
                : '<span class="no-logo-cell">No Logo</span>';

            row.innerHTML = `
                <td>${result.station_id}</td>
                <td>${result.name || 'N/A'}</td>
                <td>${result.call_sign || 'N/A'}</td>
                <td>${result.type || 'N/A'}</td>
                <td>${logoCell}</td>
                <td style="white-space: nowrap;">
                    <button onclick="event.stopPropagation(); showStationDetails('${result.station_id}')" style="padding: 6px 12px; font-size: 14px; margin-right: 5px;">View Details</button>
                    <button onclick="event.stopPropagation(); openCreateChannelModal('${result.station_id}')" style="padding: 6px 12px; font-size: 14px; background: #22c55e; border-color: #22c55e;">‚ûï Create Channel</button>
                </td>
            `;

            row.onclick = () => showStationDetails(result.station_id);
            return row;
        }

        function sortResults(column) {
            // Update sort direction
            if (sortColumn === column) {
                sortDirection = sortDirection === 'asc' ? 'desc' : 'asc';
            } else {
                sortColumn = column;
                sortDirection = 'asc';
            }

            // Sort results
            currentResults.sort((a, b) => {
                let aVal = a[column] || '';
                let bVal = b[column] || '';

                // Handle numeric station IDs
                if (column === 'station_id') {
                    aVal = parseInt(aVal) || 0;
                    bVal = parseInt(bVal) || 0;
                }

                if (aVal < bVal) return sortDirection === 'asc' ? -1 : 1;
                if (aVal > bVal) return sortDirection === 'asc' ? 1 : -1;
                return 0;
            });

            // Update header classes
            document.querySelectorAll('.results-table th').forEach(th => {
                th.classList.remove('sorted-asc', 'sorted-desc');
            });

            const headers = document.querySelectorAll('.results-table th');
            const columnIndex = ['station_id', 'name', 'call_sign', 'type'].indexOf(column);
            if (columnIndex >= 0 && headers[columnIndex]) {
                headers[columnIndex].classList.add(`sorted-${sortDirection}`);
            }

            // Re-render table body
            const tableBody = document.getElementById('resultsTableBody');
            tableBody.innerHTML = '';
            currentResults.forEach(result => {
                const row = createResultRow(result);
                tableBody.appendChild(row);
            });
        }

        async function showStationDetails(stationId) {
            try {
                const response = await fetch(`/api/station/${stationId}`);
                const station = await response.json();

                // Create modal
                const modal = document.createElement('div');
                modal.className = 'modal';
                modal.onclick = (e) => {
                    if (e.target === modal) {
                        modal.remove();
                    }
                };

                const hasLogo = station.logo_uri && station.logo_uri.trim() !== '';
                const logoSection = hasLogo
                    ? `<img src="${station.logo_uri}" alt="${station.name}" class="station-logo-large">`
                    : '';

                // Format broadcast languages
                const bcastLangs = station.bcast_langs ?
                    (typeof station.bcast_langs === 'string' ? station.bcast_langs : JSON.stringify(station.bcast_langs)) : 'N/A';

                modal.innerHTML = `
                    <div class="modal-content">
                        <div class="modal-header">
                            <div>
                                <div class="modal-title">${station.name || station.call_sign || 'Station Details'}</div>
                                <div style="color: #999; margin-top: 5px;">Gracenote ID: ${station.station_id}</div>
                            </div>
                            <button class="close-button" onclick="this.closest('.modal').remove()">√ó</button>
                        </div>

                        ${logoSection}

                        <div class="station-detail-grid">
                            <div class="station-detail-item">
                                <div class="station-detail-label">Station ID</div>
                                <div class="station-detail-value">${station.station_id}</div>
                            </div>
                            <div class="station-detail-item">
                                <div class="station-detail-label">Name</div>
                                <div class="station-detail-value">${station.name || 'N/A'}</div>
                            </div>
                            <div class="station-detail-item">
                                <div class="station-detail-label">Call Sign</div>
                                <div class="station-detail-value">${station.call_sign || 'N/A'}</div>
                            </div>
                            <div class="station-detail-item">
                                <div class="station-detail-label">Type</div>
                                <div class="station-detail-value">${station.type || 'N/A'}</div>
                            </div>
                            <div class="station-detail-item">
                                <div class="station-detail-label">Broadcast Languages</div>
                                <div class="station-detail-value">${bcastLangs}</div>
                            </div>
                            <div class="station-detail-item">
                                <div class="station-detail-label">Available In</div>
                                <div class="station-detail-value">${station.lineup_count || 0} Lineups</div>
                            </div>
                            <div class="station-detail-item">
                                <div class="station-detail-label">Video Types</div>
                                <div class="station-detail-value">${station.video_types || 'N/A'}</div>
                            </div>
                            <div class="station-detail-item">
                                <div class="station-detail-label">Affiliate ID</div>
                                <div class="station-detail-value">${station.affiliate_id || 'None'}</div>
                            </div>
                            <div class="station-detail-item">
                                <div class="station-detail-label">Affiliate Call Sign</div>
                                <div class="station-detail-value">${station.affiliate_call_sign || 'None'}</div>
                            </div>
                        </div>
                    </div>
                `;

                document.body.appendChild(modal);
            } catch (error) {
                console.error('Failed to load station details:', error);
                showError('Failed to load station details');
            }
        }

        function clearSearch() {
            document.getElementById('searchInput').value = '';
            document.getElementById('resultsSection').classList.add('hidden');
            document.getElementById('errorSection').classList.add('hidden');
            currentResults = [];
        }

        function showError(message) {
            const errorSection = document.getElementById('errorSection');
            errorSection.textContent = message;
            errorSection.classList.remove('hidden');
        }

        function exportResults() {
            if (currentResults.length === 0) return;

            const csv = [
                ['Station ID', 'Name', 'Call Sign', 'Type', 'Has Logo'],
                ...currentResults.map(r => [
                    r.station_id,
                    r.name || '',
                    r.call_sign || '',
                    r.type || '',
                    r.logo_uri ? 'Yes' : 'No'
                ])
            ].map(row => row.join(',')).join('\n');

            const blob = new Blob([csv], { type: 'text/csv' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `channel_search_${new Date().toISOString().split('T')[0]}.csv`;
            a.click();
        }
        // Settings Management
        // Helper function to get settings from backend
        async function getSettings() {
            try {
                const response = await fetch('/api/settings');
                if (response.ok) {
                    return await response.json();
                }
                return {};
            } catch (error) {
                console.error('Error fetching settings:', error);
                return {};
            }
        }

        async function loadSettings() {
            try {
                // Load from backend
                const response = await fetch('/api/settings');
                let settings = {};

                if (response.ok) {
                    settings = await response.json();
                } else {
                    // Try localStorage migration on first load
                    const localSettings = localStorage.getItem('channelIdentifiarrSettings');
                    if (localSettings) {
                        settings = JSON.parse(localSettings);
                        // Migrate to backend
                        await migrateSettingsToBackend(settings);
                        showNotification('Settings migrated to persistent storage', 'info');
                    }
                }

                // Database settings
                if (settings.database) {
                    document.getElementById('settingsDatabasePath').value = settings.database.path || '/data/channelidentifiarr.db';
                    document.getElementById('settingsRemoteDatabaseUrl').value = settings.database.remoteUrl || '';
                } else {
                    document.getElementById('settingsDatabasePath').value = '/data/channelidentifiarr.db';
                    document.getElementById('settingsRemoteDatabaseUrl').value = '';
                }

                // Load local database version on page load
                loadLocalDatabaseVersion();

                // Dispatcharr settings
                if (settings.dispatcharr) {
                    document.getElementById('settingsDispatcharrUrl').value = settings.dispatcharr.url || '';
                    document.getElementById('settingsDispatcharrUsername').value = settings.dispatcharr.username || '';
                    document.getElementById('settingsDispatcharrPassword').value = settings.dispatcharr.password || '';
                }

                // Emby settings
                if (settings.emby) {
                    document.getElementById('settingsEmbyUrl').value = settings.emby.url || '';
                    document.getElementById('settingsEmbyUsername').value = settings.emby.username || '';
                    document.getElementById('settingsEmbyPassword').value = settings.emby.password || '';
                }

                // Matching preferences
                if (settings.matching) {
                    document.getElementById('applyStationId').checked = settings.matching.applyStationId !== false;
                    document.getElementById('applyChannelName').checked = settings.matching.applyChannelName === true;
                    document.getElementById('applyLogo').checked = settings.matching.applyLogo !== false;

                    // Handle legacy applyCallSign setting - convert to applyTvgId
                    let applyTvgIdValue = false;
                    let tvgIdSourceValue = 'callsign';

                    if (settings.matching.applyTvgId !== undefined) {
                        applyTvgIdValue = settings.matching.applyTvgId;
                        tvgIdSourceValue = settings.matching.tvgIdSource || 'callsign';
                    } else if (settings.matching.applyCallSign === true) {
                        // Legacy: if applyCallSign was true, enable applyTvgId with callsign source
                        applyTvgIdValue = true;
                        tvgIdSourceValue = 'callsign';
                    }

                    // Set the master checkbox
                    document.getElementById('applyTvgId').checked = applyTvgIdValue;

                    // Set the appropriate radio button
                    if (tvgIdSourceValue === 'callsign') {
                        document.getElementById('tvgIdSourceCallsign').checked = true;
                    } else if (tvgIdSourceValue === 'gracenote') {
                        document.getElementById('tvgIdSourceGracenote').checked = true;
                    }

                    // Enable/disable radio buttons based on master checkbox
                    toggleTvgIdSourceOptions();
                }

                // Stream management settings
                if (settings.streamManagement) {
                    document.getElementById('streamSearchMaxResults').value = settings.streamManagement.maxResults || 10;
                    // Playlist priorities will be loaded separately
                    if (settings.streamManagement.playlistPriority) {
                        playlistPriorityOrder = settings.streamManagement.playlistPriority;
                    }
                }

                // Channel creation settings
                if (settings.channelCreation) {
                    // Load Smart Ranges
                    customRangesData = settings.channelCreation.customRanges || [];

                    // Load default group (will be populated after groups are loaded)
                    if (settings.channelCreation.defaultGroup) {
                        defaultGroupId = settings.channelCreation.defaultGroup;
                    }
                }

                // Load groups for default group selector (BEFORE rendering ranges)
                await loadGroupsForSettings();

                // Now render Smart Ranges after groups are loaded
                renderCustomRanges();

                // Load groups for management section
                await loadGroupsForManagement();

                // Update tab visibility
                await updateTabVisibility();
            } catch (error) {
                console.error('Error loading settings:', error);
                showNotification('Error loading settings: ' + error.message, 'error');
            }
        }

        async function migrateSettingsToBackend(settings) {
            try {
                const response = await fetch('/api/settings', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(settings)
                });

                if (response.ok) {
                    // Clear localStorage after successful migration
                    localStorage.removeItem('channelIdentifiarrSettings');
                    console.log('Settings migrated successfully');
                }
            } catch (error) {
                console.error('Error migrating settings:', error);
            }
        }

        function scrollToSetting(sectionId) {
            const element = document.getElementById(sectionId);
            if (element) {
                element.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }
            return false; // Prevent default anchor behavior
        }

        function toggleTvgIdSourceOptions() {
            const applyTvgId = document.getElementById('applyTvgId').checked;
            const callsignRadio = document.getElementById('tvgIdSourceCallsign');
            const gracenoteRadio = document.getElementById('tvgIdSourceGracenote');
            const callsignLabel = document.getElementById('tvgIdSourceCallsignLabel');
            const gracenoteLabel = document.getElementById('tvgIdSourceGracenoteLabel');

            if (applyTvgId) {
                // Enable radio buttons
                callsignRadio.disabled = false;
                gracenoteRadio.disabled = false;
                callsignLabel.style.color = '#fff';
                gracenoteLabel.style.color = '#fff';

                // If neither is selected, default to callsign
                if (!callsignRadio.checked && !gracenoteRadio.checked) {
                    callsignRadio.checked = true;
                }
            } else {
                // Disable radio buttons
                callsignRadio.disabled = true;
                gracenoteRadio.disabled = true;
                callsignLabel.style.color = '#666';
                gracenoteLabel.style.color = '#666';
            }
        }

        async function saveAllSettings() {
            const settings = {
                database: {
                    path: document.getElementById('settingsDatabasePath').value,
                    remoteUrl: document.getElementById('settingsRemoteDatabaseUrl').value
                },
                dispatcharr: {
                    url: document.getElementById('settingsDispatcharrUrl').value,
                    username: document.getElementById('settingsDispatcharrUsername').value,
                    password: document.getElementById('settingsDispatcharrPassword').value
                },
                emby: {
                    url: document.getElementById('settingsEmbyUrl').value,
                    username: document.getElementById('settingsEmbyUsername').value,
                    password: document.getElementById('settingsEmbyPassword').value
                },
                matching: {
                    applyStationId: document.getElementById('applyStationId').checked,
                    applyChannelName: document.getElementById('applyChannelName').checked,
                    applyLogo: document.getElementById('applyLogo').checked,
                    applyTvgId: document.getElementById('applyTvgId').checked,
                    tvgIdSource: document.querySelector('input[name="tvgIdSource"]:checked')?.value || 'callsign'
                },
                streamManagement: {
                    maxResults: parseInt(document.getElementById('streamSearchMaxResults').value) || 10,
                    playlistPriority: playlistPriorityOrder
                },
                channelCreation: {
                    defaultGroup: document.getElementById('settingsDefaultGroup').value || null,
                    customRanges: customRangesData || []
                }
            };

            try {
                const response = await fetch('/api/settings', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(settings)
                });

                if (response.ok) {
                    // Update tab visibility
                    await updateTabVisibility();
                    showNotification('Settings saved successfully! Note: Database path changes require backend restart.', 'success');
                } else {
                    const error = await response.json();
                    showNotification('Error saving settings: ' + (error.error || 'Unknown error'), 'error');
                }
            } catch (error) {
                console.error('Error saving settings:', error);
                showNotification('Error saving settings: ' + error.message, 'error');
            }
        }

        async function updateTabVisibility() {
            try {
                const response = await fetch('/api/settings');
                const settings = response.ok ? await response.json() : {};
                console.log('updateTabVisibility - settings:', settings);

            // Show/hide Dispatcharr tab
            const dispatcharrButton = document.getElementById('dispatcharrTabButton');
            const hasDispatcharr = settings.dispatcharr && settings.dispatcharr.url && settings.dispatcharr.username && settings.dispatcharr.password;
            console.log('Dispatcharr check:', hasDispatcharr, settings.dispatcharr);

            if (hasDispatcharr) {
                dispatcharrButton.style.display = 'inline-block';
                console.log('Showing Dispatcharr tab');
            } else {
                dispatcharrButton.style.display = 'none';
                console.log('Hiding Dispatcharr tab');
            }

            // Show/hide Emby tab
            const embyButton = document.getElementById('embyTabButton');
            const hasEmby = settings.emby && settings.emby.url && settings.emby.username && settings.emby.password;
            console.log('Emby check:', hasEmby, settings.emby);

            if (hasEmby) {
                embyButton.style.display = 'inline-block';
                console.log('Showing Emby tab');
            } else {
                embyButton.style.display = 'none';
                console.log('Hiding Emby tab');
            }
            } catch (error) {
                console.error('Error updating tab visibility:', error);
            }
        }

        function testDatabaseConnection() {
            const dbPath = document.getElementById('settingsDatabasePath').value;

            if (!dbPath) {
                document.getElementById('databaseTestResult').innerHTML = '<span style="color: #ff6b6b;">Please enter a database path</span>';
                return;
            }

            document.getElementById('databaseTestResult').innerHTML = '<span style="color: #999;">Testing...</span>';

            fetch('/api/health')
            .then(r => r.json())
            .then(data => {
                if (data.status === 'healthy') {
                    document.getElementById('databaseTestResult').innerHTML = `<span style="color: #51cf66;">‚úÖ Connected! (${data.stations_count.toLocaleString()} stations)</span>`;
                    // Load local version
                    loadLocalDatabaseVersion();
                } else {
                    document.getElementById('databaseTestResult').innerHTML = '<span style="color: #ff6b6b;">‚ùå Database error</span>';
                }
            })
            .catch(err => {
                document.getElementById('databaseTestResult').innerHTML = '<span style="color: #ff6b6b;">‚ùå Connection failed</span>';
            });
        }

        async function loadLocalDatabaseVersion() {
            try {
                const response = await fetch('/api/database/metadata');
                const data = await response.json();

                if (response.ok && data.version) {
                    document.getElementById('localDbVersion').textContent = data.version || 'Unknown';
                    document.getElementById('localDbDate').textContent = data.effective_date ? `Date: ${data.effective_date}` : '-';
                } else {
                    document.getElementById('localDbVersion').textContent = 'Error loading';
                    document.getElementById('localDbDate').textContent = '-';
                }
            } catch (err) {
                console.error('Error loading local DB version:', err);
                document.getElementById('localDbVersion').textContent = 'Error';
            }
        }

        async function autoCheckDatabaseUpdate() {
            // Silently check for updates if remote URL is configured
            const remoteUrl = document.getElementById('settingsRemoteDatabaseUrl').value.trim();

            if (!remoteUrl) {
                return; // No remote URL configured, skip check
            }

            const statusDiv = document.getElementById('updateStatus');
            const downloadBtn = document.getElementById('btnDownloadUpdate');

            // Show subtle loading indicator
            statusDiv.textContent = 'Checking for updates...';
            statusDiv.style.color = '#666';

            // Reset remote display
            document.getElementById('remoteDbVersion').textContent = '-';
            document.getElementById('remoteDbDate').textContent = '-';
            document.getElementById('remoteDbSize').textContent = '-';
            downloadBtn.disabled = true;
            downloadBtn.style.opacity = '0.5';

            try {
                const response = await fetch('/api/database/check-remote', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ remote_url: remoteUrl })
                });

                const data = await response.json();

                if (data.success) {
                    // Update remote version display
                    document.getElementById('remoteDbVersion').textContent = data.remote.version;
                    document.getElementById('remoteDbDate').textContent = `Date: ${data.remote.date}`;
                    document.getElementById('remoteDbSize').textContent = `Size: ${data.file_size_mb} MB`;

                    if (data.update_available) {
                        statusDiv.textContent = '‚ö†Ô∏è Update available!';
                        statusDiv.style.color = '#51cf66';
                        document.getElementById('remoteDbVersion').style.color = '#51cf66';
                        downloadBtn.disabled = false;
                        downloadBtn.style.opacity = '1';
                    } else {
                        statusDiv.textContent = '‚úÖ You have the latest version';
                        statusDiv.style.color = '#4a9eff';
                        document.getElementById('remoteDbVersion').style.color = '#666';
                    }
                } else {
                    statusDiv.textContent = 'Check failed (click Check for Updates to retry)';
                    statusDiv.style.color = '#999';
                }
            } catch (err) {
                console.error('Auto-check for updates error:', err);
                statusDiv.textContent = '';
            }
        }

        async function checkForDatabaseUpdate() {
            const remoteUrl = document.getElementById('settingsRemoteDatabaseUrl').value.trim();

            if (!remoteUrl) {
                showNotification('Please enter a remote database URL', 'error');
                return;
            }

            // Save remote URL to settings
            await saveAllSettings();

            const checkBtn = document.getElementById('btnCheckUpdate');
            const downloadBtn = document.getElementById('btnDownloadUpdate');
            const statusDiv = document.getElementById('updateStatus');

            checkBtn.disabled = true;
            checkBtn.textContent = 'üîç Checking...';
            statusDiv.textContent = 'Checking for updates...';
            statusDiv.style.color = '#999';

            // Reset remote display
            document.getElementById('remoteDbVersion').textContent = '-';
            document.getElementById('remoteDbDate').textContent = '-';
            document.getElementById('remoteDbSize').textContent = '-';
            downloadBtn.disabled = true;
            downloadBtn.style.opacity = '0.5';

            try {
                const response = await fetch('/api/database/check-remote', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ remote_url: remoteUrl })
                });

                const data = await response.json();

                if (data.success) {
                    // Update remote version display
                    document.getElementById('remoteDbVersion').textContent = data.remote.version;
                    document.getElementById('remoteDbDate').textContent = `Date: ${data.remote.date}`;
                    document.getElementById('remoteDbSize').textContent = `Size: ${data.file_size_mb} MB`;

                    if (data.update_available) {
                        statusDiv.textContent = '‚ö†Ô∏è Update available!';
                        statusDiv.style.color = '#51cf66';
                        document.getElementById('remoteDbVersion').style.color = '#51cf66';
                        downloadBtn.disabled = false;
                        downloadBtn.style.opacity = '1';
                        showNotification(`Update available: ${data.remote.version} (${data.remote.date})`, 'success');
                    } else {
                        statusDiv.textContent = '‚úÖ You have the latest version';
                        statusDiv.style.color = '#4a9eff';
                        document.getElementById('remoteDbVersion').style.color = '#666';
                        showNotification('You have the latest version', 'info');
                    }
                } else {
                    statusDiv.textContent = '‚ùå ' + (data.error || 'Failed to check for updates');
                    statusDiv.style.color = '#ff6b6b';
                    showNotification(data.error || 'Failed to check for updates', 'error');
                }
            } catch (err) {
                console.error('Error checking for updates:', err);
                statusDiv.textContent = '‚ùå Connection error';
                statusDiv.style.color = '#ff6b6b';
                showNotification('Error checking for updates', 'error');
            } finally {
                checkBtn.disabled = false;
                checkBtn.textContent = 'üîç Check for Updates';
            }
        }

        async function downloadDatabaseUpdate() {
            const remoteUrl = document.getElementById('settingsRemoteDatabaseUrl').value.trim();

            if (!remoteUrl) {
                showNotification('Please enter a remote database URL', 'error');
                return;
            }

            // Confirm download
            const remoteVersion = document.getElementById('remoteDbVersion').textContent;
            const remoteSize = document.getElementById('remoteDbSize').textContent;

            if (!confirm(`Download and install database update?\n\nVersion: ${remoteVersion}\n${remoteSize}\n\nYour current database will be backed up automatically before updating.`)) {
                return;
            }

            const downloadBtn = document.getElementById('btnDownloadUpdate');
            const checkBtn = document.getElementById('btnCheckUpdate');
            const restoreBtn = document.getElementById('btnRestoreBackup');
            const statusDiv = document.getElementById('updateStatus');
            const progressDiv = document.getElementById('downloadProgress');

            // Disable all buttons
            downloadBtn.disabled = true;
            checkBtn.disabled = true;
            restoreBtn.disabled = true;
            downloadBtn.textContent = '‚¨áÔ∏è Downloading...';

            statusDiv.textContent = 'Creating backup and downloading update...';
            statusDiv.style.color = '#999';

            // Show progress bar with indeterminate state
            progressDiv.style.display = 'block';
            const progressBar = document.getElementById('downloadProgressBar');
            const progressText = document.getElementById('downloadProgressText');
            progressBar.style.width = '100%';
            progressBar.style.background = 'repeating-linear-gradient(90deg, #4a9eff, #6bb6ff 40px, #4a9eff 80px)';
            progressBar.style.backgroundSize = '200% 100%';
            progressBar.style.animation = 'progress-slide 8s linear infinite';
            progressText.textContent = 'Downloading... (this may take several minutes for large files)';

            try {
                const response = await fetch('/api/database/update', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ remote_url: remoteUrl })
                });

                const data = await response.json();

                if (data.success) {
                    // Reset progress bar to completion state
                    progressBar.style.animation = 'none';
                    progressBar.style.background = 'linear-gradient(90deg, #4a9eff, #6bb6ff)';
                    progressBar.style.width = '100%';
                    progressText.textContent = 'Complete!';

                    statusDiv.textContent = `‚úÖ Database updated to ${data.new_version}`;
                    statusDiv.style.color = '#51cf66';

                    // Update local version display
                    document.getElementById('localDbVersion').textContent = data.new_version;
                    document.getElementById('localDbDate').textContent = `Date: ${data.new_date}`;

                    showNotification(`Database updated successfully to ${data.new_version}`, 'success');

                    // Hide progress after a moment
                    setTimeout(() => {
                        progressDiv.style.display = 'none';
                    }, 2000);
                } else {
                    statusDiv.textContent = '‚ùå ' + (data.error || 'Update failed');
                    statusDiv.style.color = '#ff6b6b';
                    showNotification(data.error || 'Failed to update database', 'error');
                    progressDiv.style.display = 'none';
                }
            } catch (err) {
                console.error('Error updating database:', err);
                statusDiv.textContent = '‚ùå Update failed';
                statusDiv.style.color = '#ff6b6b';
                showNotification('Error updating database', 'error');
                progressDiv.style.display = 'none';
            } finally {
                downloadBtn.disabled = false;
                checkBtn.disabled = false;
                restoreBtn.disabled = false;
                downloadBtn.textContent = '‚¨áÔ∏è Download Update';
            }
        }

        async function restoreDatabaseBackup() {
            if (!confirm('Restore database from backup?\n\nThis will replace your current database with the backup copy. Any changes made since the backup will be lost.')) {
                return;
            }

            const restoreBtn = document.getElementById('btnRestoreBackup');
            const checkBtn = document.getElementById('btnCheckUpdate');
            const downloadBtn = document.getElementById('btnDownloadUpdate');
            const statusDiv = document.getElementById('updateStatus');

            restoreBtn.disabled = true;
            checkBtn.disabled = true;
            downloadBtn.disabled = true;
            restoreBtn.textContent = 'üîô Restoring...';

            statusDiv.textContent = 'Restoring from backup...';
            statusDiv.style.color = '#999';

            try {
                const response = await fetch('/api/database/restore', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });

                const data = await response.json();

                if (data.success) {
                    statusDiv.textContent = `‚úÖ Database restored to ${data.restored_version}`;
                    statusDiv.style.color = '#51cf66';

                    // Update local version display
                    document.getElementById('localDbVersion').textContent = data.restored_version;
                    document.getElementById('localDbDate').textContent = `Date: ${data.restored_date}`;

                    showNotification(`Database restored successfully to ${data.restored_version}`, 'success');
                } else {
                    statusDiv.textContent = '‚ùå ' + (data.error || 'Restore failed');
                    statusDiv.style.color = '#ff6b6b';
                    showNotification(data.error || 'Failed to restore database', 'error');
                }
            } catch (err) {
                console.error('Error restoring database:', err);
                statusDiv.textContent = '‚ùå Restore failed';
                statusDiv.style.color = '#ff6b6b';
                showNotification('Error restoring database', 'error');
            } finally {
                restoreBtn.disabled = false;
                checkBtn.disabled = false;
                downloadBtn.disabled = false;
                restoreBtn.textContent = 'üîô Restore Backup';
            }
        }

        function testDispatcharrSettings() {
            const url = document.getElementById('settingsDispatcharrUrl').value;
            const username = document.getElementById('settingsDispatcharrUsername').value;
            const password = document.getElementById('settingsDispatcharrPassword').value;

            if (!url || !username || !password) {
                document.getElementById('dispatcharrTestResult').innerHTML = '<span style="color: #ff6b6b;">Please fill in all fields</span>';
                return;
            }

            document.getElementById('dispatcharrTestResult').innerHTML = '<span style="color: #999;">Testing...</span>';

            fetch('/api/dispatcharr/test', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ url, username, password })
            })
            .then(r => r.json())
            .then(data => {
                if (data.success) {
                    document.getElementById('dispatcharrTestResult').innerHTML = '<span style="color: #51cf66;">‚úÖ Connection successful!</span>';
                    // Auto-save settings and show tab on successful connection
                    try {
                        saveAllSettings();
                    } catch (e) {
                        console.error('Error saving settings:', e);
                    }
                } else {
                    document.getElementById('dispatcharrTestResult').innerHTML = '<span style="color: #ff6b6b;">‚ùå Connection failed</span>';
                }
            })
            .catch(err => {
                console.error('Dispatcharr test error:', err);
                document.getElementById('dispatcharrTestResult').innerHTML = '<span style="color: #ff6b6b;">‚ùå Connection error</span>';
            });
        }

        async function loadPlaylistsForSettings() {
            const settings = await getSettings();
            if (!settings.dispatcharr || !settings.dispatcharr.url) {
                document.getElementById('playlistPriorityList').innerHTML = '<div style="text-align: center; color: #ff6b6b; padding: 20px;">Please configure Dispatcharr connection first</div>';
                return;
            }

            document.getElementById('playlistPriorityList').innerHTML = '<div style="text-align: center; color: #999; padding: 20px;">Loading...</div>';

            try {
                const response = await fetch('/api/dispatcharr/m3u-accounts', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        url: settings.dispatcharr.url,
                        username: settings.dispatcharr.username,
                        password: settings.dispatcharr.password
                    })
                });

                const data = await response.json();

                if (data.success) {
                    cachedM3UAccounts = data.accounts;

                    // Build list of playlist IDs in priority order
                    const playlistIds = Object.keys(data.accounts).map(id => parseInt(id));

                    // If we have saved priority order, use it and add any new playlists at the end
                    if (playlistPriorityOrder.length > 0) {
                        const existingIds = new Set(playlistPriorityOrder);
                        const newIds = playlistIds.filter(id => !existingIds.has(id));
                        playlistPriorityOrder = [...playlistPriorityOrder.filter(id => playlistIds.includes(id)), ...newIds];
                    } else {
                        playlistPriorityOrder = playlistIds;
                    }

                    renderPlaylistPriorityList();
                } else {
                    document.getElementById('playlistPriorityList').innerHTML = `<div style="text-align: center; color: #ff6b6b; padding: 20px;">Error: ${data.error || 'Failed to load playlists'}</div>`;
                }
            } catch (error) {
                console.error('Error loading playlists:', error);
                document.getElementById('playlistPriorityList').innerHTML = '<div style="text-align: center; color: #ff6b6b; padding: 20px;">Error loading playlists</div>';
            }
        }

        function renderPlaylistPriorityList() {
            const container = document.getElementById('playlistPriorityList');
            if (!container || !cachedM3UAccounts) return;

            if (playlistPriorityOrder.length === 0) {
                container.innerHTML = '<div style="text-align: center; color: #666; padding: 20px;">No playlists found</div>';
                return;
            }

            container.innerHTML = playlistPriorityOrder.map((playlistId, index) => {
                const playlistName = cachedM3UAccounts[playlistId] || `Playlist ${playlistId}`;
                return `
                    <div class="playlist-priority-item" draggable="true" data-playlist-id="${playlistId}" data-index="${index}"
                        style="background: rgba(255,255,255,0.05); padding: 10px; margin-bottom: 8px; border-radius: 6px; cursor: move; border: 1px solid rgba(255,255,255,0.1);"
                        ondragstart="handlePlaylistDragStart(event)" ondragover="handlePlaylistDragOver(event)"
                        ondrop="handlePlaylistDrop(event)" ondragend="handlePlaylistDragEnd(event)">
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <span style="color: #999; font-size: 0.9rem;">‚ãÆ‚ãÆ</span>
                            <span style="background: rgba(51, 204, 255, 0.2); color: #33ccff; padding: 2px 8px; border-radius: 4px; font-size: 0.8rem;">
                                #${index + 1}
                            </span>
                            <span style="flex: 1;">${escapeHtml(playlistName)}</span>
                        </div>
                    </div>
                `;
            }).join('');
        }

        // Playlist drag and drop handlers
        let draggedPlaylistElement = null;
        let draggedPlaylistIndex = null;

        function handlePlaylistDragStart(e) {
            draggedPlaylistElement = e.target.closest('.playlist-priority-item');
            draggedPlaylistIndex = parseInt(draggedPlaylistElement.dataset.index);
            e.dataTransfer.effectAllowed = 'move';
            draggedPlaylistElement.style.opacity = '0.4';
        }

        function handlePlaylistDragOver(e) {
            if (e.preventDefault) {
                e.preventDefault();
            }
            e.dataTransfer.dropEffect = 'move';

            const targetElement = e.target.closest('.playlist-priority-item');
            if (targetElement && targetElement !== draggedPlaylistElement) {
                targetElement.style.borderTop = '3px solid #33ccff';
            }
            return false;
        }

        function handlePlaylistDrop(e) {
            if (e.stopPropagation) {
                e.stopPropagation();
            }

            const targetElement = e.target.closest('.playlist-priority-item');
            if (targetElement && draggedPlaylistElement && targetElement !== draggedPlaylistElement) {
                const targetIndex = parseInt(targetElement.dataset.index);

                // Reorder the array
                const [movedPlaylist] = playlistPriorityOrder.splice(draggedPlaylistIndex, 1);
                playlistPriorityOrder.splice(targetIndex, 0, movedPlaylist);

                // Re-render
                renderPlaylistPriorityList();
            }

            // Clear border highlight
            document.querySelectorAll('.playlist-priority-item').forEach(item => {
                item.style.borderTop = '';
            });

            return false;
        }

        function handlePlaylistDragEnd(e) {
            if (draggedPlaylistElement) {
                draggedPlaylistElement.style.opacity = '';
            }

            // Clear all border highlights
            document.querySelectorAll('.playlist-priority-item').forEach(item => {
                item.style.borderTop = '';
            });
        }

        // Smart Ranges and Default Group Functions
        async function loadGroupsForSettings() {
            // Load groups for the default group selector
            if (!dispatcharrGroups || dispatcharrGroups.length === 0) {
                await loadDispatcharrGroups();
            }

            filterDefaultGroupSelector();
        }

        function updateDefaultGroupDisplay() {
            const select = document.getElementById('settingsDefaultGroup');
            const displayBox = document.getElementById('currentDefaultGroupDisplay');
            const displayName = document.getElementById('currentDefaultGroupName');
            const statusDiv = document.getElementById('settingsDefaultGroupStatus');

            if (!select || !displayBox || !displayName) return;

            const selectedValue = select.value;
            const selectedOption = select.options[select.selectedIndex];

            if (!selectedValue) {
                // No default set
                displayName.textContent = 'No Default Set';
                displayBox.style.background = 'rgba(128, 128, 128, 0.05)';
                displayBox.style.borderColor = 'rgba(128, 128, 128, 0.15)';
                displayName.style.color = '#999';
                statusDiv.textContent = '';
            } else {
                // Default group selected
                const groupName = selectedOption.textContent;
                displayName.textContent = groupName;
                displayBox.style.background = 'rgba(74, 158, 255, 0.08)';
                displayBox.style.borderColor = 'rgba(74, 158, 255, 0.2)';
                displayName.style.color = '#4a9eff';
                statusDiv.textContent = `‚úì Default group will be applied to new channels`;
            }
        }

        function filterDefaultGroupSelector() {
            const filter = document.getElementById('settingsDefaultGroupFilter').value.toLowerCase();
            const showCustomOnly = document.getElementById('settingsDefaultGroupShowCustomOnly').checked;
            const select = document.getElementById('settingsDefaultGroup');
            if (!select) return;

            // Filter groups
            let filtered = dispatcharrGroups.filter(g => {
                // Text filter
                const matchesText = g.name.toLowerCase().includes(filter);

                // Custom groups filter (groups with no M3U associations)
                const isCustomGroup = !g.m3u_account_count || g.m3u_account_count === 0;
                const matchesCustomFilter = !showCustomOnly || isCustomGroup;

                return matchesText && matchesCustomFilter;
            });

            select.innerHTML = '<option value="">-- No Default --</option>';

            filtered.forEach(group => {
                const option = document.createElement('option');
                option.value = group.id;
                const m3uIndicator = (group.m3u_account_count && group.m3u_account_count > 0) ? ` (M3U)` : '';
                option.textContent = group.name + m3uIndicator;
                if (defaultGroupId && group.id == defaultGroupId) {
                    option.selected = true;
                }
                select.appendChild(option);
            });

            // Update the display box
            updateDefaultGroupDisplay();
        }

        // Helper function to check if two ranges overlap
        function rangesOverlap(range1Start, range1End, range2Start, range2End) {
            // Two ranges overlap if one starts before the other ends
            return (range1Start <= range2End && range1End >= range2Start);
        }

        // Check if a new range overlaps with existing ranges
        function checkRangeOverlap(newStart, newEnd, excludeIndex = -1) {
            for (let i = 0; i < customRangesData.length; i++) {
                // Skip the range being edited
                if (i === excludeIndex) continue;

                const existing = customRangesData[i];
                if (rangesOverlap(newStart, newEnd, existing.start, existing.end)) {
                    return {
                        overlaps: true,
                        conflictingRange: existing
                    };
                }
            }
            return { overlaps: false };
        }

        function renderCustomRanges() {
            const container = document.getElementById('customRangesList');
            if (!container) return;

            if (!customRangesData || customRangesData.length === 0) {
                container.innerHTML = '<div style="text-align: center; color: #666; padding: 10px; font-size: 0.85rem;">No Smart Ranges defined</div>';
                return;
            }

            // Compact version for settings page
            container.innerHTML = customRangesData.map((range, index) => {
                const groupName = range.groupId ? (dispatcharrGroups.find(g => g.id == range.groupId)?.name || 'Unknown Group') : 'No Group';
                return `
                    <div style="background: rgba(255,255,255,0.05); padding: 8px 10px; margin-bottom: 6px; border-radius: 4px; border: 1px solid rgba(255,255,255,0.1); display: flex; justify-content: space-between; align-items: center; font-size: 0.9rem;">
                        <div>
                            <span style="font-weight: 500; margin-right: 8px;">${escapeHtml(range.name)}</span>
                            <span style="color: #999; font-size: 0.85rem;">${range.start}-${range.end}</span>
                            <span style="color: #667eea; margin-left: 8px; font-size: 0.85rem;">‚Üí ${escapeHtml(groupName)}</span>
                        </div>
                    </div>
                `;
            }).join('');
        }

        function addCustomRange() {
            const name = prompt('Enter range name (e.g., "SPORTS", "NEWS"):');
            if (!name || !name.trim()) return;

            const start = prompt('Enter start channel number:');
            if (!start || isNaN(parseInt(start))) {
                showNotification('Invalid start number', 'error');
                return;
            }

            const end = prompt('Enter end channel number:');
            if (!end || isNaN(parseInt(end))) {
                showNotification('Invalid end number', 'error');
                return;
            }

            const startNum = parseInt(start);
            const endNum = parseInt(end);

            if (startNum >= endNum) {
                showNotification('Start must be less than end', 'error');
                return;
            }

            // Check for overlaps with existing ranges
            const overlapCheck = checkRangeOverlap(startNum, endNum);
            if (overlapCheck.overlaps) {
                showNotification(
                    `Range overlaps with "${overlapCheck.conflictingRange.name}" (${overlapCheck.conflictingRange.start}-${overlapCheck.conflictingRange.end})`,
                    'error'
                );
                return;
            }

            // Find group by name (case insensitive)
            const matchingGroup = dispatcharrGroups.find(g =>
                g.name.toLowerCase() === name.trim().toLowerCase()
            );

            customRangesData.push({
                name: name.trim(),
                start: startNum,
                end: endNum,
                groupId: matchingGroup ? matchingGroup.id : null
            });

            renderCustomRanges();
            saveAllSettings();

            if (!matchingGroup) {
                showNotification(`Range "${name}" added (no matching group found - you can create the group later)`, 'success');
            } else {
                showNotification(`Range "${name}" added and linked to group "${matchingGroup.name}"`, 'success');
            }
        }

        function editCustomRange(index) {
            const range = customRangesData[index];

            const name = prompt('Enter range name:', range.name);
            if (!name || !name.trim()) return;

            const start = prompt('Enter start channel number:', range.start);
            if (!start || isNaN(parseInt(start))) {
                showNotification('Invalid start number', 'error');
                return;
            }

            const end = prompt('Enter end channel number:', range.end);
            if (!end || isNaN(parseInt(end))) {
                showNotification('Invalid end number', 'error');
                return;
            }

            const startNum = parseInt(start);
            const endNum = parseInt(end);

            if (startNum >= endNum) {
                showNotification('Start must be less than end', 'error');
                return;
            }

            // Check for overlaps with existing ranges (excluding current range)
            const overlapCheck = checkRangeOverlap(startNum, endNum, index);
            if (overlapCheck.overlaps) {
                showNotification(
                    `Range overlaps with "${overlapCheck.conflictingRange.name}" (${overlapCheck.conflictingRange.start}-${overlapCheck.conflictingRange.end})`,
                    'error'
                );
                return;
            }

            // Find group by name (case insensitive)
            const matchingGroup = dispatcharrGroups.find(g =>
                g.name.toLowerCase() === name.trim().toLowerCase()
            );

            customRangesData[index] = {
                name: name.trim(),
                start: startNum,
                end: endNum,
                groupId: matchingGroup ? matchingGroup.id : null
            };

            renderCustomRanges();
            saveAllSettings();
            showNotification('Range updated', 'success');
        }

        function deleteCustomRange(index) {
            const range = customRangesData[index];
            if (confirm(`Delete range "${range.name}" (${range.start}-${range.end})?`)) {
                customRangesData.splice(index, 1);
                renderCustomRanges();
                saveAllSettings();
                showNotification('Range deleted', 'success');
            }
        }

        // Group Management Functions
        async function loadGroupsForManagement() {
            const container = document.getElementById('manageGroupsList');
            if (!container) return;

            container.innerHTML = '<div style="text-align: center; color: #999; padding: 10px;">Loading...</div>';

            // Always reload groups and channels to get fresh data
            await loadDispatcharrGroups();

            // Force load channels for accurate counts
            const settings = await getSettings();
            if (settings.dispatcharr && settings.dispatcharr.url) {
                try {
                    const response = await fetch('/api/dispatcharr/channels', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            url: settings.dispatcharr.url,
                            username: settings.dispatcharr.username,
                            password: settings.dispatcharr.password
                        })
                    });
                    const data = await response.json();
                    if (data.channels) {
                        dispatcharrChannels = data.channels;
                        console.log(`Loaded ${dispatcharrChannels.length} channels for group management`);
                    } else {
                        console.warn('No channels returned from API');
                        dispatcharrChannels = [];
                    }
                } catch (error) {
                    console.error('Failed to load channels:', error);
                }
            }

            if (!dispatcharrGroups || dispatcharrGroups.length === 0) {
                container.innerHTML = '<div style="text-align: center; color: #666; padding: 10px;">No groups found</div>';
                return;
            }

            // Filter to only show groups with NO M3U associations
            const nonM3UGroups = dispatcharrGroups.filter(g => !g.m3u_account_count || g.m3u_account_count === 0);

            if (nonM3UGroups.length === 0) {
                container.innerHTML = '<div style="text-align: center; color: #666; padding: 10px;">No user-created groups found. All groups are M3U-associated.</div>';
                return;
            }

            // Sort groups by name
            const sortedGroups = [...nonM3UGroups].sort((a, b) => a.name.localeCompare(b.name));

            container.innerHTML = sortedGroups.map(group => {
                // Count channels in this group
                let channelCount = 0;
                if (dispatcharrChannels && Array.isArray(dispatcharrChannels)) {
                    const matchingChannels = dispatcharrChannels.filter(ch => {
                        // Dispatcharr channels use 'group_id' field
                        return ch.group_id == group.id;
                    });
                    channelCount = matchingChannels.length;
                    console.log(`Group "${group.name}" (ID: ${group.id}): ${channelCount} channels found`);
                }
                const canDelete = channelCount === 0;

                return `
                    <div style="background: rgba(255,255,255,0.05); padding: 10px; margin-bottom: 8px; border-radius: 6px; border: 1px solid rgba(255,255,255,0.1);">
                        <div style="display: flex; align-items: center; justify-content: space-between; gap: 10px;">
                            <div style="flex: 1;">
                                <div style="font-weight: 500; margin-bottom: 4px;">${escapeHtml(group.name)}</div>
                                <div style="color: #999; font-size: 0.85rem;">
                                    ${channelCount} channel${channelCount !== 1 ? 's' : ''}
                                </div>
                            </div>
                            <div style="display: flex; gap: 6px;">
                                <button onclick="openEditGroupModal(${group.id}, '${escapeHtml(group.name).replace(/'/g, "\\'")}', ${channelCount})" class="btn-secondary"
                                    style="padding: 6px 10px; font-size: 0.85rem;">
                                    ‚úèÔ∏è Edit
                                </button>
                                ${canDelete ? `
                                    <button onclick="deleteGroup(${group.id}, '${escapeHtml(group.name).replace(/'/g, "\\'")})" class="btn-secondary"
                                        style="padding: 6px 10px; font-size: 0.85rem; background: rgba(255, 107, 107, 0.2); border-color: #ff6b6b;">
                                        üóëÔ∏è Delete
                                    </button>
                                ` : ''}
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
        }

        async function deleteGroup(groupId, groupName) {
            if (!confirm(`Are you sure you want to delete the group "${groupName}"?\n\nThis action cannot be undone.`)) {
                return;
            }

            const settings = await getSettings();
            if (!settings.dispatcharr || !settings.dispatcharr.url) {
                showNotification('Please configure Dispatcharr settings first', 'error');
                return;
            }

            try {
                const response = await fetch(`/api/dispatcharr/groups/${groupId}`, {
                    method: 'DELETE',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        url: settings.dispatcharr.url,
                        username: settings.dispatcharr.username,
                        password: settings.dispatcharr.password
                    })
                });

                const data = await response.json();

                if (data.success) {
                    showNotification(`Group "${groupName}" deleted successfully`, 'success');

                    // Reload groups
                    await loadDispatcharrGroups();
                    await loadGroupsForManagement();
                    await loadGroupsForSettings();
                    renderCustomRanges();
                } else {
                    showNotification(`Failed to delete group: ${data.error || 'Unknown error'}`, 'error');
                }
            } catch (error) {
                console.error('Error deleting group:', error);
                showNotification(`Error deleting group: ${error.message}`, 'error');
            }
        }

        function openCreateGroupInManagement() {
            const groupName = prompt('Enter new group name:');
            if (!groupName || !groupName.trim()) return;

            createGroupFromManagement(groupName.trim());
        }

        async function createGroupFromManagement(groupName) {
            const settings = await getSettings();
            if (!settings.dispatcharr || !settings.dispatcharr.url) {
                showNotification('Please configure Dispatcharr settings first', 'error');
                return;
            }

            try {
                const response = await fetch('/api/dispatcharr/groups', {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        url: settings.dispatcharr.url,
                        username: settings.dispatcharr.username,
                        password: settings.dispatcharr.password,
                        name: groupName
                    })
                });

                const data = await response.json();

                if (data.success && data.group) {
                    showNotification(`Group "${groupName}" created successfully`, 'success');

                    // Reload groups everywhere
                    await loadDispatcharrGroups();
                    await loadGroupsForManagement();
                    await loadGroupsForSettings();
                    renderCustomRanges();
                } else {
                    showNotification(`Failed to create group: ${data.error || 'Unknown error'}`, 'error');
                }
            } catch (error) {
                console.error('Error creating group:', error);
                showNotification(`Error creating group: ${error.message}`, 'error');
            }
        }

        function openEditGroupModal(groupId, groupName, channelCount) {
            editingGroupId = groupId;
            editingGroupChannelCount = channelCount;

            document.getElementById('editGroupName').value = groupName;
            document.getElementById('editGroupInfo').innerHTML = `
                <div>${channelCount} channel${channelCount !== 1 ? 's' : ''} currently assigned to this group</div>
                ${channelCount > 0 ? '<div style="color: #ffd43b; margin-top: 5px;">‚ö†Ô∏è Changing the name will update all references including Smart Ranges</div>' : ''}
            `;
            document.getElementById('editGroupStatus').innerHTML = '';
            document.getElementById('editGroupModal').style.display = 'flex';
        }

        function closeEditGroupModal() {
            document.getElementById('editGroupModal').style.display = 'none';
            editingGroupId = null;
            editingGroupChannelCount = 0;
        }

        async function saveGroupEdit() {
            const newName = document.getElementById('editGroupName').value.trim();
            const statusDiv = document.getElementById('editGroupStatus');

            if (!newName) {
                statusDiv.innerHTML = '<span style="color: #ff6b6b;">Group name is required</span>';
                return;
            }

            if (!editingGroupId) {
                statusDiv.innerHTML = '<span style="color: #ff6b6b;">No group selected for editing</span>';
                return;
            }

            const settings = await getSettings();
            if (!settings.dispatcharr || !settings.dispatcharr.url) {
                statusDiv.innerHTML = '<span style="color: #ff6b6b;">Please configure Dispatcharr settings first</span>';
                return;
            }

            statusDiv.innerHTML = '<span style="color: #999;">Saving...</span>';

            try {
                const response = await fetch(`/api/dispatcharr/groups/${editingGroupId}`, {
                    method: 'PATCH',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        url: settings.dispatcharr.url,
                        username: settings.dispatcharr.username,
                        password: settings.dispatcharr.password,
                        name: newName
                    })
                });

                const data = await response.json();

                if (data.success) {
                    showNotification(`Group renamed to "${newName}"`, 'success');

                    // Reload groups everywhere
                    await loadDispatcharrGroups();
                    await loadGroupsForManagement();
                    await loadGroupsForSettings();
                    renderCustomRanges();

                    closeEditGroupModal();
                } else {
                    statusDiv.innerHTML = `<span style="color: #ff6b6b;">Failed: ${data.error || 'Unknown error'}</span>`;
                }
            } catch (error) {
                console.error('Error updating group:', error);
                statusDiv.innerHTML = `<span style="color: #ff6b6b;">Error: ${error.message}</span>`;
            }
        }

        // Smart Ranges Modal Functions
        function openCustomRangesModal() {
            renderCustomRangesModalList();
            document.getElementById('customRangesModal').style.display = 'flex';
        }

        function closeCustomRangesModal() {
            document.getElementById('customRangesModal').style.display = 'none';
            // Clear add new range fields
            document.getElementById('newRangeName').value = '';
            document.getElementById('newRangeStart').value = '';
            document.getElementById('newRangeEnd').value = '';
            document.getElementById('addRangeStatus').innerHTML = '';
        }

        async function renderCustomRangesModalList() {
            const container = document.getElementById('customRangesModalList');
            if (!container) return;

            // Ensure channels are loaded for usage stats
            await ensureChannelsLoaded();

            if (!customRangesData || customRangesData.length === 0) {
                container.innerHTML = '<div style="text-align: center; color: #666; padding: 20px;">No Smart Ranges defined yet. Add your first range below!</div>';
                return;
            }

            container.innerHTML = customRangesData.map((range, index) => {
                const groupName = range.groupId ? (dispatcharrGroups.find(g => g.id == range.groupId)?.name || 'Unknown Group') : 'No Group';

                // Count channels in this range
                let usedCount = 0;
                const rangeSize = range.end - range.start + 1;
                if (dispatcharrChannels && dispatcharrChannels.length > 0) {
                    usedCount = dispatcharrChannels.filter(ch => {
                        const num = parseFloat(ch.channel_number);
                        return !isNaN(num) && num >= range.start && num <= range.end;
                    }).length;
                }

                const availableCount = rangeSize - usedCount;
                const usagePercent = (usedCount / rangeSize * 100).toFixed(1);

                return `
                    <div style="background: rgba(255,255,255,0.05); padding: 10px; margin-bottom: 8px; border-radius: 6px; border: 1px solid rgba(255,255,255,0.1);">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                            <div style="flex: 1;">
                                <div style="font-weight: 500; font-size: 1rem; margin-bottom: 3px;">${escapeHtml(range.name)}</div>
                                <div style="color: #999; font-size: 0.85rem;">
                                    ${range.start} - ${range.end}
                                    <span style="color: #667eea; margin-left: 8px;">‚Üí ${escapeHtml(groupName)}</span>
                                </div>
                            </div>
                            <button onclick="deleteRangeFromModal(${index})" class="btn-secondary"
                                style="padding: 5px 8px; font-size: 0.8rem; background: rgba(255, 107, 107, 0.2); border-color: #ff6b6b;">
                                üóëÔ∏è
                            </button>
                        </div>
                        <div style="display: flex; justify-content: space-between; font-size: 0.8rem; color: #999; margin-bottom: 4px;">
                            <span>${usedCount}/${rangeSize}</span>
                            <span style="color: ${usedCount === 0 ? '#51cf66' : '#ffd43b'};">${availableCount} available</span>
                        </div>
                        <div style="background: rgba(0,0,0,0.3); height: 6px; border-radius: 3px; overflow: hidden;">
                            <div style="background: linear-gradient(90deg, #667eea, #764ba2); height: 100%; width: ${usagePercent}%; transition: width 0.3s;"></div>
                        </div>
                    </div>
                `;
            }).join('');
        }

        async function addRangeFromModal() {
            const name = document.getElementById('newRangeName').value.trim();
            const start = parseInt(document.getElementById('newRangeStart').value);
            const end = parseInt(document.getElementById('newRangeEnd').value);
            const statusDiv = document.getElementById('addRangeStatus');

            if (!name) {
                statusDiv.innerHTML = '<span style="color: #ff6b6b;">‚ö†Ô∏è Range name is required</span>';
                return;
            }

            if (!start || isNaN(start)) {
                statusDiv.innerHTML = '<span style="color: #ff6b6b;">‚ö†Ô∏è Invalid start number</span>';
                return;
            }

            if (!end || isNaN(end)) {
                statusDiv.innerHTML = '<span style="color: #ff6b6b;">‚ö†Ô∏è Invalid end number</span>';
                return;
            }

            if (start >= end) {
                statusDiv.innerHTML = '<span style="color: #ff6b6b;">‚ö†Ô∏è Start must be less than end</span>';
                return;
            }

            // Check for overlaps with existing ranges
            const overlapCheck = checkRangeOverlap(start, end);
            if (overlapCheck.overlaps) {
                statusDiv.innerHTML = `<span style="color: #ff6b6b;">‚ö†Ô∏è Range overlaps with "${escapeHtml(overlapCheck.conflictingRange.name)}" (${overlapCheck.conflictingRange.start}-${overlapCheck.conflictingRange.end})</span>`;
                return;
            }

            // Find group by name (case insensitive)
            let matchingGroup = dispatcharrGroups.find(g =>
                g.name.toLowerCase() === name.toLowerCase()
            );

            // If group doesn't exist, offer to create it
            if (!matchingGroup) {
                statusDiv.innerHTML = '<span style="color: #ffd43b;">Group not found. Creating...</span>';

                const settings = await getSettings();
                if (!settings.dispatcharr || !settings.dispatcharr.url) {
                    statusDiv.innerHTML = '<span style="color: #ff6b6b;">‚ö†Ô∏è Please configure Dispatcharr settings first</span>';
                    return;
                }

                try {
                    const response = await fetch('/api/dispatcharr/groups', {
                        method: 'PUT',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            url: settings.dispatcharr.url,
                            username: settings.dispatcharr.username,
                            password: settings.dispatcharr.password,
                            name: name
                        })
                    });

                    const data = await response.json();

                    if (data.success && data.group) {
                        // Reload groups
                        await loadDispatcharrGroups();
                        await loadGroupsForSettings();
                        await loadGroupsForManagement();

                        matchingGroup = data.group;
                        statusDiv.innerHTML = `<span style="color: #51cf66;">‚úì Group "${name}" created and range added!</span>`;
                    } else {
                        statusDiv.innerHTML = `<span style="color: #ff6b6b;">‚ö†Ô∏è Failed to create group: ${data.error || 'Unknown error'}</span>`;
                        return;
                    }
                } catch (error) {
                    console.error('Error creating group:', error);
                    statusDiv.innerHTML = `<span style="color: #ff6b6b;">‚ö†Ô∏è Error creating group: ${error.message}</span>`;
                    return;
                }
            } else {
                statusDiv.innerHTML = `<span style="color: #51cf66;">‚úì Range added and linked to existing "${matchingGroup.name}" group</span>`;
            }

            customRangesData.push({
                name: name,
                start: start,
                end: end,
                groupId: matchingGroup ? matchingGroup.id : null
            });

            // Clear fields
            document.getElementById('newRangeName').value = '';
            document.getElementById('newRangeStart').value = '';
            document.getElementById('newRangeEnd').value = '';

            // Refresh the list
            renderCustomRangesModalList();

            // Clear status after 3 seconds
            setTimeout(() => {
                statusDiv.innerHTML = '';
            }, 3000);
        }

        function deleteRangeFromModal(index) {
            const range = customRangesData[index];
            if (confirm(`Delete range "${range.name}" (${range.start}-${range.end})?`)) {
                customRangesData.splice(index, 1);
                renderCustomRangesModalList();
            }
        }

        async function saveCustomRangesFromModal() {
            await saveAllSettings();
            renderCustomRanges(); // Update the preview in settings
            showNotification('Smart Ranges saved successfully', 'success');
        }

        // Channel Matching Functions
        async function startChannelMatching() {
            // Load Dispatcharr channels first if needed
            if (dispatcharrChannels.length === 0) {
                await loadDispatcharrChannels();
            }

            // Filter unmatched channels
            matchingQueue = dispatcharrChannels.filter(ch => !ch.gracenote_id);

            if (matchingQueue.length === 0) {
                showNotification('All channels already have Gracenote IDs!');
                return;
            }

            // Initialize matching
            currentMatchIndex = 0;
            matchingResults = [];
            isMatching = true;

            // Update UI
            document.getElementById('matchingProgress').style.display = 'block';
            document.getElementById('matchingInterface').style.display = 'block';
            document.getElementById('matchingResults').style.display = 'none';

            // Start matching process
            await matchNextChannel();
        }

        // Matching Filter Functions (unified filters with full manual control)
        let autoDetectedFilters = {country: '', resolution: ''};  // Store auto-detected values
        let filtersManuallyModified = false;  // Track if user manually changed filters

        // Normalize resolution values between database format and UI format
        function normalizeResolutionToUI(dbValue) {
            if (!dbValue) return '';
            const upper = dbValue.toUpperCase();
            if (upper === 'HDTV') return 'HD';
            if (upper === 'SDTV') return 'SD';
            if (upper === 'UHDTV' || upper === '4K') return 'UHD';
            return dbValue; // Fallback to original
        }

        function normalizeResolutionToDB(uiValue) {
            if (!uiValue) return '';
            const upper = uiValue.toUpperCase();
            if (upper === 'HD') return 'HDTV';
            if (upper === 'SD') return 'SDTV';
            if (upper === 'UHD') return 'UHDTV';
            return uiValue; // Fallback to original
        }

        function toggleMatchingFilters() {
            const controls = document.getElementById('filterControls');
            const icon = document.getElementById('filterToggleIcon');
            if (controls.style.display === 'none') {
                controls.style.display = 'block';
                icon.textContent = '‚ñº';
            } else {
                controls.style.display = 'none';
                icon.textContent = '‚ñ∂';
            }
        }

        function getMatchingFilters() {
            // Get currently selected filters from UI and convert to database format
            const country = document.getElementById('filterCountry').value;
            const resolutions = [];
            if (document.getElementById('filterSD').checked) resolutions.push(normalizeResolutionToDB('SD'));
            if (document.getElementById('filterHD').checked) resolutions.push(normalizeResolutionToDB('HD'));
            if (document.getElementById('filterUHD').checked) resolutions.push(normalizeResolutionToDB('UHD'));

            return {
                country: country,
                resolutions: resolutions
            };
        }

        function applyMatchingFilters() {
            // Re-run matching with current filters
            if (isMatching && matchingQueue[currentMatchIndex]) {
                matchNextChannel();  // Refresh suggestions for current channel
            }
        }

        function resetMatchingFilters() {
            // Reset manual modification flag to allow auto-detection
            filtersManuallyModified = false;

            // Reset to auto-detected values
            document.getElementById('filterCountry').value = autoDetectedFilters.country || '';

            // Reset resolution checkboxes based on auto-detected value (normalize DB format to UI)
            const autoResolution = autoDetectedFilters.resolution;
            if (autoResolution) {
                const normalizedResolution = normalizeResolutionToUI(autoResolution);
                // Only check the auto-detected resolution
                document.getElementById('filterSD').checked = (normalizedResolution === 'SD');
                document.getElementById('filterHD').checked = (normalizedResolution === 'HD');
                document.getElementById('filterUHD').checked = (normalizedResolution === 'UHD');
            } else {
                // No auto-detection - check all
                document.getElementById('filterSD').checked = true;
                document.getElementById('filterHD').checked = true;
                document.getElementById('filterUHD').checked = true;
            }

            applyMatchingFilters();
        }

        function clearAllMatchingFilters() {
            // Mark as manually modified since user is clearing filters
            filtersManuallyModified = true;

            // Clear all filters (show everything)
            document.getElementById('filterCountry').value = '';
            document.getElementById('filterSD').checked = true;
            document.getElementById('filterHD').checked = true;
            document.getElementById('filterUHD').checked = true;
            applyMatchingFilters();
        }

        async function matchNextChannel() {
            if (!isMatching || currentMatchIndex >= matchingQueue.length) {
                finishMatching();
                return;
            }

            const channel = matchingQueue[currentMatchIndex];

            // Update progress
            updateMatchingProgress();

            // Update current channel display
            document.getElementById('currentChannelName').textContent = channel.name;
            document.getElementById('currentChannelId').textContent = channel.id;
            document.getElementById('currentStationId').textContent = channel.gracenote_id || 'None';

            // Clear manual search input and results when moving to next channel
            document.getElementById('manualSearchInput').value = '';
            document.getElementById('manualSearchResults').innerHTML = '';

            // Get suggested matches
            try {
                // Show loading indicator
                const container = document.getElementById('suggestedMatches');
                container.innerHTML = '<p style="color: #999; text-align: center; padding: 20px;"><span style="font-size: 2rem;">üîÑ</span><br/>Searching database for matches...</p>';

                // Get current filter values (unified filters with full manual control)
                const filters = getMatchingFilters();

                const response = await fetch('/api/match/suggest', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        channel_name: channel.name,
                        channel_id: channel.id,
                        existing_station_id: channel.gracenote_id || null,
                        filter_country: filters.country,
                        filter_resolutions: filters.resolutions
                    })
                });

                const data = await response.json();

                // Update parsed info and populate filters from parsed data (for every channel)
                if (data.parsed) {
                    document.getElementById('parsedCleanName').textContent = data.parsed.clean_name || '-';
                    document.getElementById('parsedCountry').textContent = data.parsed.country || 'Not detected';
                    document.getElementById('parsedResolution').textContent = data.parsed.resolution || 'Not detected';

                    // Store auto-detected values
                    autoDetectedFilters = {
                        country: data.parsed.country || '',
                        resolution: data.parsed.resolution || ''
                    };

                    // Only auto-populate filters if user hasn't manually modified them
                    if (!filtersManuallyModified) {
                        // Populate filter UI with auto-detected values for this channel
                        if (autoDetectedFilters.country) {
                            document.getElementById('filterCountry').value = autoDetectedFilters.country;
                            document.getElementById('countryAutoDetected').textContent = `(auto: ${autoDetectedFilters.country})`;
                        } else {
                            document.getElementById('filterCountry').value = '';
                            document.getElementById('countryAutoDetected').textContent = '';
                        }

                        if (autoDetectedFilters.resolution) {
                            // Normalize database format to UI format for comparison
                            const normalizedResolution = normalizeResolutionToUI(autoDetectedFilters.resolution);
                            // Check only the auto-detected resolution
                            document.getElementById('filterSD').checked = (normalizedResolution === 'SD');
                            document.getElementById('filterHD').checked = (normalizedResolution === 'HD');
                            document.getElementById('filterUHD').checked = (normalizedResolution === 'UHD');
                            document.getElementById('resolutionAutoDetected').textContent = `(auto: ${normalizedResolution})`;
                        } else {
                            // No resolution detected - show all
                            document.getElementById('filterSD').checked = true;
                            document.getElementById('filterHD').checked = true;
                            document.getElementById('filterUHD').checked = true;
                            document.getElementById('resolutionAutoDetected').textContent = '';
                        }
                    } else {
                        // User has manual filters - just update the auto-detected labels for reference
                        document.getElementById('countryAutoDetected').textContent = autoDetectedFilters.country ? `(auto: ${autoDetectedFilters.country})` : '';
                        const normalizedResolution = normalizeResolutionToUI(autoDetectedFilters.resolution);
                        document.getElementById('resolutionAutoDetected').textContent = normalizedResolution ? `(auto: ${normalizedResolution})` : '';
                    }
                }

                // Display suggested matches - user must manually accept
                displaySuggestedMatches(data.matches, channel);

            } catch (error) {
                console.error('Error getting matches:', error);
                displaySuggestedMatches([], channel);
            }
        }

        function displaySuggestedMatches(matches, channel) {
            const container = document.getElementById('suggestedMatches');

            if (!matches || matches.length === 0) {
                container.innerHTML = '<p style="color: #999;">No suggested matches found. Try manual search below.</p>';
                return;
            }

            let html = '';
            matches.forEach((match, index) => {
                const isExisting = match.is_existing === true;
                const confidence = isExisting ? 'existing' : (match.score > 0.8 ? 'high' : match.score > 0.5 ? 'medium' : 'low');
                const confColor = isExisting ? '#667eea' : (confidence === 'high' ? '#51cf66' : confidence === 'medium' ? '#ffd93d' : '#ff6b6b');

                const videoTypes = match.station.video_types ? match.station.video_types.split(',').join(', ') : 'Unknown';

                const borderStyle = isExisting ? 'border: 2px solid #667eea;' : '';
                const bgStyle = isExisting ? 'background: rgba(102, 126, 234, 0.1);' : 'background: rgba(255, 255, 255, 0.05);';

                html += `
                    <div style="padding: 15px; ${bgStyle} ${borderStyle} border-radius: 8px; margin-bottom: 10px;">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <div style="flex: 1;">
                                <div style="display: flex; align-items: center; gap: 10px;">
                                    <div style="font-weight: bold; font-size: 1.1rem;">${match.station.name}</div>
                                    ${isExisting ? '<span style="background: #667eea; color: white; padding: 3px 10px; border-radius: 12px; font-size: 0.75rem; font-weight: 600;">CURRENT MATCH</span>' : ''}
                                </div>
                                <div style="color: #999; margin-top: 5px;">
                                    ${match.station.call_sign ? `Call Sign: ${match.station.call_sign} | ` : ''}
                                    Station ID: ${match.station.station_id}
                                    ${match.station.logo_uri ? ' | üñºÔ∏è Has Logo' : ''}
                                </div>
                                <div style="color: #999; margin-top: 3px; font-size: 0.9rem;">
                                    üì∫ Resolution: ${videoTypes}
                                </div>
                                <div style="margin-top: 5px;">
                                    <span style="background: ${confColor}22; color: ${confColor}; padding: 2px 8px; border-radius: 4px; font-size: 0.9rem;">
                                        ${isExisting ? '‚úì Current Station' : Math.round(match.score * 100) + '% Match'}
                                    </span>
                                </div>
                            </div>
                            <button onclick="acceptMatch('${match.station.station_id}')"
                                    class="btn-primary" style="padding: 8px 20px;">
                                ‚úÖ ${isExisting ? 'Keep & Update' : 'Accept Match'}
                            </button>
                        </div>
                    </div>
                `;
            });

            container.innerHTML = html;
        }

        async function acceptMatch(stationId) {
            // Always use current channel from matching queue to prevent stale references
            const channel = matchingQueue[currentMatchIndex];
            if (!channel) {
                showNotification('Error: No channel selected', 'error');
                return;
            }

            const settings = await getSettings();

            if (!settings.dispatcharr || !settings.dispatcharr.url) {
                showNotification('Please configure Dispatcharr settings first!');
                switchTab('settings');
                return;
            }

            try {
                const response = await fetch('/api/match/apply', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        channel_id: channel.id,
                        station_id: stationId,
                        dispatcharr_config: settings.dispatcharr,
                        apply_options: settings.matching || {
                            applyStationId: true,
                            applyChannelName: false,
                            applyLogo: true,
                            tvgIdSource: 'none'
                        }
                    })
                });

                const result = await response.json();

                if (result.success) {
                    // Show logo status message if present (no delay needed in matching workflow)
                    if (result.logo_message) {
                        showNotification(result.logo_message, 'info');
                    }

                    // Update local channel data with the updated channel from API
                    const channelIndex = dispatcharrChannels.findIndex(ch => ch.id === channel.id);
                    if (channelIndex !== -1 && result.channel) {
                        dispatcharrChannels[channelIndex] = result.channel;
                        // Update just this channel's row immediately (improved refresh strategy)
                        updateSingleChannelRow(channel.id);
                        hasIncrementalUpdates = true;
                    }

                    // Record result
                    matchingResults.push({
                        channel: channel,
                        station: result.station,
                        status: 'matched'
                    });

                    // Move to next channel - reset manual filter flag
                    currentMatchIndex++;
                    filtersManuallyModified = false;
                    await matchNextChannel();
                } else {
                    showNotification('Failed to apply match: ' + (result.error || 'Unknown error'));
                }
            } catch (error) {
                showNotification('Error applying match: ' + error.message);
            }
        }

        function skipCurrentChannel() {
            const channel = matchingQueue[currentMatchIndex];
            matchingResults.push({
                channel: channel,
                status: 'skipped'
            });

            // Move to next channel - reset manual filter flag
            currentMatchIndex++;
            filtersManuallyModified = false;
            matchNextChannel();
        }

        async function stopMatching() {
            if (await showConfirm('Are you sure you want to stop the matching process?')) {
                isMatching = false;
                finishMatching();
            }
        }

        function updateMatchingProgress() {
            const progress = currentMatchIndex + 1;
            const total = matchingQueue.length;
            const percentage = Math.round((progress / total) * 100);

            document.getElementById('matchProgress').textContent = progress;
            document.getElementById('matchTotal').textContent = total;
            document.getElementById('matchPercentage').textContent = percentage + '%';
            document.getElementById('matchProgressBar').style.width = percentage + '%';
        }

        function finishMatching() {
            isMatching = false;

            // Hide interface, show results
            document.getElementById('matchingInterface').style.display = 'none';
            document.getElementById('matchingResults').style.display = 'block';

            // Display summary
            const matched = matchingResults.filter(r => r.status === 'matched').length;
            const skipped = matchingResults.filter(r => r.status === 'skipped').length;

            const summaryHtml = `
                <div style="padding: 20px; background: rgba(255, 255, 255, 0.05); border-radius: 10px;">
                    <h4>Matching Complete!</h4>
                    <div style="margin-top: 15px;">
                        <p>‚úÖ Matched: ${matched} channels</p>
                        <p>‚è≠Ô∏è Skipped: ${skipped} channels</p>
                        <p>üìä Total Processed: ${matchingResults.length} channels</p>
                    </div>
                    ${matched > 0 ? '<p style="color: #51cf66; margin-top: 15px;">Channels have been updated in Dispatcharr!</p>' : ''}
                    <div style="margin-top: 20px;">
                        <button onclick="switchTab('dispatcharr')" class="btn-primary">üì° View Dispatcharr Channels</button>
                    </div>
                </div>
            `;

            document.getElementById('matchingSummary').innerHTML = summaryHtml;

            // Set flag to reload channels when modal closes
            if (matched > 0) {
                channelChangedInModal = true;
            }
        }

        async function performManualSearch() {
            const query = document.getElementById('manualSearchInput').value;
            if (!query) return;

            try {
                // Get current filter values (unified filters with full manual control)
                const filters = getMatchingFilters();

                // Build query string with filters
                let queryParams = `q=${encodeURIComponent(query)}&limit=10`;
                if (filters.country) {
                    queryParams += `&country=${encodeURIComponent(filters.country)}`;
                }
                if (filters.resolutions.length > 0) {
                    queryParams += `&quality=${encodeURIComponent(filters.resolutions.join(','))}`;
                }

                const response = await fetch(`/api/search/stations?${queryParams}`);
                const data = await response.json();

                const container = document.getElementById('manualSearchResults');

                if (!data.results || data.results.length === 0) {
                    container.innerHTML = '<p style="color: #999;">No results found</p>';
                    return;
                }

                let html = '<div style="max-height: 300px; overflow-y: auto;">';
                data.results.forEach(station => {
                    html += `
                        <div style="padding: 10px; background: rgba(0, 0, 0, 0.3); border-radius: 6px; margin-bottom: 8px;">
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <div>
                                    <div style="font-weight: bold;">${station.name}</div>
                                    <div style="color: #999; font-size: 0.9rem;">
                                        ${station.call_sign || 'No call sign'} | ID: ${station.station_id}
                                    </div>
                                </div>
                                <button onclick="acceptMatch('${station.station_id}')"
                                        class="btn-secondary" style="padding: 5px 15px; font-size: 0.9rem;">
                                    Select
                                </button>
                            </div>
                        </div>
                    `;
                });
                html += '</div>';

                container.innerHTML = html;
            } catch (error) {
                document.getElementById('manualSearchResults').innerHTML = '<p style="color: #ff6b6b;">Search failed</p>';
            }
        }

        async function startBulkMatching() {
            if (!await showConfirm('This will suggest matches for all channels. You will review before applying. Continue?')) {
                return;
            }

            // Load channels if needed
            if (dispatcharrChannels.length === 0) {
                await loadDispatcharrChannels();
            }

            const settings = await getSettings();

            if (!settings.dispatcharr || !settings.dispatcharr.url) {
                showNotification('Please configure Dispatcharr settings first!');
                switchTab('settings');
                return;
            }

            // Get unmatched channels
            const unmatchedChannels = dispatcharrChannels.filter(ch => !ch.gracenote_id);

            if (unmatchedChannels.length === 0) {
                showNotification('All channels already have Gracenote IDs!');
                return;
            }

            // Show progress
            document.getElementById('matchingProgress').style.display = 'block';

            try {
                const response = await fetch('/api/match/batch', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        channels: unmatchedChannels.map(ch => ({
                            id: ch.id,
                            name: ch.name
                        }))
                    })
                });

                const results = await response.json();

                // Display bulk results
                document.getElementById('matchingResults').style.display = 'block';
                document.getElementById('matchingSummary').innerHTML = `
                    <div style="padding: 20px; background: rgba(255, 255, 255, 0.05); border-radius: 10px;">
                        <h4>Bulk Matching Results</h4>
                        <div style="margin-top: 15px;">
                            <p>‚úÖ High Confidence: ${results.matched} channels</p>
                            <p>‚ö†Ô∏è Medium Confidence: ${results.review_needed} channels</p>
                            <p>‚ùå No Match Found: ${results.no_match} channels</p>
                            <p>üö´ Errors: ${results.errors} channels</p>
                        </div>
                        <p style="margin-top: 15px; color: #999; font-size: 0.9rem;">
                            üí° All matches require your review before being applied
                        </p>
                        <button onclick="reviewBulkMatches(${JSON.stringify(results.results).replace(/"/g, '&quot;')})"
                                class="btn-primary" style="margin-top: 15px;">
                            Review & Apply Matches
                        </button>
                    </div>
                `;

            } catch (error) {
                showNotification('Bulk matching failed: ' + error.message);
            } finally {
                document.getElementById('matchingProgress').style.display = 'none';
            }
        }

        function reviewBulkMatches(results) {
            // Filter for review
            matchingQueue = results.filter(r => r.status === 'review_needed' || r.status === 'no_match')
                .map(r => r.channel);

            if (matchingQueue.length === 0) {
                showNotification('No channels need review!');
                return;
            }

            // Start matching process for review
            currentMatchIndex = 0;
            matchingResults = [];
            isMatching = true;

            document.getElementById('matchingInterface').style.display = 'block';
            document.getElementById('matchingResults').style.display = 'none';

            matchNextChannel();
        }

        // New multi-select and matching functions
        function toggleSelectAll() {
            const selectAll = document.getElementById('selectAllChannels');
            // Only select visible checkboxes (those in displayed rows)
            const visibleRows = document.querySelectorAll('#dispatcharrTableBody tr:not([style*="display: none"])');
            visibleRows.forEach(row => {
                const checkbox = row.querySelector('.channel-checkbox');
                if (checkbox) {
                    checkbox.checked = selectAll.checked;
                }
            });
            updateMatchButtons();
        }

        function updateMatchButtons() {
            const selectedChannels = document.querySelectorAll('.channel-checkbox:checked').length;
            const matchBtn = document.getElementById('matchSelectedBtn');
            const bulkEditBtn = document.getElementById('bulkEditGroupBtn');
            const bulkDeleteBtn = document.getElementById('bulkDeleteBtn');

            if (matchBtn) {
                matchBtn.disabled = selectedChannels === 0;
            }
            if (bulkEditBtn) {
                bulkEditBtn.disabled = selectedChannels === 0;
            }
            if (bulkDeleteBtn) {
                bulkDeleteBtn.disabled = selectedChannels === 0;
            }
        }

        function selectAll() {
            const checkboxes = document.querySelectorAll('.channel-checkbox');
            checkboxes.forEach(cb => cb.checked = true);
            document.getElementById('selectAllChannels').checked = true;
            updateMatchButtons();
        }

        function selectMissingGracenote() {
            // Deselect all first
            document.querySelectorAll('.channel-checkbox').forEach(cb => cb.checked = false);
            document.getElementById('selectAllChannels').checked = false;

            // Select channels missing gracenote_id
            dispatcharrChannels.forEach(channel => {
                if (!channel.gracenote_id || channel.gracenote_id === 'Not Set') {
                    const checkbox = document.querySelector(`.channel-checkbox[data-channel-id="${channel.id}"]`);
                    if (checkbox) checkbox.checked = true;
                }
            });
            updateMatchButtons();
        }

        function selectMissingLogo() {
            // Deselect all first
            document.querySelectorAll('.channel-checkbox').forEach(cb => cb.checked = false);
            document.getElementById('selectAllChannels').checked = false;

            // Select channels missing logo
            dispatcharrChannels.forEach(channel => {
                if (!channel.logo_url || channel.logo_url.trim() === '') {
                    const checkbox = document.querySelector(`.channel-checkbox[data-channel-id="${channel.id}"]`);
                    if (checkbox) checkbox.checked = true;
                }
            });
            updateMatchButtons();
        }

        function selectMissingTvgId() {
            // Deselect all first
            document.querySelectorAll('.channel-checkbox').forEach(cb => cb.checked = false);
            document.getElementById('selectAllChannels').checked = false;

            // Select channels missing tvg_id (call_sign)
            dispatcharrChannels.forEach(channel => {
                if (!channel.call_sign || channel.call_sign === 'N/A' || channel.call_sign.trim() === '') {
                    const checkbox = document.querySelector(`.channel-checkbox[data-channel-id="${channel.id}"]`);
                    if (checkbox) checkbox.checked = true;
                }
            });
            updateMatchButtons();
        }

        async function bulkDeleteChannels() {
            const selectedIds = Array.from(document.querySelectorAll('.channel-checkbox:checked'))
                .map(cb => parseInt(cb.dataset.channelId));

            if (selectedIds.length === 0) {
                showNotification('No channels selected!', 'error');
                return;
            }

            const confirmMsg = `‚ö†Ô∏è WARNING: You are about to DELETE ${selectedIds.length} channel(s).\n\nThis action CANNOT be undone!\n\nAre you absolutely sure you want to proceed?`;
            if (!await showConfirm(confirmMsg)) {
                return;
            }

            const settings = await getSettings();
            if (!settings.dispatcharr || !settings.dispatcharr.url) {
                showNotification('Please configure Dispatcharr settings first', 'error');
                return;
            }

            showNotification(`Deleting ${selectedIds.length} channel(s)...`, 'info');

            let successCount = 0;
            let errorCount = 0;

            for (const channelId of selectedIds) {
                try {
                    const response = await fetch(`/api/dispatcharr/channels/${channelId}/delete`, {
                        method: 'DELETE',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            url: settings.dispatcharr.url,
                            username: settings.dispatcharr.username,
                            password: settings.dispatcharr.password
                        })
                    });

                    const data = await response.json();

                    if (data.success) {
                        successCount++;
                    } else {
                        errorCount++;
                    }
                } catch (error) {
                    errorCount++;
                }
            }

            // Show results
            if (errorCount === 0) {
                showNotification(`‚úì Successfully deleted ${successCount} channel(s)`, 'success');
            } else {
                showNotification(`Completed: ${successCount} deleted, ${errorCount} failed`, 'error');
            }

            // Reload channels
            await loadDispatcharrChannels();
        }

        async function bulkEditGroup() {
            const selectedIds = Array.from(document.querySelectorAll('.channel-checkbox:checked'))
                .map(cb => parseInt(cb.dataset.channelId));

            if (selectedIds.length === 0) {
                showNotification('No channels selected!', 'error');
                return;
            }

            // Load groups if not already loaded
            if (!dispatcharrGroups || dispatcharrGroups.length === 0) {
                await loadDispatcharrGroups();
            }

            // Store groups for filtering
            window.bulkEditGroupsList = [...dispatcharrGroups];

            const modalHtml = `
                <div style="background: white; padding: 20px; border-radius: 8px; max-width: 500px; color: #333;">
                    <h3 style="margin-top: 0;">Bulk Edit Group</h3>
                    <p style="color: #666;">Change group for ${selectedIds.length} selected channel(s)</p>

                    <div style="margin: 20px 0;">
                        <label style="display: block; margin-bottom: 5px; color: #333;">Select New Group:</label>

                        <!-- Filter Input -->
                        <input type="text" id="bulkEditGroupFilter" placeholder="Type to filter groups..."
                            style="width: 100%; padding: 8px; margin-bottom: 8px; border: 1px solid #ccc; border-radius: 4px;"
                            oninput="filterBulkEditGroups()">

                        <!-- Create New Group Button -->
                        <button onclick="toggleBulkCreateGroupForm()" class="btn-secondary"
                            style="width: 100%; margin-bottom: 8px; padding: 8px; font-size: 0.9rem; background: #667eea; border-color: #667eea; color: white;">
                            ‚ûï Create New Group
                        </button>

                        <!-- Inline Group Creation Form -->
                        <div id="bulkInlineGroupCreateForm" style="display: none; background: rgba(102, 126, 234, 0.1); border: 1px solid #667eea; padding: 12px; border-radius: 6px; margin-bottom: 8px;">
                            <div style="display: flex; gap: 8px; align-items: center;">
                                <input type="text" id="bulkNewGroupName" placeholder="Enter group name (e.g., NEWS)"
                                    style="flex: 1; padding: 8px; border: 1px solid #ccc; border-radius: 4px;"
                                    onkeypress="if(event.key==='Enter') createGroupInlineBulk()">
                                <button onclick="createGroupInlineBulk()" class="btn-primary" style="padding: 8px 16px; white-space: nowrap;">Create</button>
                                <button onclick="cancelCreateGroupInlineBulk()" class="btn-secondary" style="padding: 8px 16px;">Cancel</button>
                            </div>
                            <div id="bulkInlineGroupStatus" style="font-size: 0.85rem; margin-top: 8px;"></div>
                        </div>

                        <!-- Show Custom Only Checkbox -->
                        <label style="display: flex; align-items: center; margin-bottom: 8px; cursor: pointer;">
                            <input type="checkbox" id="bulkEditShowCustomOnly" onchange="filterBulkEditGroups()" style="margin-right: 8px;">
                            <span style="font-size: 0.9rem; color: #666;">Show only custom groups (no M3U associations)</span>
                        </label>

                        <!-- Group Select Dropdown -->
                        <select id="bulkEditGroupSelect" size="5"
                            style="width: 100%; padding: 10px; border: 1px solid #ccc; border-radius: 4px; max-height: 150px;">
                            <option value="">-- Remove Group --</option>
                        </select>

                        <!-- Filter Status -->
                        <div id="bulkGroupFilterStatus" style="font-size: 0.85rem; color: #666; margin-top: 5px;"></div>
                    </div>

                    <div style="display: flex; gap: 10px; justify-content: flex-end;">
                        <button onclick="closeBulkEditGroupModal()" class="btn-secondary" style="padding: 8px 16px;">Cancel</button>
                        <button onclick="applyBulkGroupEdit()" class="btn-primary" style="padding: 8px 16px;">Apply Changes</button>
                    </div>
                </div>
            `;

            // Show modal
            const modalBg = document.createElement('div');
            modalBg.id = 'bulkEditGroupModal';
            modalBg.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); display: flex; align-items: center; justify-content: center; z-index: 10000;';
            modalBg.innerHTML = modalHtml;
            document.body.appendChild(modalBg);

            // Initialize the filter
            filterBulkEditGroups();
        }

        function filterBulkEditGroups() {
            const filter = document.getElementById('bulkEditGroupFilter').value.toLowerCase();
            const showCustomOnly = document.getElementById('bulkEditShowCustomOnly').checked;
            const select = document.getElementById('bulkEditGroupSelect');

            let filtered = window.bulkEditGroupsList.filter(g => {
                // Text filter
                const matchesText = g.name.toLowerCase().includes(filter);

                // Custom groups filter (groups with no M3U associations)
                const isCustomGroup = !g.m3u_account_count || g.m3u_account_count === 0;
                const matchesCustomFilter = !showCustomOnly || isCustomGroup;

                return matchesText && matchesCustomFilter;
            });

            select.innerHTML = '<option value="">-- Remove Group --</option>';

            filtered.forEach(group => {
                const option = document.createElement('option');
                option.value = group.id;

                // Add indicator for M3U-associated groups
                const m3uIndicator = group.m3u_account_count > 0 ? ` üì°(${group.m3u_account_count})` : '';
                option.textContent = group.name + m3uIndicator;

                select.appendChild(option);
            });

            const customOnlyText = showCustomOnly ? ' custom' : '';
            const statusText = showCustomOnly && filtered.length === 0
                ? 'No custom groups found (all groups have M3U associations)'
                : `Showing ${filtered.length}${customOnlyText} of ${window.bulkEditGroupsList.length} groups`;

            document.getElementById('bulkGroupFilterStatus').textContent = statusText;
        }

        function toggleBulkCreateGroupForm() {
            const form = document.getElementById('bulkInlineGroupCreateForm');
            const isVisible = form.style.display !== 'none';
            form.style.display = isVisible ? 'none' : 'block';

            if (!isVisible) {
                document.getElementById('bulkNewGroupName').focus();
            }
        }

        async function createGroupInlineBulk() {
            const groupName = document.getElementById('bulkNewGroupName').value.trim();
            const statusDiv = document.getElementById('bulkInlineGroupStatus');

            if (!groupName) {
                statusDiv.innerHTML = '<span style="color: #ff6b6b;">‚ö†Ô∏è Group name is required</span>';
                return;
            }

            const settings = await getSettings();
            if (!settings.dispatcharr || !settings.dispatcharr.url) {
                statusDiv.innerHTML = '<span style="color: #ff6b6b;">‚ö†Ô∏è Please configure Dispatcharr settings first</span>';
                return;
            }

            statusDiv.innerHTML = '<span style="color: #999;">Creating group...</span>';

            try {
                const response = await fetch('/api/dispatcharr/groups', {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        url: settings.dispatcharr.url,
                        username: settings.dispatcharr.username,
                        password: settings.dispatcharr.password,
                        name: groupName
                    })
                });

                const data = await response.json();

                if (data.success) {
                    statusDiv.innerHTML = '<span style="color: #51cf66;">‚úÖ Group created!</span>';

                    // Reload groups and refresh UI
                    await loadDispatcharrGroups();
                    window.bulkEditGroupsList = [...dispatcharrGroups];

                    // Refresh the filter
                    filterBulkEditGroups();

                    // Select the newly created group
                    const select = document.getElementById('bulkEditGroupSelect');
                    const newOption = Array.from(select.options).find(opt => opt.textContent.startsWith(groupName));
                    if (newOption) {
                        newOption.selected = true;
                    }

                    // Hide the form after success
                    setTimeout(() => {
                        document.getElementById('bulkInlineGroupCreateForm').style.display = 'none';
                        document.getElementById('bulkNewGroupName').value = '';
                    }, 1500);
                } else {
                    statusDiv.innerHTML = `<span style="color: #ff6b6b;">‚ö†Ô∏è Error: ${data.error || 'Failed to create group'}</span>`;
                }
            } catch (error) {
                statusDiv.innerHTML = `<span style="color: #ff6b6b;">‚ö†Ô∏è Error: ${error.message}</span>`;
            }
        }

        function cancelCreateGroupInlineBulk() {
            document.getElementById('bulkInlineGroupCreateForm').style.display = 'none';
            document.getElementById('bulkNewGroupName').value = '';
            document.getElementById('bulkInlineGroupStatus').innerHTML = '';
        }

        function closeBulkEditGroupModal() {
            const modal = document.getElementById('bulkEditGroupModal');
            if (modal) {
                modal.remove();
            }
        }

        async function applyBulkGroupEdit() {
            const groupId = document.getElementById('bulkEditGroupSelect').value;
            const selectedIds = Array.from(document.querySelectorAll('.channel-checkbox:checked'))
                .map(cb => parseInt(cb.dataset.channelId));

            closeBulkEditGroupModal();

            const settings = await getSettings();
            if (!settings.dispatcharr || !settings.dispatcharr.url) {
                showNotification('Please configure Dispatcharr settings first', 'error');
                return;
            }

            showNotification(`Updating ${selectedIds.length} channel(s)...`, 'info');

            let successCount = 0;
            let errorCount = 0;

            for (const channelId of selectedIds) {
                try {
                    const response = await fetch(`/api/dispatcharr/channels/${channelId}`, {
                        method: 'PATCH',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            url: settings.dispatcharr.url,
                            username: settings.dispatcharr.username,
                            password: settings.dispatcharr.password,
                            update_data: {
                                group_id: groupId ? parseInt(groupId) : null
                            }
                        })
                    });

                    const data = await response.json();

                    if (data.success) {
                        successCount++;
                        // Update local channel data
                        const channelIndex = dispatcharrChannels.findIndex(ch => ch.id === channelId);
                        if (channelIndex !== -1 && data.channel) {
                            dispatcharrChannels[channelIndex] = data.channel;
                        }
                    } else {
                        errorCount++;
                    }
                } catch (error) {
                    errorCount++;
                }
            }

            // Show results
            if (errorCount === 0) {
                showNotification(`‚úì Successfully updated ${successCount} channel(s)`, 'success');
            } else {
                showNotification(`Completed: ${successCount} updated, ${errorCount} failed`, 'error');
            }

            // Reload channels to show changes
            await loadDispatcharrChannels();
        }

        async function matchSelectedStations() {
            const selectedIds = Array.from(document.querySelectorAll('.channel-checkbox:checked'))
                .map(cb => parseInt(cb.dataset.channelId));

            const selectedChannels = dispatcharrChannels.filter(ch => selectedIds.includes(ch.id));

            if (selectedChannels.length === 0) {
                showNotification('No channels selected!');
                return;
            }

            if (!await showConfirm(`Match ${selectedChannels.length} selected channel(s)?\n\nYou will review each match before it is applied.`)) {
                return;
            }

            startMatchingWorkflow(selectedChannels);
        }

        function searchAndMatch(channelId) {
            const channel = dispatcharrChannels.find(ch => ch.id === channelId);
            if (!channel) {
                showNotification('Channel not found');
                return;
            }

            startMatchingWorkflow([channel]);
        }

        function startMatchingWorkflow(channels) {
            // Set up matching queue
            matchingQueue = channels;
            currentMatchIndex = 0;
            matchingResults = [];
            isMatching = true;

            // Reset change tracking flag
            channelChangedInModal = false;

            // Reset filter flag for first channel
            filtersManuallyModified = false;

            // Show matching modal
            document.getElementById('matchingModal').style.display = 'flex';
            document.getElementById('matchingInterface').style.display = 'block';
            document.getElementById('matchingResults').style.display = 'none';

            matchNextChannel();
        }

        function closeMatchingModal() {
            document.getElementById('matchingModal').style.display = 'none';
            isMatching = false;
            matchingQueue = [];
            currentMatchIndex = 0;
            // Improved refresh strategy: skip reload if we already did incremental updates
            if (hasIncrementalUpdates) {
                hasIncrementalUpdates = false;
            } else if (channelChangedInModal) {
                loadDispatcharrChannels();
            }
            channelChangedInModal = false;
        }

        // Load database metadata
        async function loadDatabaseMetadata() {
            try {
                const response = await fetch('/api/database/metadata');
                const data = await response.json();

                if (data.version !== 'Unknown') {
                    document.getElementById('dbVersion').textContent = data.version;
                    document.getElementById('dbEffectiveDate').textContent = data.effective_date;
                    document.getElementById('dbSchema').textContent = data.schema_version;
                    document.getElementById('dbMetadata').style.display = 'block';
                }
            } catch (error) {
                console.error('Failed to load database metadata:', error);
            }
        }

        // Populate Emby country dropdown from database
        async function populateEmbyCountries() {
            try {
                const response = await fetch('/api/metadata');
                const data = await response.json();

                const embyCountrySelect = document.getElementById('embyCountrySelect');

                // Clear existing options except "Any Country"
                while (embyCountrySelect.options.length > 1) {
                    embyCountrySelect.remove(1);
                }

                // Add USA first if it exists
                if (data.countries.includes('USA')) {
                    const usaOption = document.createElement('option');
                    usaOption.value = 'USA';
                    usaOption.textContent = 'USA - United States';
                    usaOption.selected = true;  // Set USA as default
                    embyCountrySelect.appendChild(usaOption);

                    // Add divider
                    const divider = document.createElement('option');
                    divider.disabled = true;
                    divider.textContent = '‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ';
                    embyCountrySelect.appendChild(divider);
                }

                // Country name mappings
                const countryNames = {
                    'AIA': 'Anguilla',
                    'ARG': 'Argentina',
                    'AUS': 'Australia',
                    'AUT': 'Austria',
                    'BEL': 'Belgium',
                    'BLZ': 'Belize',
                    'BMU': 'Bermuda',
                    'BRA': 'Brazil',
                    'BRB': 'Barbados',
                    'CAN': 'Canada',
                    'CHE': 'Switzerland',
                    'CHL': 'Chile',
                    'COL': 'Colombia',
                    'CRI': 'Costa Rica',
                    'CYM': 'Cayman Islands',
                    'DEU': 'Germany',
                    'DNK': 'Denmark',
                    'DOM': 'Dominican Republic',
                    'ECU': 'Ecuador',
                    'ESP': 'Spain',
                    'FIN': 'Finland',
                    'FRA': 'France',
                    'GBR': 'United Kingdom',
                    'GRC': 'Greece',
                    'HND': 'Honduras',
                    'IRL': 'Ireland',
                    'ISL': 'Iceland',
                    'ITA': 'Italy',
                    'JAM': 'Jamaica',
                    'LUX': 'Luxembourg',
                    'MEX': 'Mexico',
                    'NLD': 'Netherlands',
                    'NOR': 'Norway',
                    'NZL': 'New Zealand',
                    'PAN': 'Panama',
                    'PER': 'Peru',
                    'PRT': 'Portugal',
                    'SWE': 'Sweden',
                    'TCA': 'Turks and Caicos',
                    'TTO': 'Trinidad and Tobago',
                    'URY': 'Uruguay',
                    'VEN': 'Venezuela'
                };

                // Add all countries alphabetically (excluding USA since it's already added)
                data.countries.sort().forEach(country => {
                    if (country !== 'USA') {
                        const option = document.createElement('option');
                        option.value = country;
                        const countryName = countryNames[country] || country;
                        option.textContent = `${country} - ${countryName}`;
                        embyCountrySelect.appendChild(option);
                    }
                });

            } catch (error) {
                console.error('Failed to populate Emby countries:', error);
            }
        }


        // Create Channel Modal State
        let createChannelStationData = null;
        let createChannelStreams = [];
        let allGroupsForFilter = [];

        async function openCreateChannelModal(stationId) {
            // Fetch station details
            try {
                const response = await fetch(`/api/station/${stationId}`);
                if (!response.ok) {
                    throw new Error(`Failed to fetch station: ${response.status}`);
                }
                const station = await response.json();
                createChannelStationData = station;

                // Populate station info
                document.getElementById('createChannelStationInfo').innerHTML = `
                    <div><strong>Name:</strong> ${station.name}</div>
                    <div><strong>Call Sign:</strong> ${station.call_sign || 'N/A'}</div>
                    <div><strong>Gracenote ID:</strong> ${station.station_id}</div>
                    ${station.logo_uri ? `<img src="${station.logo_uri}" style="max-width: 100px; margin-top: 10px;">` : ''}
                `;

                // Pre-populate form
                document.getElementById('createChannelName').value = station.name || '';
                document.getElementById('createChannelGracenoteId').value = station.station_id || '';
                document.getElementById('createChannelTvgId').value = station.call_sign || '';
                document.getElementById('createChannelNumber').value = '';
                document.getElementById('createChannelGroupFilter').value = '';
                document.getElementById('createChannelShowCustomOnly').checked = false;
                createChannelStreams = [];

                // Clear stream search results and assigned streams
                document.getElementById('createChannelStreamSearchResults').innerHTML = '';
                renderCreateChannelAssignedStreams();

                // Load channels in background for sidebar and suggestions
                await ensureChannelsLoaded();

                // Load groups (default group selection happens in filterGroupsInCreate)
                await loadGroupsForCreate();

                // Render sidebar
                renderChannelSidebar();

                // Show modal and reset scroll position
                const modal = document.getElementById('createChannelModal');
                modal.style.display = 'flex';
                // Reset scroll to top
                const modalContent = modal.querySelector('.modal-content');
                if (modalContent) {
                    modalContent.scrollTop = 0;
                }
            } catch (error) {
                showNotification(`Failed to load station details: ${error.message}`, 'error');
                console.error('Error opening create channel modal:', error);
            }
        }

        async function openCreateCustomChannelModal() {
            // Open Create Channel modal without station data (for custom channels)
            try {
                createChannelStationData = null;

                // Show empty station info
                document.getElementById('createChannelStationInfo').innerHTML = `
                    <div style="text-align: center; color: #999; padding: 10px;">
                        <div style="font-size: 1.1rem; margin-bottom: 5px;">Custom Channel</div>
                        <div style="font-size: 0.85rem;">Not linked to Gracenote database</div>
                    </div>
                `;

                // Clear all form fields
                document.getElementById('createChannelName').value = '';
                document.getElementById('createChannelGracenoteId').value = '';
                document.getElementById('createChannelTvgId').value = '';
                document.getElementById('createChannelNumber').value = '';
                document.getElementById('createChannelGroupFilter').value = '';
                document.getElementById('createChannelShowCustomOnly').checked = false;
                createChannelStreams = [];

                // Clear stream search results and assigned streams
                document.getElementById('createChannelStreamSearchResults').innerHTML = '';
                renderCreateChannelAssignedStreams();

                // Load channels in background for sidebar and suggestions
                await ensureChannelsLoaded();

                // Load groups (default group selection happens in filterGroupsInCreate)
                await loadGroupsForCreate();

                // Render sidebar
                renderChannelSidebar();

                // Show modal and reset scroll position
                const modal = document.getElementById('createChannelModal');
                modal.style.display = 'flex';
                // Reset scroll to top
                const modalContent = modal.querySelector('.modal-content');
                if (modalContent) {
                    modalContent.scrollTop = 0;
                }
            } catch (error) {
                showNotification(`Failed to open custom channel modal: ${error.message}`, 'error');
                console.error('Error opening custom channel modal:', error);
            }
        }

        function closeCreateChannelModal() {
            document.getElementById('createChannelModal').style.display = 'none';
            createChannelStationData = null;
            createChannelStreams = [];
            allGroupsForFilter = [];
        }

        async function ensureChannelsLoaded() {
            // Auto-load channels if not already loaded
            if (!dispatcharrChannels || dispatcharrChannels.length === 0) {
                const settings = await getSettings();
                if (settings.dispatcharr && settings.dispatcharr.url) {
                    try {
                        const response = await fetch('/api/dispatcharr/channels', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                url: settings.dispatcharr.url,
                                username: settings.dispatcharr.username,
                                password: settings.dispatcharr.password
                            })
                        });
                        const data = await response.json();
                        if (data.channels) {
                            dispatcharrChannels = data.channels;
                        }
                    } catch (error) {
                        console.error('Failed to auto-load channels:', error);
                    }
                }
            }
        }

        async function loadGroupsForCreate() {
            if (!dispatcharrGroups || dispatcharrGroups.length === 0) {
                await loadDispatcharrGroups();
            }

            allGroupsForFilter = [...dispatcharrGroups];

            // Use the filter function to populate (it will show all groups initially)
            filterGroupsInCreate();
        }

        function filterGroupsInCreate() {
            const filter = document.getElementById('createChannelGroupFilter').value.toLowerCase();
            const showCustomOnly = document.getElementById('createChannelShowCustomOnly').checked;
            const select = document.getElementById('createChannelGroup');

            let filtered = allGroupsForFilter.filter(g => {
                // Text filter
                const matchesText = g.name.toLowerCase().includes(filter);

                // Custom groups filter (groups with no M3U associations)
                const isCustomGroup = !g.m3u_account_count || g.m3u_account_count === 0;
                const matchesCustomFilter = !showCustomOnly || isCustomGroup;

                return matchesText && matchesCustomFilter;
            });

            select.innerHTML = '';

            // Track if we found and selected the default
            let defaultFound = false;

            filtered.forEach((group, index) => {
                const option = document.createElement('option');
                option.value = group.id;

                // Add indicator for M3U-associated groups
                const m3uIndicator = group.m3u_account_count > 0 ? ` üì°(${group.m3u_account_count})` : '';
                option.textContent = group.name + m3uIndicator;

                // Check if this is the default group
                if (defaultGroupId && group.id == defaultGroupId) {
                    option.selected = true;
                    defaultFound = true;
                } else if (index === 0 && !defaultFound) {
                    // Only auto-select first if no default group is set or found
                    option.selected = true;
                }

                select.appendChild(option);
            });

            const customOnlyText = showCustomOnly ? ' custom' : '';
            const statusText = showCustomOnly && filtered.length === 0
                ? 'No custom groups found (all groups have M3U associations)'
                : `Showing ${filtered.length}${customOnlyText} of ${allGroupsForFilter.length} groups`;

            document.getElementById('groupFilterStatus').textContent = statusText;
        }

        function toggleCreateGroupForm() {
            const form = document.getElementById('inlineGroupCreateForm');
            const isVisible = form.style.display !== 'none';
            form.style.display = isVisible ? 'none' : 'block';

            if (!isVisible) {
                document.getElementById('newGroupName').focus();
            }
        }

        async function createGroupInline() {
            const groupName = document.getElementById('newGroupName').value.trim();
            const statusDiv = document.getElementById('inlineGroupStatus');

            if (!groupName) {
                statusDiv.innerHTML = '<span style="color: #ff6b6b;">‚ö†Ô∏è Group name is required</span>';
                return;
            }

            const settings = await getSettings();
            if (!settings.dispatcharr || !settings.dispatcharr.url) {
                statusDiv.innerHTML = '<span style="color: #ff6b6b;">‚ö†Ô∏è Please configure Dispatcharr settings first</span>';
                return;
            }

            statusDiv.innerHTML = '<span style="color: #999;">Creating group...</span>';

            try {
                const response = await fetch('/api/dispatcharr/groups', {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        url: settings.dispatcharr.url,
                        username: settings.dispatcharr.username,
                        password: settings.dispatcharr.password,
                        name: groupName
                    })
                });

                const data = await response.json();

                if (data.success) {
                    statusDiv.innerHTML = '<span style="color: #51cf66;">‚úÖ Group created!</span>';

                    // Force reload groups from API and refresh the UI
                    await loadDispatcharrGroups();
                    await loadGroupsForCreate();

                    // Select the newly created group
                    const select = document.getElementById('createChannelGroup');
                    const newOption = Array.from(select.options).find(opt =>
                        opt.textContent.includes(groupName)
                    );
                    if (newOption) {
                        newOption.selected = true;
                    }

                    // Clear and hide form after brief delay
                    setTimeout(() => {
                        cancelCreateGroupInline();
                    }, 1500);

                    showNotification(`Group "${groupName}" created successfully!`, 'success');
                } else {
                    statusDiv.innerHTML = `<span style="color: #ff6b6b;">‚ùå Failed: ${data.error || 'Unknown error'}</span>`;
                }
            } catch (error) {
                statusDiv.innerHTML = '<span style="color: #ff6b6b;">‚ùå Error creating group</span>';
                console.error(error);
            }
        }

        function cancelCreateGroupInline() {
            document.getElementById('inlineGroupCreateForm').style.display = 'none';
            document.getElementById('newGroupName').value = '';
            document.getElementById('inlineGroupStatus').innerHTML = '';
        }

        function renderChannelSidebar() {
            const container = document.getElementById('channelSidebarList');

            if (!dispatcharrChannels || dispatcharrChannels.length === 0) {
                container.innerHTML = '<div style="text-align: center; color: #666;">No channels loaded</div>';
                return;
            }

            const sorted = [...dispatcharrChannels]
                .filter(ch => ch.channel_number)
                .sort((a, b) => parseFloat(a.channel_number) - parseFloat(b.channel_number));

            container.innerHTML = sorted.map(ch => {
                const num = parseFloat(ch.channel_number);
                const range = num < 1000 ? '1-999' : num < 2000 ? '1000-1999' : num < 3000 ? '2000-2999' : '3000+';
                return `
                    <div style="padding: 6px; border-bottom: 1px solid rgba(255,255,255,0.05); cursor: pointer; display: flex; justify-content: space-between;"
                         onclick="document.getElementById('createChannelNumber').value = ${num}"
                         title="Click to use this number as reference">
                        <span style="font-weight: bold; color: #667eea;">${ch.channel_number}</span>
                        <span style="color: #999; font-size: 0.8rem; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; max-width: 180px;">${ch.name}</span>
                    </div>
                `;
            }).join('');
        }

        function filterChannelSidebar() {
            const filter = document.getElementById('channelSidebarFilter').value.toLowerCase();
            const items = document.querySelectorAll('#channelSidebarList > div');

            items.forEach(item => {
                const text = item.textContent.toLowerCase();
                item.style.display = text.includes(filter) ? '' : 'none';
            });
        }

        async function suggestChannelNumber(mode) {
            try {
                // Ensure channels are loaded
                await ensureChannelsLoaded();

                if (!dispatcharrChannels || dispatcharrChannels.length === 0) {
                    document.getElementById('channelNumberSuggestion').textContent = 'No existing channels found - you can use any number';
                    document.getElementById('createChannelNumber').value = 1;
                    return;
                }

                const usedNumbers = dispatcharrChannels
                    .map(ch => parseFloat(ch.channel_number))
                    .filter(n => !isNaN(n))
                    .sort((a, b) => a - b);

                let suggested;
                let range;

                if (mode === 'first') {
                    // Find first gap or use 1
                    suggested = 1;
                    for (const num of usedNumbers) {
                        if (num === suggested) {
                            suggested++;
                        } else if (num > suggested) {
                            break;
                        }
                    }
                } else if (mode === 'next') {
                    // Highest + 1
                    suggested = usedNumbers.length > 0 ? Math.floor(usedNumbers[usedNumbers.length - 1]) + 1 : 1;
                } else if (mode.startsWith('range-')) {
                    // Next available in range (format: range-START-END)
                    const parts = mode.split('-');
                    const rangeStart = parseInt(parts[1]);
                    const rangeEnd = parseInt(parts[2]);
                    const numbersInRange = usedNumbers.filter(n => n >= rangeStart && n <= rangeEnd);
                    suggested = rangeStart;
                    for (const num of numbersInRange) {
                        if (num === suggested) {
                            suggested++;
                        } else if (num > suggested) {
                            break;
                        }
                    }
                    range = `${rangeStart}-${rangeEnd}`;
                }

                // Detect range if not already set
                if (!range) {
                    const rangeNum = Math.ceil(suggested / 1000);
                    const rangeStart = (rangeNum - 1) * 1000 + 1;
                    const rangeEnd = rangeNum * 1000;
                    range = `${rangeStart}-${rangeEnd}`;
                }

                document.getElementById('createChannelNumber').value = suggested;
                document.getElementById('channelNumberSuggestion').textContent = `Suggested: ${suggested} (Range: ${range})`;
            } catch (error) {
                console.error('Error suggesting channel number:', error);
            }
        }

        async function openRangeSelector() {
            // Check if Smart Ranges are defined
            if (!customRangesData || customRangesData.length === 0) {
                // No Smart Ranges - direct user to settings
                const container = document.getElementById('suggestedRangesList');
                container.innerHTML = `
                    <div style="text-align: center; padding: 30px;">
                        <div style="font-size: 2rem; margin-bottom: 15px;">üìä</div>
                        <div style="font-size: 1.1rem; margin-bottom: 10px; color: #ffd43b;">No Smart Ranges Defined</div>
                        <div style="color: #999; font-size: 0.9rem; margin-bottom: 20px;">
                            Smart Ranges allow you to organize channels by number ranges with automatic group assignment.
                        </div>
                        <button onclick="closeRangeSelector(); showTab('settings')" class="btn-primary">
                            Go to Settings to Create Ranges
                        </button>
                    </div>
                `;
                document.getElementById('rangeSelectorModal').style.display = 'flex';
                return;
            }

            // Ensure channels are loaded
            await ensureChannelsLoaded();

            // Use Smart Ranges from settings
            const container = document.getElementById('suggestedRangesList');
            container.innerHTML = customRangesData.map(range => {
                // Count how many channels are in this range
                let count = 0;
                const rangeSize = range.end - range.start + 1;
                if (dispatcharrChannels && dispatcharrChannels.length > 0) {
                    count = dispatcharrChannels.filter(ch => {
                        const num = parseFloat(ch.channel_number);
                        return !isNaN(num) && num >= range.start && num <= range.end;
                    }).length;
                }

                const usagePercent = (count / rangeSize * 100).toFixed(1);
                const usageColor = count === 0 ? '#51cf66' : count < rangeSize / 2 ? '#ffd43b' : '#ff6b6b';
                const groupName = range.groupId ? (dispatcharrGroups.find(g => g.id == range.groupId)?.name || 'Unknown Group') : 'No Group';

                return `
                    <div onclick="applyRange(${range.start}, ${range.end}, ${range.groupId || 'null'})"
                         style="background: rgba(255,255,255,0.05); padding: 15px; border-radius: 6px; border: 1px solid rgba(255,255,255,0.1); cursor: pointer; transition: all 0.2s;"
                         onmouseover="this.style.background='rgba(102, 126, 234, 0.2)'; this.style.borderColor='#667eea';"
                         onmouseout="this.style.background='rgba(255,255,255,0.05)'; this.style.borderColor='rgba(255,255,255,0.1)';">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                            <div>
                                <div style="font-weight: bold; font-size: 1.1rem;">${escapeHtml(range.name)}</div>
                                <div style="color: #999; font-size: 0.85rem; margin-top: 2px;">${range.start} - ${range.end}</div>
                            </div>
                            <span style="color: ${usageColor}; font-weight: bold;">${count} used</span>
                        </div>
                        <div style="background: rgba(0,0,0,0.3); height: 6px; border-radius: 3px; overflow: hidden;">
                            <div style="background: ${usageColor}; height: 100%; width: ${usagePercent}%;"></div>
                        </div>
                        <div style="display: flex; justify-content: space-between; font-size: 0.8rem; color: #999; margin-top: 5px;">
                            <span>${count === 0 ? 'Empty range' : `${(rangeSize - count)} available`}</span>
                            <span style="color: #667eea;">‚Üí ${escapeHtml(groupName)}</span>
                        </div>
                    </div>
                `;
            }).join('');

            // Show modal
            document.getElementById('rangeSelectorModal').style.display = 'flex';
        }

        function closeRangeSelector() {
            document.getElementById('rangeSelectorModal').style.display = 'none';
            document.getElementById('customRangeStart').value = '';
            document.getElementById('customRangeEnd').value = '';
            document.getElementById('customRangeStatus').textContent = '';
        }

        async function applyRange(start, end, groupId) {
            // Use the range mode in suggestChannelNumber
            await suggestChannelNumber(`range-${start}-${end}`);

            // Auto-assign the group if provided
            if (groupId) {
                const groupSelect = document.getElementById('createChannelGroup');
                const option = Array.from(groupSelect.options).find(opt => opt.value == groupId);
                if (option) {
                    option.selected = true;
                    showNotification(`Group auto-assigned based on range`, 'info');
                }
            }

            closeRangeSelector();
        }

        async function applyCustomRange() {
            const start = parseInt(document.getElementById('customRangeStart').value);
            const end = parseInt(document.getElementById('customRangeEnd').value);
            const statusDiv = document.getElementById('customRangeStatus');

            if (!start || !end) {
                statusDiv.textContent = '‚ö†Ô∏è Please enter both start and end numbers';
                statusDiv.style.color = '#ff6b6b';
                return;
            }

            if (start >= end) {
                statusDiv.textContent = '‚ö†Ô∏è Start must be less than end';
                statusDiv.style.color = '#ff6b6b';
                return;
            }

            if (start < 1) {
                statusDiv.textContent = '‚ö†Ô∏è Start must be at least 1';
                statusDiv.style.color = '#ff6b6b';
                return;
            }

            // Apply the one-time range
            await applyRange(start, end);
        }

        // ========== CHANNEL SHIFT FUNCTIONALITY ==========

        // Global state for shift operations
        let shiftPlanData = null;
        let shiftCancelled = false;
        let pendingChannelData = null; // Store channel data for creation after shift
        let hiddenEditModal = null; // Store reference to temporarily hidden edit modal

        /**
         * Plans a channel shift operation and shows preview modal
         * @param {number} insertAt - Channel number to insert at
         * @param {number} shiftAmount - Amount to shift by (default 1)
         * @param {number} excludeChannelId - Optional channel ID to exclude from shift (for edit mode)
         * @returns {Promise<Object>} Shift plan data
         */
        async function planChannelShift(insertAt, shiftAmount = 1, excludeChannelId = null) {
            await ensureChannelsLoaded();

            const plan = {
                insertNumber: parseFloat(insertAt),
                shiftAmount: shiftAmount,
                affectedChannels: [],
                warnings: [],
                estimatedTime: 0,
                gapAt: null,
                excludedChannelId: excludeChannelId
            };

            // Get all channels >= insertAt (including decimals)
            // EXCLUDE the source channel if this is an edit operation
            const candidateChannels = dispatcharrChannels
                .filter(ch => {
                    const num = parseFloat(ch.channel_number);
                    // Exclude the channel being edited (it's being moved, not shifted)
                    if (excludeChannelId && ch.id === excludeChannelId) {
                        return false;
                    }
                    return !isNaN(num) && num >= plan.insertNumber;
                })
                .sort((a, b) => parseFloat(a.channel_number) - parseFloat(b.channel_number));

            // Find where to stop (first gap)
            plan.gapAt = findShiftStopPoint(candidateChannels, plan.insertNumber, plan.shiftAmount);

            // Filter channels up to gap
            plan.affectedChannels = candidateChannels.filter(ch =>
                parseFloat(ch.channel_number) < plan.gapAt
            );

            // Validate Smart Range boundaries (warning mode - allow but warn)
            plan.warnings = validateSmartRangeBoundaries(plan.affectedChannels, plan.shiftAmount);

            // Estimate time (roughly 150ms per channel)
            plan.estimatedTime = plan.affectedChannels.length * 0.15;

            return plan;
        }

        /**
         * Finds the point where shifting should stop (first gap)
         * @param {Array} channels - Sorted channels in ascending order
         * @param {number} insertAt - Starting point
         * @param {number} shiftAmount - Shift amount
         * @returns {number} Channel number where gap occurs
         */
        function findShiftStopPoint(channels, insertAt, shiftAmount) {
            let expected = parseFloat(insertAt);

            for (const ch of channels) {
                const num = parseFloat(ch.channel_number);

                // If there's a gap (channel number > expected), return the gap position
                if (num > expected) {
                    return expected;
                }

                // Move expected to next position after this channel
                expected = num + shiftAmount;
            }

            // No gap found - return Infinity to shift all
            return Infinity;
        }

        /**
         * Validates Smart Range boundaries and generates warnings
         * @param {Array} channels - Channels to be shifted
         * @param {number} shiftAmount - Shift amount
         * @returns {Array} Array of warning objects
         */
        function validateSmartRangeBoundaries(channels, shiftAmount) {
            const warnings = [];

            if (!customRangesData || customRangesData.length === 0) {
                return warnings;
            }

            for (const ch of channels) {
                const currentNum = parseFloat(ch.channel_number);
                const newNum = currentNum + shiftAmount;

                // Find Smart Range for this channel's current position
                const range = customRangesData.find(r =>
                    currentNum >= r.start && currentNum <= r.end
                );

                if (range && newNum > range.end) {
                    warnings.push({
                        type: 'range_overflow',
                        channel: ch,
                        range: range,
                        currentNumber: currentNum,
                        newNumber: newNum,
                        message: `${ch.name} (${currentNum}) will exceed ${range.name} range boundary (${range.end}) ‚Üí becomes ${newNum}`
                    });
                }
            }

            return warnings;
        }

        /**
         * Shows the shift preview modal with plan data
         * @param {Object} plan - Shift plan data
         */
        function showShiftPreviewModal(plan) {
            shiftPlanData = plan;

            // Hide any open edit modal temporarily (so shift preview is visible)
            const editModals = document.querySelectorAll('.modal');
            for (const modal of editModals) {
                if (modal.id !== 'shiftPreviewModal' && modal.id !== 'shiftProgressModal' && modal.style.display !== 'none') {
                    hiddenEditModal = modal;
                    modal.style.display = 'none';
                    break;
                }
            }

            // Populate summary
            document.getElementById('previewInsertAt').textContent = plan.insertNumber;
            document.getElementById('previewShiftAmount').textContent = `+${plan.shiftAmount}`;
            document.getElementById('previewCount').textContent = `${plan.affectedChannels.length} channel(s)`;
            document.getElementById('previewGapAt').textContent = plan.gapAt === Infinity ? 'No gap found (shift all)' : plan.gapAt;
            document.getElementById('previewTime').textContent = `~${plan.estimatedTime.toFixed(1)}s`;

            // Show warnings
            const warningsDiv = document.getElementById('previewWarnings');
            if (plan.warnings.length > 0) {
                warningsDiv.innerHTML = `
                    <div style="background: rgba(255, 107, 107, 0.1); border: 1px solid #ff6b6b; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                        <h3 style="margin-top: 0; color: #ff6b6b;">‚ö†Ô∏è Warnings (${plan.warnings.length})</h3>
                        <ul style="margin: 0; padding-left: 20px;">
                            ${plan.warnings.map(w => `<li style="margin: 5px 0;">${w.message}</li>`).join('')}
                        </ul>
                        <p style="margin: 10px 0 0 0; font-size: 0.9rem; color: #999;">
                            These channels will be shifted beyond their Smart Range boundaries. You can still proceed if desired.
                        </p>
                    </div>
                `;
            } else {
                warningsDiv.innerHTML = '';
            }

            // Populate changes table
            const tbody = document.getElementById('previewTableBody');
            tbody.innerHTML = plan.affectedChannels.map(ch => {
                const currentNum = parseFloat(ch.channel_number);
                const newNum = currentNum + plan.shiftAmount;
                const hasWarning = plan.warnings.some(w => w.channel.id === ch.id);

                return `
                    <tr style="border-bottom: 1px solid rgba(255,255,255,0.05); ${hasWarning ? 'background: rgba(255, 107, 107, 0.05);' : ''}">
                        <td style="padding: 8px;">${ch.name}${hasWarning ? ' ‚ö†Ô∏è' : ''}</td>
                        <td style="padding: 8px; text-align: center;">${currentNum}</td>
                        <td style="padding: 8px; text-align: center;">‚Üí</td>
                        <td style="padding: 8px; text-align: center; font-weight: bold; color: #667eea;">${newNum}</td>
                        <td style="padding: 8px;">${ch.group_name || '(None)'}</td>
                    </tr>
                `;
            }).join('');

            // Show modal
            document.getElementById('shiftPreviewModal').style.display = 'flex';
        }

        async function closeShiftPreviewModal() {
            document.getElementById('shiftPreviewModal').style.display = 'none';

            // Restore hidden edit modal if it exists
            if (hiddenEditModal) {
                // Reload channels and refresh the edit modal data before showing it
                await loadDispatcharrChannels();
                refreshEditModalData();
                hiddenEditModal.style.display = 'flex';
                hiddenEditModal = null;
            }

            shiftPlanData = null;
        }

        /**
         * Refreshes the data in the currently hidden edit modal with latest channel info
         */
        function refreshEditModalData() {
            if (!hiddenEditModal || !pendingChannelData || !pendingChannelData.isEdit) {
                return;
            }

            // Find the channel with latest data
            const channelId = pendingChannelData.channelId;
            const channel = dispatcharrChannels.find(ch => ch.id === channelId);

            if (!channel) {
                return; // Channel not found
            }

            // Update all input fields in the edit modal with current values
            const nameInput = hiddenEditModal.querySelector('#editChannelName');
            const callSignInput = hiddenEditModal.querySelector('#editChannelCallSign');
            const gracenoteInput = hiddenEditModal.querySelector('#editChannelGracenoteId');
            const numberInput = hiddenEditModal.querySelector('#editChannelNumber');

            if (nameInput) nameInput.value = channel.name || '';
            if (callSignInput) callSignInput.value = channel.call_sign || '';
            if (gracenoteInput) gracenoteInput.value = channel.gracenote_id || '';
            if (numberInput) numberInput.value = channel.channel_number || '';
        }

        /**
         * Confirms and executes the channel shift
         */
        async function confirmChannelShift() {
            if (!shiftPlanData) {
                showNotification('No shift plan available', 'error');
                return;
            }

            closeShiftPreviewModal();

            // Execute shift
            const result = await executeChannelShift(shiftPlanData);

            if (result.cancelled) {
                showNotification('Shift operation cancelled', 'info');

                // Restore edit modal if it was hidden (refresh data first)
                if (hiddenEditModal) {
                    await loadDispatcharrChannels(); // Reload to get latest state
                    refreshEditModalData(); // Update modal with latest data
                    hiddenEditModal.style.display = 'flex';
                    hiddenEditModal = null;
                }

                pendingChannelData = null;
                return result;
            }

            if (!result.success) {
                showNotification(
                    `Shift failed: ${result.successCount} succeeded, ${result.errorCount} failed. Rolled back.`,
                    'error'
                );

                // Restore edit modal if it was hidden (refresh data first after rollback)
                if (hiddenEditModal) {
                    await loadDispatcharrChannels(); // Reload to get post-rollback state
                    refreshEditModalData(); // Update modal with latest data
                    hiddenEditModal.style.display = 'flex';
                    hiddenEditModal = null;
                }

                pendingChannelData = null;
                return result;
            }

            // Shift successful!
            // Don't show notification yet if we have pending operations (create/edit)
            const hasPendingOp = !!pendingChannelData;
            if (!hasPendingOp) {
                showNotification(`‚úì Successfully shifted ${result.successCount} channel(s)`, 'success');
            }

            // If there's pending channel data, handle it
            if (pendingChannelData) {
                if (pendingChannelData.isEdit) {
                    // Edit flow - update the channel (will show its own notification)
                    await updateChannelAfterShift(pendingChannelData);
                } else {
                    // Create flow - create the channel (will show combined notification)
                    await createChannelAfterShift(pendingChannelData);
                }
                pendingChannelData = null;
            }

            // ALWAYS do a full reload after shift operations to reflect all changes
            await loadDispatcharrChannels();

            return result;
        }

        /**
         * Updates a channel after successful shift (used in edit insert-and-shift flow)
         * @param {Object} editInfo - Stored edit info from edit modal
         */
        async function updateChannelAfterShift(editInfo) {
            const settings = await getSettings();

            try {
                showNotification('Updating channel...', 'info');

                const response = await fetch(`/api/dispatcharr/channels/${editInfo.channelId}`, {
                    method: 'PATCH',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        url: settings.dispatcharr.url,
                        username: settings.dispatcharr.username,
                        password: settings.dispatcharr.password,
                        update_data: editInfo.updateData
                    })
                });

                const result = await response.json();

                if (result.success) {
                    // Get channel name for notification
                    const channelName = editInfo.updateData.name || 'Channel';
                    const channelNumber = editInfo.updateData.channel_number;
                    showNotification(`‚úì ${channelName} moved to ${channelNumber} successfully!`, 'success');

                    // Update local channel data
                    const channelIndex = dispatcharrChannels.findIndex(ch => ch.id == editInfo.channelId);
                    if (channelIndex !== -1 && result.channel) {
                        dispatcharrChannels[channelIndex] = result.channel;
                        hasIncrementalUpdates = true;
                    }

                    // Close and remove the hidden edit modal permanently
                    if (hiddenEditModal) {
                        hiddenEditModal.remove();
                        hiddenEditModal = null;
                    }

                    // Also close any other modals
                    const modal = document.querySelector('.modal');
                    if (modal) modal.remove();
                } else {
                    showNotification('Failed to update channel: ' + (result.error || 'Unknown error'), 'error');

                    // On error, restore the edit modal so user can try again
                    if (hiddenEditModal) {
                        await loadDispatcharrChannels(); // Reload to get latest state
                        refreshEditModalData(); // Update modal with latest data
                        hiddenEditModal.style.display = 'flex';
                        hiddenEditModal = null;
                    }
                }
            } catch (error) {
                showNotification('Error updating channel: ' + error.message, 'error');
                console.error(error);

                // On error, restore the edit modal so user can try again
                if (hiddenEditModal) {
                    await loadDispatcharrChannels(); // Reload to get latest state
                    refreshEditModalData(); // Update modal with latest data
                    hiddenEditModal.style.display = 'flex';
                    hiddenEditModal = null;
                }
            }
        }

        /**
         * Creates a channel after successful shift (used in create insert-and-shift flow)
         * @param {Object} channelInfo - Stored channel info from creation modal
         */
        async function createChannelAfterShift(channelInfo) {
            const settings = await getSettings();

            try {
                const channelData = {
                    name: channelInfo.name,
                    channel_number: channelInfo.channelNumber,
                    tvc_guide_stationid: channelInfo.gracenoteId || '',
                    tvg_id: channelInfo.tvgId || '',
                    channel_group_id: channelInfo.groupId ? parseInt(channelInfo.groupId) : null,
                    streams: createChannelStreams.map(s => s.id)
                };

                // Add logo if available from station data
                if (createChannelStationData && createChannelStationData.logo_uri) {
                    channelData.logo_uri = createChannelStationData.logo_uri;
                }

                showNotification('Creating channel...', 'info');

                const response = await fetch('/api/dispatcharr/channels/create', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        url: settings.dispatcharr.url,
                        username: settings.dispatcharr.username,
                        password: settings.dispatcharr.password,
                        channel: channelData
                    })
                });

                const data = await response.json();

                if (data.success) {
                    // Show success notification (combine shift + creation success)
                    showNotification(`‚úì Channel "${channelInfo.name}" created successfully at ${channelInfo.channelNumber}!`, 'success');

                    // Close the hidden create modal permanently
                    if (hiddenEditModal && hiddenEditModal.id === 'createChannelModal') {
                        hiddenEditModal.remove();
                        hiddenEditModal = null;
                    } else {
                        // Fallback: close via normal method
                        closeCreateChannelModal();
                    }
                } else {
                    showNotification(`Failed to create channel: ${data.error}`, 'error');

                    // On error, restore the create modal so user can try again
                    if (hiddenEditModal && hiddenEditModal.id === 'createChannelModal') {
                        await loadDispatcharrChannels(); // Reload to get latest state
                        hiddenEditModal.style.display = 'flex';
                        hiddenEditModal = null;
                    }
                }
            } catch (error) {
                showNotification('Error creating channel: ' + error.message, 'error');
                console.error(error);

                // On error, restore the create modal so user can try again
                if (hiddenEditModal && hiddenEditModal.id === 'createChannelModal') {
                    await loadDispatcharrChannels(); // Reload to get latest state
                    hiddenEditModal.style.display = 'flex';
                    hiddenEditModal = null;
                }
            }
        }

        /**
         * Executes the channel shift (processes HIGHEST TO LOWEST to avoid collisions!)
         * @param {Object} plan - Shift plan data
         * @returns {Promise<Object>} Execution result
         */
        async function executeChannelShift(plan) {
            const settings = await getSettings();
            if (!settings.dispatcharr || !settings.dispatcharr.url) {
                showNotification('Please configure Dispatcharr settings first', 'error');
                return { success: false, error: 'No Dispatcharr settings' };
            }

            // Sort HIGHEST TO LOWEST (reverse order) to avoid collisions!
            const channelsToShift = [...plan.affectedChannels].sort((a, b) =>
                parseFloat(b.channel_number) - parseFloat(a.channel_number)
            );

            let successCount = 0;
            let errorCount = 0;
            const errors = [];
            const originalNumbers = new Map();

            // Show progress modal
            shiftCancelled = false;
            document.getElementById('shiftProgressModal').style.display = 'flex';
            document.getElementById('shiftCancelButton').disabled = false;
            document.getElementById('shiftCancelButton').textContent = 'Cancel';

            // Process each channel (highest to lowest!)
            for (let i = 0; i < channelsToShift.length; i++) {
                // Check if cancelled
                if (shiftCancelled) {
                    // Attempt rollback
                    await rollbackChannelShift(originalNumbers);
                    document.getElementById('shiftProgressModal').style.display = 'none';
                    return { success: false, cancelled: true, successCount, errorCount };
                }

                const channel = channelsToShift[i];
                const currentNum = parseFloat(channel.channel_number);
                const newNum = currentNum + plan.shiftAmount;

                // Store original number for potential rollback
                originalNumbers.set(channel.id, currentNum);

                // Update progress
                updateShiftProgress(i + 1, channelsToShift.length, `Shifting ${channel.name}...`);

                try {
                    const response = await fetch(`/api/dispatcharr/channels/${channel.id}`, {
                        method: 'PATCH',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            url: settings.dispatcharr.url,
                            username: settings.dispatcharr.username,
                            password: settings.dispatcharr.password,
                            update_data: { channel_number: newNum }
                        })
                    });

                    const data = await response.json();

                    if (data.success) {
                        successCount++;
                    } else {
                        errorCount++;
                        errors.push({ channel, error: data.error || 'Unknown error' });

                        // Rollback on error
                        await rollbackChannelShift(originalNumbers);
                        document.getElementById('shiftProgressModal').style.display = 'none';
                        showNotification(`Shift failed at ${channel.name}. Rolling back changes...`, 'error');
                        return { success: false, successCount, errorCount, errors };
                    }
                } catch (error) {
                    errorCount++;
                    errors.push({ channel, error: error.message });

                    // Rollback on error
                    await rollbackChannelShift(originalNumbers);
                    document.getElementById('shiftProgressModal').style.display = 'none';
                    showNotification(`Shift failed at ${channel.name}. Rolling back changes...`, 'error');
                    return { success: false, successCount, errorCount, errors };
                }
            }

            // Hide progress modal
            document.getElementById('shiftProgressModal').style.display = 'none';

            return {
                success: errorCount === 0,
                successCount,
                errorCount,
                errors,
                cancelled: false
            };
        }

        /**
         * Rolls back shifted channels to original numbers
         * @param {Map} originalNumbers - Map of channel ID to original number
         */
        async function rollbackChannelShift(originalNumbers) {
            if (originalNumbers.size === 0) return;

            const settings = await getSettings();
            showNotification('Rolling back changes...', 'info');

            let rollbackCount = 0;
            for (const [channelId, originalNumber] of originalNumbers) {
                try {
                    await fetch(`/api/dispatcharr/channels/${channelId}`, {
                        method: 'PATCH',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            url: settings.dispatcharr.url,
                            username: settings.dispatcharr.username,
                            password: settings.dispatcharr.password,
                            update_data: { channel_number: originalNumber }
                        })
                    });
                    rollbackCount++;
                } catch (error) {
                    console.error(`Failed to rollback channel ${channelId}:`, error);
                }
            }

            showNotification(`Rolled back ${rollbackCount} channel(s)`, 'info');
        }

        /**
         * Updates the shift progress UI
         * @param {number} current - Current progress
         * @param {number} total - Total count
         * @param {string} status - Status message
         */
        function updateShiftProgress(current, total, status = '') {
            const percentage = (current / total) * 100;

            document.getElementById('shiftProgressText').textContent = `Processing ${current}/${total} channels...`;
            document.getElementById('shiftProgressFill').style.width = `${percentage}%`;
            document.getElementById('shiftProgressStatus').textContent = status;
        }

        /**
         * Cancels an in-progress shift operation
         */
        function cancelShiftInProgress() {
            shiftCancelled = true;
            document.getElementById('shiftCancelButton').disabled = true;
            document.getElementById('shiftCancelButton').textContent = 'Cancelling...';
            document.getElementById('shiftProgressStatus').textContent = 'Cancelling and rolling back...';
        }

        // ========== END CHANNEL SHIFT FUNCTIONALITY ==========

        async function submitCreateChannel() {
            const name = document.getElementById('createChannelName').value.trim();
            const channelNumber = document.getElementById('createChannelNumber').value;
            const groupId = document.getElementById('createChannelGroup').value;
            const gracenoteId = document.getElementById('createChannelGracenoteId').value;
            const tvgId = document.getElementById('createChannelTvgId').value.trim();

            if (!name) {
                showNotification('Channel name is required', 'error');
                return;
            }

            const settings = await getSettings();
            if (!settings.dispatcharr || !settings.dispatcharr.url) {
                showNotification('Please configure Dispatcharr settings first', 'error');
                return;
            }

            // INTELLIGENT SHIFT DETECTION: Check if the channel number is already taken
            if (channelNumber) {
                const parsedNumber = parseFloat(channelNumber);
                await ensureChannelsLoaded();

                // Check if this channel number is occupied
                const isOccupied = dispatcharrChannels.some(ch => {
                    const existingNum = parseFloat(ch.channel_number);
                    return !isNaN(existingNum) && existingNum === parsedNumber;
                });

                if (isOccupied) {
                    // Number is taken - automatically plan a shift
                    const plan = await planChannelShift(parsedNumber, 1);

                    if (plan.affectedChannels.length > 0) {
                        // Show preview modal with option to shift
                        showShiftPreviewModal(plan);

                        // Store channel data for creation after shift
                        pendingChannelData = {
                            name,
                            channelNumber: parsedNumber,
                            groupId,
                            gracenoteId,
                            tvgId
                        };

                        // Exit here - creation will happen after user confirms shift
                        return;
                    }
                    // If no channels to shift (shouldn't happen), fall through to normal creation
                }
            }

            try {
                // Create channel payload
                const channelData = {
                    name: name,
                    channel_number: channelNumber ? parseFloat(channelNumber) : null,
                    tvc_guide_stationid: gracenoteId || '',
                    tvg_id: tvgId || '',
                    channel_group_id: groupId ? parseInt(groupId) : null,
                    streams: createChannelStreams.map(s => s.id)
                };

                // Add logo if available from station data
                if (createChannelStationData && createChannelStationData.logo_uri) {
                    channelData.logo_uri = createChannelStationData.logo_uri;
                    console.log('[Create Channel] Adding logo_uri to channel data:', channelData.logo_uri);
                } else {
                    console.log('[Create Channel] No logo_uri in station data. createChannelStationData:', createChannelStationData);
                }

                showNotification('Creating channel...', 'info');

                const response = await fetch('/api/dispatcharr/channels/create', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        url: settings.dispatcharr.url,
                        username: settings.dispatcharr.username,
                        password: settings.dispatcharr.password,
                        channel: channelData
                    })
                });

                const data = await response.json();

                if (data.success) {
                    // Show logo status message first if present
                    if (data.logo_message) {
                        showNotification(data.logo_message, 'info');
                    }

                    // Then show success message (delayed slightly so logo message appears first)
                    setTimeout(() => {
                        showNotification('Channel created successfully!', 'success');
                    }, 300);

                    closeCreateChannelModal();

                    // Refresh Dispatcharr channels if on that tab
                    if (document.getElementById('dispatcharrTab').classList.contains('active')) {
                        loadDispatcharrChannels();
                    }
                } else {
                    showNotification(`Failed to create channel: ${data.error}`, 'error');
                }
            } catch (error) {
                showNotification('Error creating channel', 'error');
                console.error(error);
            }
        }

        // Stream search for Create Channel modal
        async function searchStreamsInCreate(searchMode) {
            const resultsContainer = document.getElementById('createChannelStreamSearchResults');
            const channelName = document.getElementById('createChannelName').value.trim();

            let searchTerm;
            if (searchMode === 'auto') {
                // Auto mode: use channel name
                if (!channelName) {
                    resultsContainer.innerHTML = '<div style="text-align: center; color: #ff6b6b; padding: 10px;">Please enter a channel name first</div>';
                    return;
                }
                searchTerm = channelName;
            } else {
                // Manual mode: use search input
                searchTerm = document.getElementById('createChannelStreamSearch').value.trim();
                if (!searchTerm) {
                    resultsContainer.innerHTML = '<div style="text-align: center; color: #ff6b6b; padding: 10px;">Please enter a search term</div>';
                    return;
                }
            }

            resultsContainer.innerHTML = '<div style="text-align: center; color: #999; padding: 20px;">Searching...</div>';

            const settings = await getSettings();
            if (!settings.dispatcharr || !settings.dispatcharr.url) {
                resultsContainer.innerHTML = '<div style="text-align: center; color: #ff6b6b; padding: 10px;">Please configure Dispatcharr settings first</div>';
                return;
            }

            // Get max results from settings
            const maxResults = (settings.streamManagement && settings.streamManagement.maxResults) || 10;

            // Get playlist priority from settings
            const preferredPlaylists = (settings.streamManagement && settings.streamManagement.playlistPriority) || [];

            try {
                // Use a temporary channel ID for search (we'll use 0 since we're creating a new channel)
                const response = await fetch(`/api/dispatcharr/streams/search`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        url: settings.dispatcharr.url,
                        username: settings.dispatcharr.username,
                        password: settings.dispatcharr.password,
                        channel_name: searchTerm,
                        preferred_playlists: preferredPlaylists,
                        max_results: maxResults,
                        search_mode: searchMode
                    })
                });

                const data = await response.json();

                if (!data.success) {
                    resultsContainer.innerHTML = `<div style="text-align: center; color: #ff6b6b; padding: 10px;">Error: ${data.error || 'Search failed'}</div>`;
                    return;
                }

                const results = data.results || [];

                if (results.length === 0) {
                    resultsContainer.innerHTML = '<div style="text-align: center; color: #666; padding: 10px;">No matching streams found</div>';
                    return;
                }

                // Ensure M3U accounts are loaded
                if (!cachedM3UAccounts) {
                    await loadM3UAccounts();
                }

                // Filter out already added streams
                const currentStreamIds = new Set(createChannelStreams.map(s => s.id));
                const availableResults = results.filter(r => !currentStreamIds.has(r.stream.id));

                if (availableResults.length === 0) {
                    resultsContainer.innerHTML = '<div style="text-align: center; color: #666; padding: 10px;">All matching streams are already added</div>';
                    return;
                }

                resultsContainer.innerHTML = `
                    <div style="margin-bottom: 10px; color: #999; font-size: 0.85rem; padding: 5px;">
                        Found ${availableResults.length} matching stream${availableResults.length > 1 ? 's' : ''}
                        ${data.strategy ? `<span style="color: #666;"> (${data.strategy})</span>` : ''}
                    </div>
                    ${availableResults.slice(0, 20).map(result => {
                        const stream = result.stream;
                        const playlist = cachedM3UAccounts ? cachedM3UAccounts[stream.m3u_account] || `Account ${stream.m3u_account}` : `Account ${stream.m3u_account}`;

                        // Confidence badge
                        const confidence = result.relevance;
                        let confidenceBadge = '';
                        let confidenceColor = '';
                        if (confidence >= 0.95) {
                            confidenceBadge = 'Excellent';
                            confidenceColor = '#51cf66';
                        } else if (confidence >= 0.85) {
                            confidenceBadge = 'Very Good';
                            confidenceColor = '#94d82d';
                        } else if (confidence >= 0.80) {
                            confidenceBadge = 'Good';
                            confidenceColor = '#ffd43b';
                        } else if (confidence >= 0.70) {
                            confidenceBadge = 'Fair';
                            confidenceColor = '#ff922b';
                        } else {
                            confidenceBadge = 'Low';
                            confidenceColor = '#ff6b6b';
                        }

                        return `
                            <div style="background: rgba(255,255,255,0.03); padding: 10px; margin-bottom: 6px; border-radius: 4px; border: 1px solid rgba(255,255,255,0.08); font-size: 0.9rem;">
                                <div style="display: flex; justify-content: space-between; align-items: start;">
                                    <div style="flex: 1; min-width: 0;">
                                        <div style="display: flex; align-items: center; gap: 6px; margin-bottom: 4px; flex-wrap: wrap;">
                                            <span style="background: rgba(51, 204, 255, 0.2); color: #33ccff; padding: 2px 6px; border-radius: 3px; font-size: 0.75rem;">
                                                ${escapeHtml(playlist)}
                                            </span>
                                            <span style="background: rgba(${confidenceColor.replace('#', '')}, 0.2); color: ${confidenceColor}; padding: 2px 6px; border-radius: 3px; font-size: 0.75rem;">
                                                ${confidenceBadge} (${(confidence * 100).toFixed(0)}%)
                                            </span>
                                        </div>
                                        <div style="font-weight: 500; margin-bottom: 2px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${escapeHtml(stream.name)}</div>
                                    </div>
                                    <button onclick="addStreamToCreateChannel(${stream.id}, '${escapeHtml(stream.name).replace(/'/g, "\\'")}', ${stream.m3u_account}, '${escapeHtml(stream.url || '').replace(/'/g, "\\'")}', ${stream.channel_group || 'null'})"
                                        style="padding: 4px 10px; font-size: 11px; margin-left: 8px; white-space: nowrap;">
                                        ‚ûï Add
                                    </button>
                                </div>
                            </div>
                        `;
                    }).join('')}
                    ${availableResults.length > 20 ? `<div style="text-align: center; color: #666; margin-top: 8px; font-size: 0.85rem;">Showing top 20 of ${availableResults.length} results</div>` : ''}
                `;

            } catch (error) {
                console.error('Stream search error:', error);
                resultsContainer.innerHTML = `<div style="text-align: center; color: #ff6b6b; padding: 10px;">Error: ${error.message}</div>`;
            }
        }

        function addStreamToCreateChannel(streamId, streamName, m3uAccount, streamUrl, channelGroup) {
            // Check if already added
            if (createChannelStreams.find(s => s.id === streamId)) {
                showNotification('Stream already added', 'warning');
                return;
            }

            // Add to create channel streams
            createChannelStreams.push({
                id: streamId,
                name: streamName,
                m3u_account: m3uAccount,
                url: streamUrl,
                channel_group: channelGroup
            });

            // Re-render assigned streams
            renderCreateChannelAssignedStreams();

            // Re-run search to update available streams (optional, could be removed for performance)
            // searchStreamsInCreate will be called again if user wants to add more

            showNotification('Stream added', 'success');
        }

        function removeStreamFromCreateChannel(streamId) {
            createChannelStreams = createChannelStreams.filter(s => s.id !== streamId);
            renderCreateChannelAssignedStreams();
            showNotification('Stream removed', 'success');
        }

        function renderCreateChannelAssignedStreams() {
            const container = document.getElementById('createChannelStreamsList');

            if (createChannelStreams.length === 0) {
                container.innerHTML = '<div style="text-align: center; color: #666;">No streams assigned</div>';
                return;
            }

            container.innerHTML = createChannelStreams.map((stream, index) => {
                const playlist = cachedM3UAccounts ? cachedM3UAccounts[stream.m3u_account] || `Account ${stream.m3u_account}` : `Account ${stream.m3u_account}`;

                return `
                    <div class="create-stream-item" draggable="true" data-stream-id="${stream.id}" data-index="${index}"
                        style="background: rgba(255,255,255,0.05); padding: 10px; margin-bottom: 6px; border-radius: 4px; border: 1px solid rgba(255,255,255,0.1); cursor: move; display: flex; justify-content: space-between; align-items: center;"
                        ondragstart="handleCreateStreamDragStart(event)" ondragover="handleCreateStreamDragOver(event)"
                        ondrop="handleCreateStreamDrop(event)" ondragend="handleCreateStreamDragEnd(event)">
                        <div style="flex: 1; min-width: 0; display: flex; align-items: center; gap: 10px;">
                            <span style="color: #999; font-size: 0.9rem;">‚ãÆ‚ãÆ</span>
                            <div style="flex: 1; min-width: 0;">
                                <div style="display: flex; align-items: center; gap: 6px; margin-bottom: 3px;">
                                    <span style="font-size: 0.75rem; color: #33ccff;">${escapeHtml(playlist)}</span>
                                    <span style="color: #999; font-size: 0.75rem;">#${index + 1}</span>
                                </div>
                                <div style="font-weight: 500; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${escapeHtml(stream.name)}</div>
                            </div>
                        </div>
                        <button onclick="event.stopPropagation(); removeStreamFromCreateChannel(${stream.id})" style="padding: 4px 8px; font-size: 11px; background: #ff6b6b; border-color: #ff6b6b; margin-left: 10px;">
                            üóëÔ∏è Remove
                        </button>
                    </div>
                `;
            }).join('');
        }

        // Drag and drop handlers for Create Channel streams
        let draggedCreateStreamElement = null;
        let draggedCreateStreamIndex = null;

        function handleCreateStreamDragStart(e) {
            draggedCreateStreamElement = e.target.closest('.create-stream-item');
            draggedCreateStreamIndex = parseInt(draggedCreateStreamElement.dataset.index);
            e.dataTransfer.effectAllowed = 'move';
            draggedCreateStreamElement.style.opacity = '0.4';
        }

        function handleCreateStreamDragOver(e) {
            if (e.preventDefault) {
                e.preventDefault();
            }
            e.dataTransfer.dropEffect = 'move';

            const targetElement = e.target.closest('.create-stream-item');
            if (targetElement && targetElement !== draggedCreateStreamElement) {
                targetElement.style.borderTop = '3px solid #33ccff';
            }
            return false;
        }

        function handleCreateStreamDrop(e) {
            if (e.stopPropagation) {
                e.stopPropagation();
            }

            const targetElement = e.target.closest('.create-stream-item');
            if (targetElement && draggedCreateStreamElement && targetElement !== draggedCreateStreamElement) {
                const targetIndex = parseInt(targetElement.dataset.index);

                // Reorder the array
                const [movedStream] = createChannelStreams.splice(draggedCreateStreamIndex, 1);
                createChannelStreams.splice(targetIndex, 0, movedStream);

                // Re-render
                renderCreateChannelAssignedStreams();
            }

            // Clear border highlight
            document.querySelectorAll('.create-stream-item').forEach(item => {
                item.style.borderTop = '';
            });

            return false;
        }

        function handleCreateStreamDragEnd(e) {
            if (draggedCreateStreamElement) {
                draggedCreateStreamElement.style.opacity = '';
            }

            // Clear all border highlights
            document.querySelectorAll('.create-stream-item').forEach(item => {
                item.style.borderTop = '';
            });
        }

        // ============================================================
        // Clone Lineup Functions
        // ============================================================

        let cloneLineupState = {
            selectedLineupId: null,
            selectedLineupName: null,
            previewData: null,
            streamReader: null,
            importInProgress: false
        };

        // Populate clone country dropdown from database
        async function populateCloneCountries() {
            try {
                const response = await fetch('/api/metadata');
                const data = await response.json();

                const cloneCountrySelect = document.getElementById('cloneCountry');
                cloneCountrySelect.innerHTML = ''; // Clear all options

                // Country name mappings
                const countryNames = {
                    'AIA': 'Anguilla', 'ARG': 'Argentina', 'AUS': 'Australia', 'AUT': 'Austria',
                    'BEL': 'Belgium', 'BLZ': 'Belize', 'BMU': 'Bermuda', 'BRA': 'Brazil',
                    'BRB': 'Barbados', 'CAN': 'Canada', 'CHE': 'Switzerland', 'CHL': 'Chile',
                    'COL': 'Colombia', 'CRI': 'Costa Rica', 'CYM': 'Cayman Islands', 'DEU': 'Germany',
                    'DNK': 'Denmark', 'DOM': 'Dominican Republic', 'ECU': 'Ecuador', 'ESP': 'Spain',
                    'FIN': 'Finland', 'FRA': 'France', 'GBR': 'United Kingdom', 'GRC': 'Greece',
                    'HND': 'Honduras', 'IRL': 'Ireland', 'ISL': 'Iceland', 'ITA': 'Italy',
                    'JAM': 'Jamaica', 'LUX': 'Luxembourg', 'MEX': 'Mexico', 'NLD': 'Netherlands',
                    'NOR': 'Norway', 'NZL': 'New Zealand', 'PAN': 'Panama', 'PER': 'Peru',
                    'PRT': 'Portugal', 'SWE': 'Sweden', 'TCA': 'Turks and Caicos',
                    'TTO': 'Trinidad and Tobago', 'URY': 'Uruguay', 'VEN': 'Venezuela'
                };

                // Add USA first if it exists
                if (data.countries.includes('USA')) {
                    const usaOption = document.createElement('option');
                    usaOption.value = 'USA';
                    usaOption.textContent = 'USA - United States';
                    usaOption.selected = true;
                    cloneCountrySelect.appendChild(usaOption);

                    // Add divider
                    const divider = document.createElement('option');
                    divider.disabled = true;
                    divider.textContent = '‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ';
                    cloneCountrySelect.appendChild(divider);
                }

                // Add all countries alphabetically (excluding USA since it's already added)
                data.countries.sort().forEach(country => {
                    if (country !== 'USA') {
                        const option = document.createElement('option');
                        option.value = country;
                        option.textContent = countryNames[country]
                            ? `${country} - ${countryNames[country]}`
                            : country;
                        cloneCountrySelect.appendChild(option);
                    }
                });
            } catch (error) {
                console.error('Failed to populate clone countries:', error);
                // Fallback to USA only
                const cloneCountrySelect = document.getElementById('cloneCountry');
                cloneCountrySelect.innerHTML = '<option value="USA">USA - United States</option>';
            }
        }

        async function openCloneLineupModal() {
            // Reset state
            cloneLineupState = {
                selectedLineupId: null,
                selectedLineupName: null,
                previewData: null,
                streamReader: null,
                importInProgress: false
            };

            // Reset UI
            document.getElementById('cloneZipCode').value = '';
            document.getElementById('cloneSearchResults').style.display = 'none';
            document.getElementById('cloneStep1').style.display = 'block';
            document.getElementById('cloneStep2').style.display = 'none';
            document.getElementById('cloneStep3').style.display = 'none';
            document.getElementById('cloneStep4').style.display = 'none';

            // Populate countries and groups
            await populateCloneCountries();
            filterGroupsInClone();

            // Show modal
            document.getElementById('cloneLineupModal').style.display = 'flex';
        }

        function filterGroupsInClone() {
            const filterText = document.getElementById('cloneGroupFilter').value.toLowerCase();
            const showCustomOnly = document.getElementById('cloneShowCustomOnly').checked;
            const select = document.getElementById('cloneDefaultGroup');

            // Get default group from settings
            const settings = JSON.parse(localStorage.getItem('appSettings') || '{}');
            const defaultGroupId = settings.channelCreation?.defaultGroup;

            // Clear and rebuild
            select.innerHTML = '<option value="">-- No Group --</option>';

            let filteredCount = 0;
            let defaultFound = false;

            dispatcharrGroups.forEach(group => {
                // Filter by text
                if (filterText && !group.name.toLowerCase().includes(filterText)) {
                    return;
                }

                // Filter by custom only
                if (showCustomOnly && group.m3u_playlists && group.m3u_playlists.length > 0) {
                    return;
                }

                const option = document.createElement('option');
                option.value = group.id;
                option.textContent = group.name;

                // Select default group if matches
                if (defaultGroupId && group.id === defaultGroupId) {
                    option.selected = true;
                    defaultFound = true;
                }

                select.appendChild(option);
                filteredCount++;
            });

            // Update status
            const statusDiv = document.getElementById('cloneGroupFilterStatus');
            if (filteredCount === 0) {
                statusDiv.textContent = 'No groups match your filter';
                statusDiv.style.color = '#ff6b6b';
            } else if (filterText || showCustomOnly) {
                statusDiv.textContent = `Showing ${filteredCount} of ${dispatcharrGroups.length} groups`;
                statusDiv.style.color = '#999';
            } else {
                statusDiv.textContent = `${dispatcharrGroups.length} groups available`;
                statusDiv.style.color = '#999';
            }
        }

        function closeCloneLineupModal() {
            // Cancel any active stream
            if (cloneLineupState.streamReader) {
                try {
                    cloneLineupState.streamReader.cancel();
                } catch (error) {
                    console.error('Error cancelling stream:', error);
                }
                cloneLineupState.streamReader = null;
            }

            document.getElementById('cloneLineupModal').style.display = 'none';

            // Reload channels if import was completed
            if (cloneLineupState.importInProgress === 'completed') {
                loadDispatcharrChannels();
            }
        }

        async function searchLineupsByZip() {
            const zipCode = document.getElementById('cloneZipCode').value.trim();
            const country = document.getElementById('cloneCountry').value;

            if (!zipCode) {
                showNotification('Please enter a ZIP code', 'warning');
                return;
            }

            try {
                const response = await fetch(`/api/lineups/search-by-zip?zip=${encodeURIComponent(zipCode)}&country=${country}`);
                const data = await response.json();

                if (!response.ok) {
                    throw new Error(data.error || 'Failed to search lineups');
                }

                if (data.lineups.length === 0) {
                    showNotification('No lineups found for this ZIP code', 'info');
                    document.getElementById('cloneSearchResults').style.display = 'none';
                    return;
                }

                // Group lineups by type
                const groupedLineups = {};
                data.lineups.forEach(lineup => {
                    const type = lineup.type || 'OTHER';
                    if (!groupedLineups[type]) {
                        groupedLineups[type] = [];
                    }
                    groupedLineups[type].push(lineup);
                });

                // Render lineup list
                const listContainer = document.getElementById('cloneLineupList');
                listContainer.innerHTML = '';

                const typeOrder = ['CABLE', 'SATELLITE', 'VMVPD', 'OTA', 'OTHER'];
                typeOrder.forEach(type => {
                    if (!groupedLineups[type]) return;

                    const typeHeader = document.createElement('div');
                    typeHeader.style.cssText = 'font-weight: 600; margin-top: 15px; margin-bottom: 8px; color: #667eea; font-size: 0.9rem;';
                    typeHeader.textContent = type;
                    listContainer.appendChild(typeHeader);

                    groupedLineups[type].forEach(lineup => {
                        const lineupItem = document.createElement('div');
                        lineupItem.style.cssText = 'padding: 10px; background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.1); border-radius: 4px; margin-bottom: 8px; cursor: pointer; transition: all 0.2s;';
                        lineupItem.innerHTML = `
                            <div style="font-weight: 600;">${lineup.name || lineup.lineup_id}</div>
                            <div style="font-size: 0.85rem; color: #999; margin-top: 4px;">${lineup.channel_count} channels ‚Ä¢ ${lineup.location || ''}</div>
                        `;
                        lineupItem.onmouseover = () => lineupItem.style.background = 'rgba(102, 126, 234, 0.2)';
                        lineupItem.onmouseout = () => lineupItem.style.background = 'rgba(0,0,0,0.3)';
                        lineupItem.onclick = () => selectLineup(lineup.lineup_id, lineup.name || lineup.lineup_id);
                        listContainer.appendChild(lineupItem);
                    });
                });

                document.getElementById('cloneSearchResults').style.display = 'block';
                showNotification(`Found ${data.lineups.length} lineup(s)`, 'success');

            } catch (error) {
                console.error('Error searching lineups:', error);
                showNotification(error.message, 'error');
            }
        }

        async function selectLineup(lineupId, lineupName) {
            cloneLineupState.selectedLineupId = lineupId;
            cloneLineupState.selectedLineupName = lineupName;

            try {
                const response = await fetch(`/api/lineups/${encodeURIComponent(lineupId)}/preview`);
                const data = await response.json();

                if (!response.ok) {
                    throw new Error(data.error || 'Failed to load lineup preview');
                }

                cloneLineupState.previewData = data;

                // Render preview
                document.getElementById('clonePreviewName').textContent = lineupName;

                const stats = document.getElementById('clonePreviewStats');
                stats.innerHTML = `
                    <div><strong>${data.total_channels}</strong> Total Channels</div>
                    <div><strong>${data.quality_breakdown.HDTV || 0}</strong> HD</div>
                    <div><strong>${data.quality_breakdown.SDTV || 0}</strong> SD</div>
                    <div><strong>${data.quality_breakdown.UHDTV || 0}</strong> 4K</div>
                    <div><strong>${data.quality_breakdown.UNKNOWN || 0}</strong> Unknown</div>
                `;

                const samples = document.getElementById('cloneChannelSamples');
                samples.innerHTML = data.channels.map(ch =>
                    `<div style="padding: 4px 0; border-bottom: 1px solid rgba(255,255,255,0.05);">${ch.channel_number} - ${ch.station_name || ch.call_sign || 'Unknown'} ${ch.video_type ? `(${ch.video_type})` : ''}</div>`
                ).join('');

                // Show preview step
                document.getElementById('cloneStep2').style.display = 'block';
                document.getElementById('cloneStep2').scrollIntoView({ behavior: 'smooth', block: 'nearest' });

            } catch (error) {
                console.error('Error loading lineup preview:', error);
                showNotification(error.message, 'error');
            }
        }

        function showCloneConfiguration() {
            document.getElementById('cloneStep3').style.display = 'block';
            document.getElementById('cloneStep3').scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }

        function hideCloneConfiguration() {
            document.getElementById('cloneStep3').style.display = 'none';
            document.getElementById('cloneStep2').scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }

        async function startCloneImport() {
            // Load Dispatcharr credentials from backend settings
            const settings = await getSettings();
            const dispatcharrUrl = settings.dispatcharr?.url;
            const dispatcharrUsername = settings.dispatcharr?.username;
            const dispatcharrPassword = settings.dispatcharr?.password;

            if (!dispatcharrUrl || !dispatcharrUsername || !dispatcharrPassword) {
                showNotification('Please configure Dispatcharr credentials in Settings first', 'error');
                return;
            }

            // Validate quality filters
            const includeHd = document.getElementById('cloneIncludeHd').checked;
            const includeSd = document.getElementById('cloneIncludeSd').checked;
            const includeUhd = document.getElementById('cloneIncludeUhd').checked;
            const includeUnknown = document.getElementById('cloneIncludeUnknown').checked;

            if (!includeHd && !includeSd && !includeUhd && !includeUnknown) {
                showNotification('Please select at least one quality type', 'warning');
                return;
            }

            // Gather configuration
            const config = {
                // Dispatcharr credentials
                dispatcharrUrl: dispatcharrUrl,
                dispatcharrUsername: dispatcharrUsername,
                dispatcharrPassword: dispatcharrPassword,
                // Quality filters
                includeSd: includeSd,
                includeHd: includeHd,
                includeUhd: includeUhd,
                includeUnknown: includeUnknown,
                // Channel settings
                channelOffset: parseInt(document.getElementById('cloneChannelOffset').value) || 0,
                // Data usage
                useLogos: document.getElementById('cloneUseLogos').checked,
                useCallSign: document.getElementById('cloneUseCallSign').checked,
                useStationId: document.getElementById('cloneUseStationId').checked,
                // Group assignment
                defaultGroupId: parseInt(document.getElementById('cloneDefaultGroup').value) || null,
                // Conflict handling
                numberConflict: document.getElementById('cloneNumberConflict').value,
                stationConflict: document.getElementById('cloneStationConflict').value
            };

            // Show progress step
            document.getElementById('cloneStep1').style.display = 'none';
            document.getElementById('cloneStep2').style.display = 'none';
            document.getElementById('cloneStep3').style.display = 'none';
            document.getElementById('cloneStep4').style.display = 'block';
            document.getElementById('cloneCancelButton').style.display = 'inline-block';
            document.getElementById('cloneFinishButton').style.display = 'none';

            // Reset progress UI
            document.getElementById('cloneProgressText').textContent = 'Preparing import...';
            document.getElementById('cloneProgressFill').style.width = '0%';
            document.getElementById('cloneProgressStatus').innerHTML = '';

            cloneLineupState.importInProgress = true;

            // Start SSE import with fetch streaming
            const url = `/api/lineups/${encodeURIComponent(cloneLineupState.selectedLineupId)}/import`;

            try {
                const response = await fetch(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(config)
                });

                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    throw new Error(errorData.error || 'Failed to start import');
                }

                // Read SSE stream from response body
                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let buffer = '';

                // Store reader for cancellation
                cloneLineupState.streamReader = reader;

                const processStream = async () => {
                    try {
                        while (true) {
                            const { done, value } = await reader.read();

                            if (done) {
                                break;
                            }

                            // Decode and add to buffer
                            buffer += decoder.decode(value, { stream: true });

                            // Process complete SSE messages (delimited by \n\n)
                            const messages = buffer.split('\n\n');
                            buffer = messages.pop() || ''; // Keep incomplete message in buffer

                            for (const message of messages) {
                                if (!message.trim()) continue;

                                // Parse SSE format: "data: {...}\n"
                                const dataMatch = message.match(/data: (.+)/);
                                if (!dataMatch) continue;

                                try {
                                    const data = JSON.parse(dataMatch[1]);

                                    if (data.status === 'progress') {
                                        // Update progress
                                        const percent = Math.round((data.processed / data.total) * 100);
                                        document.getElementById('cloneProgressText').textContent = `Processing ${data.processed}/${data.total} channels (${percent}%)`;
                                        document.getElementById('cloneProgressFill').style.width = percent + '%';

                                        if (data.message) {
                                            const statusDiv = document.getElementById('cloneProgressStatus');
                                            statusDiv.innerHTML = `<div style="margin-bottom: 4px;">${data.message}</div>` + statusDiv.innerHTML;
                                            statusDiv.scrollTop = 0;
                                        }
                                    } else if (data.status === 'complete') {
                                        // Import complete
                                        document.getElementById('cloneProgressText').textContent = 'Import Complete!';
                                        document.getElementById('cloneProgressFill').style.width = '100%';

                                        const statusDiv = document.getElementById('cloneProgressStatus');
                                        statusDiv.innerHTML = `
                                            <div style="color: #51cf66; font-weight: 600; margin-top: 10px;">‚úì Successfully imported ${data.created} channels</div>
                                            ${data.skipped > 0 ? `<div style="color: #ffd43b; margin-top: 4px;">‚ö† Skipped ${data.skipped} channels (duplicates or errors)</div>` : ''}
                                            ${data.errors > 0 ? `<div style="color: #ff6b6b; margin-top: 4px;">‚úó ${data.errors} errors</div>` : ''}
                                        ` + statusDiv.innerHTML;

                                        document.getElementById('cloneCancelButton').style.display = 'none';
                                        document.getElementById('cloneFinishButton').style.display = 'inline-block';

                                        cloneLineupState.importInProgress = 'completed';
                                        showNotification(`Import complete: ${data.created} channels created`, 'success');
                                    } else if (data.status === 'error') {
                                        // Error occurred
                                        document.getElementById('cloneProgressText').textContent = 'Import Failed';
                                        const statusDiv = document.getElementById('cloneProgressStatus');
                                        statusDiv.innerHTML = `<div style="color: #ff6b6b; font-weight: 600;">Error: ${data.error}</div>` + statusDiv.innerHTML;

                                        document.getElementById('cloneCancelButton').textContent = 'Close';
                                        cloneLineupState.importInProgress = false;
                                        showNotification('Import failed: ' + data.error, 'error');
                                    }
                                } catch (error) {
                                    console.error('Error parsing SSE data:', error);
                                }
                            }
                        }
                    } catch (error) {
                        if (error.name === 'AbortError') {
                            console.log('Stream cancelled by user');
                        } else {
                            console.error('Stream error:', error);
                            if (cloneLineupState.importInProgress === true) {
                                document.getElementById('cloneProgressText').textContent = 'Connection Error';
                                const statusDiv = document.getElementById('cloneProgressStatus');
                                statusDiv.innerHTML = `<div style="color: #ff6b6b; font-weight: 600;">Connection lost. Import may have been interrupted.</div>` + statusDiv.innerHTML;
                                document.getElementById('cloneCancelButton').textContent = 'Close';
                                cloneLineupState.importInProgress = false;
                                showNotification('Connection error during import', 'error');
                            }
                        }
                    }
                };

                // Start processing stream
                processStream();

            } catch (error) {
                console.error('Error starting import:', error);
                showNotification(error.message, 'error');
                cloneLineupState.importInProgress = false;
            }
        }

        function cancelCloneImport() {
            if (cloneLineupState.streamReader) {
                try {
                    cloneLineupState.streamReader.cancel();
                } catch (error) {
                    console.error('Error cancelling stream:', error);
                }
                cloneLineupState.streamReader = null;
            }

            if (cloneLineupState.importInProgress === true) {
                document.getElementById('cloneProgressText').textContent = 'Import Cancelled';
                const statusDiv = document.getElementById('cloneProgressStatus');
                statusDiv.innerHTML = `<div style="color: #ffd43b; font-weight: 600;">Import cancelled by user</div>` + statusDiv.innerHTML;
                cloneLineupState.importInProgress = false;
            }

            closeCloneLineupModal();
        }

        // ============================================================
        // End Clone Lineup Functions
        // ============================================================

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', async function() {
            // PRIORITY: Show tabs as quickly as possible
            await updateTabVisibility();

            // Then load everything else in the background
            await loadSettings();
            loadDatabaseMetadata();
            populateEmbyCountries();
        });
    </script>
</body>
</html>